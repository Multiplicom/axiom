define("AXM", [], function() { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 38);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
 //@ sourceMappingURL=jquery-1.10.2.min.map
 */
(function (e, t) {
  var n,
      r,
      i = typeof t === "undefined" ? "undefined" : _typeof(t),
      o = e.location,
      a = e.document,
      s = a.documentElement,
      l = e.jQuery,
      u = e.$,
      c = {},
      p = [],
      f = "1.10.2",
      d = p.concat,
      h = p.push,
      g = p.slice,
      m = p.indexOf,
      y = c.toString,
      v = c.hasOwnProperty,
      b = f.trim,
      x = function x(e, t) {
    return new x.fn.init(e, t, r);
  },
      w = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
      T = /\S+/g,
      C = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      N = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      k = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      E = /^[\],:{}\s]*$/,
      S = /(?:^|:|,)(?:\s*\[)+/g,
      A = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
      j = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,
      D = /^-ms-/,
      L = /-([\da-z])/gi,
      H = function H(e, t) {
    return t.toUpperCase();
  },
      q = function q(e) {
    (a.addEventListener || "load" === e.type || "complete" === a.readyState) && (_(), x.ready());
  },
      _ = function _() {
    a.addEventListener ? (a.removeEventListener("DOMContentLoaded", q, !1), e.removeEventListener("load", q, !1)) : (a.detachEvent("onreadystatechange", q), e.detachEvent("onload", q));
  };x.fn = x.prototype = { jquery: f, constructor: x, init: function init(e, n, r) {
      var i, o;if (!e) return this;if ("string" == typeof e) {
        if (i = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : N.exec(e), !i || !i[1] && n) return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);if (i[1]) {
          if (n = n instanceof x ? n[0] : n, x.merge(this, x.parseHTML(i[1], n && n.nodeType ? n.ownerDocument || n : a, !0)), k.test(i[1]) && x.isPlainObject(n)) for (i in n) {
            x.isFunction(this[i]) ? this[i](n[i]) : this.attr(i, n[i]);
          }return this;
        }if (o = a.getElementById(i[2]), o && o.parentNode) {
          if (o.id !== i[2]) return r.find(e);this.length = 1, this[0] = o;
        }return this.context = a, this.selector = e, this;
      }return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : x.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, this.context = e.context), x.makeArray(e, this));
    }, selector: "", length: 0, toArray: function toArray() {
      return g.call(this);
    }, get: function get(e) {
      return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e];
    }, pushStack: function pushStack(e) {
      var t = x.merge(this.constructor(), e);return t.prevObject = this, t.context = this.context, t;
    }, each: function each(e, t) {
      return x.each(this, e, t);
    }, ready: function ready(e) {
      return x.ready.promise().done(e), this;
    }, slice: function slice() {
      return this.pushStack(g.apply(this, arguments));
    }, first: function first() {
      return this.eq(0);
    }, last: function last() {
      return this.eq(-1);
    }, eq: function eq(e) {
      var t = this.length,
          n = +e + (0 > e ? t : 0);return this.pushStack(n >= 0 && t > n ? [this[n]] : []);
    }, map: function map(e) {
      return this.pushStack(x.map(this, function (t, n) {
        return e.call(t, n, t);
      }));
    }, end: function end() {
      return this.prevObject || this.constructor(null);
    }, push: h, sort: [].sort, splice: [].splice }, x.fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {
    var e,
        n,
        r,
        i,
        o,
        a,
        s = arguments[0] || {},
        l = 1,
        u = arguments.length,
        c = !1;for ("boolean" == typeof s && (c = s, s = arguments[1] || {}, l = 2), "object" == (typeof s === "undefined" ? "undefined" : _typeof(s)) || x.isFunction(s) || (s = {}), u === l && (s = this, --l); u > l; l++) {
      if (null != (o = arguments[l])) for (i in o) {
        e = s[i], r = o[i], s !== r && (c && r && (x.isPlainObject(r) || (n = x.isArray(r))) ? (n ? (n = !1, a = e && x.isArray(e) ? e : []) : a = e && x.isPlainObject(e) ? e : {}, s[i] = x.extend(c, a, r)) : r !== t && (s[i] = r));
      }
    }return s;
  }, x.extend({ expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""), noConflict: function noConflict(t) {
      return e.$ === x && (e.$ = u), t && e.jQuery === x && (e.jQuery = l), x;
    }, isReady: !1, readyWait: 1, holdReady: function holdReady(e) {
      e ? x.readyWait++ : x.ready(!0);
    }, ready: function ready(e) {
      if (e === !0 ? ! --x.readyWait : !x.isReady) {
        if (!a.body) return setTimeout(x.ready);x.isReady = !0, e !== !0 && --x.readyWait > 0 || (n.resolveWith(a, [x]), x.fn.trigger && x(a).trigger("ready").off("ready"));
      }
    }, isFunction: function isFunction(e) {
      return "function" === x.type(e);
    }, isArray: Array.isArray || function (e) {
      return "array" === x.type(e);
    }, isWindow: function isWindow(e) {
      return null != e && e == e.window;
    }, isNumeric: function isNumeric(e) {
      return !isNaN(parseFloat(e)) && isFinite(e);
    }, type: function type(e) {
      return null == e ? e + "" : "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) || "function" == typeof e ? c[y.call(e)] || "object" : typeof e === "undefined" ? "undefined" : _typeof(e);
    }, isPlainObject: function isPlainObject(e) {
      var n;if (!e || "object" !== x.type(e) || e.nodeType || x.isWindow(e)) return !1;try {
        if (e.constructor && !v.call(e, "constructor") && !v.call(e.constructor.prototype, "isPrototypeOf")) return !1;
      } catch (r) {
        return !1;
      }if (x.support.ownLast) for (n in e) {
        return v.call(e, n);
      }for (n in e) {}return n === t || v.call(e, n);
    }, isEmptyObject: function isEmptyObject(e) {
      var t;for (t in e) {
        return !1;
      }return !0;
    }, error: function error(e) {
      throw Error(e);
    }, parseHTML: function parseHTML(e, t, n) {
      if (!e || "string" != typeof e) return null;"boolean" == typeof t && (n = t, t = !1), t = t || a;var r = k.exec(e),
          i = !n && [];return r ? [t.createElement(r[1])] : (r = x.buildFragment([e], t, i), i && x(i).remove(), x.merge([], r.childNodes));
    }, parseJSON: function parseJSON(n) {
      return e.JSON && e.JSON.parse ? e.JSON.parse(n) : null === n ? n : "string" == typeof n && (n = x.trim(n), n && E.test(n.replace(A, "@").replace(j, "]").replace(S, ""))) ? Function("return " + n)() : (x.error("Invalid JSON: " + n), t);
    }, parseXML: function parseXML(n) {
      var r, i;if (!n || "string" != typeof n) return null;try {
        e.DOMParser ? (i = new DOMParser(), r = i.parseFromString(n, "text/xml")) : (r = new ActiveXObject("Microsoft.XMLDOM"), r.async = "false", r.loadXML(n));
      } catch (o) {
        r = t;
      }return r && r.documentElement && !r.getElementsByTagName("parsererror").length || x.error("Invalid XML: " + n), r;
    }, noop: function noop() {}, globalEval: function globalEval(t) {
      t && x.trim(t) && (e.execScript || function (t) {
        e.eval.call(e, t);
      })(t);
    }, camelCase: function camelCase(e) {
      return e.replace(D, "ms-").replace(L, H);
    }, nodeName: function nodeName(e, t) {
      return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
    }, each: function each(e, t, n) {
      var r,
          i = 0,
          o = e.length,
          a = M(e);if (n) {
        if (a) {
          for (; o > i; i++) {
            if (r = t.apply(e[i], n), r === !1) break;
          }
        } else for (i in e) {
          if (r = t.apply(e[i], n), r === !1) break;
        }
      } else if (a) {
        for (; o > i; i++) {
          if (r = t.call(e[i], i, e[i]), r === !1) break;
        }
      } else for (i in e) {
        if (r = t.call(e[i], i, e[i]), r === !1) break;
      }return e;
    }, trim: b && !b.call("\uFEFF\xA0") ? function (e) {
      return null == e ? "" : b.call(e);
    } : function (e) {
      return null == e ? "" : (e + "").replace(C, "");
    }, makeArray: function makeArray(e, t) {
      var n = t || [];return null != e && (M(Object(e)) ? x.merge(n, "string" == typeof e ? [e] : e) : h.call(n, e)), n;
    }, inArray: function inArray(e, t, n) {
      var r;if (t) {
        if (m) return m.call(t, e, n);for (r = t.length, n = n ? 0 > n ? Math.max(0, r + n) : n : 0; r > n; n++) {
          if (n in t && t[n] === e) return n;
        }
      }return -1;
    }, merge: function merge(e, n) {
      var r = n.length,
          i = e.length,
          o = 0;if ("number" == typeof r) for (; r > o; o++) {
        e[i++] = n[o];
      } else while (n[o] !== t) {
        e[i++] = n[o++];
      }return e.length = i, e;
    }, grep: function grep(e, t, n) {
      var r,
          i = [],
          o = 0,
          a = e.length;for (n = !!n; a > o; o++) {
        r = !!t(e[o], o), n !== r && i.push(e[o]);
      }return i;
    }, map: function map(e, t, n) {
      var r,
          i = 0,
          o = e.length,
          a = M(e),
          s = [];if (a) for (; o > i; i++) {
        r = t(e[i], i, n), null != r && (s[s.length] = r);
      } else for (i in e) {
        r = t(e[i], i, n), null != r && (s[s.length] = r);
      }return d.apply([], s);
    }, guid: 1, proxy: function proxy(e, n) {
      var r, i, o;return "string" == typeof n && (o = e[n], n = e, e = o), x.isFunction(e) ? (r = g.call(arguments, 2), i = function i() {
        return e.apply(n || this, r.concat(g.call(arguments)));
      }, i.guid = e.guid = e.guid || x.guid++, i) : t;
    }, access: function access(e, n, r, i, o, a, s) {
      var l = 0,
          u = e.length,
          c = null == r;if ("object" === x.type(r)) {
        o = !0;for (l in r) {
          x.access(e, n, l, r[l], !0, a, s);
        }
      } else if (i !== t && (o = !0, x.isFunction(i) || (s = !0), c && (s ? (n.call(e, i), n = null) : (c = n, n = function n(e, t, _n2) {
        return c.call(x(e), _n2);
      })), n)) for (; u > l; l++) {
        n(e[l], r, s ? i : i.call(e[l], l, n(e[l], r)));
      }return o ? e : c ? n.call(e) : u ? n(e[0], r) : a;
    }, now: function now() {
      return new Date().getTime();
    }, swap: function swap(e, t, n, r) {
      var i,
          o,
          a = {};for (o in t) {
        a[o] = e.style[o], e.style[o] = t[o];
      }i = n.apply(e, r || []);for (o in t) {
        e.style[o] = a[o];
      }return i;
    } }), x.ready.promise = function (t) {
    if (!n) if (n = x.Deferred(), "complete" === a.readyState) setTimeout(x.ready);else if (a.addEventListener) a.addEventListener("DOMContentLoaded", q, !1), e.addEventListener("load", q, !1);else {
      a.attachEvent("onreadystatechange", q), e.attachEvent("onload", q);var r = !1;try {
        r = null == e.frameElement && a.documentElement;
      } catch (i) {}r && r.doScroll && function o() {
        if (!x.isReady) {
          try {
            r.doScroll("left");
          } catch (e) {
            return setTimeout(o, 50);
          }_(), x.ready();
        }
      }();
    }return n.promise(t);
  }, x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (e, t) {
    c["[object " + t + "]"] = t.toLowerCase();
  });function M(e) {
    var t = e.length,
        n = x.type(e);return x.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || "function" !== n && (0 === t || "number" == typeof t && t > 0 && t - 1 in e);
  }r = x(a), function (e, t) {
    var n,
        r,
        i,
        o,
        a,
        s,
        l,
        u,
        c,
        p,
        f,
        d,
        h,
        g,
        m,
        y,
        v,
        b = "sizzle" + -new Date(),
        w = e.document,
        T = 0,
        C = 0,
        N = st(),
        k = st(),
        E = st(),
        S = !1,
        A = function A(e, t) {
      return e === t ? (S = !0, 0) : 0;
    },
        j = typeof t === "undefined" ? "undefined" : _typeof(t),
        D = 1 << 31,
        L = {}.hasOwnProperty,
        H = [],
        q = H.pop,
        _ = H.push,
        M = H.push,
        O = H.slice,
        F = H.indexOf || function (e) {
      var t = 0,
          n = this.length;for (; n > t; t++) {
        if (this[t] === e) return t;
      }return -1;
    },
        B = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        P = "[\\x20\\t\\r\\n\\f]",
        R = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        W = R.replace("w", "w#"),
        $ = "\\[" + P + "*(" + R + ")" + P + "*(?:([*^$|!~]?=)" + P + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + W + ")|)|)" + P + "*\\]",
        I = ":(" + R + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + $.replace(3, 8) + ")*)|.*)\\)|)",
        z = RegExp("^" + P + "+|((?:^|[^\\\\])(?:\\\\.)*)" + P + "+$", "g"),
        X = RegExp("^" + P + "*," + P + "*"),
        U = RegExp("^" + P + "*([>+~]|" + P + ")" + P + "*"),
        V = RegExp(P + "*[+~]"),
        Y = RegExp("=" + P + "*([^\\]'\"]*)" + P + "*\\]", "g"),
        J = RegExp(I),
        G = RegExp("^" + W + "$"),
        Q = { ID: RegExp("^#(" + R + ")"), CLASS: RegExp("^\\.(" + R + ")"), TAG: RegExp("^(" + R.replace("w", "w*") + ")"), ATTR: RegExp("^" + $), PSEUDO: RegExp("^" + I), CHILD: RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + P + "*(even|odd|(([+-]|)(\\d*)n|)" + P + "*(?:([+-]|)" + P + "*(\\d+)|))" + P + "*\\)|)", "i"), bool: RegExp("^(?:" + B + ")$", "i"), needsContext: RegExp("^" + P + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + P + "*((?:-\\d)?\\d*)" + P + "*\\)|)(?=[^-]|$)", "i") },
        K = /^[^{]+\{\s*\[native \w/,
        Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        et = /^(?:input|select|textarea|button)$/i,
        tt = /^h\d$/i,
        nt = /'|\\/g,
        rt = RegExp("\\\\([\\da-f]{1,6}" + P + "?|(" + P + ")|.)", "ig"),
        it = function it(e, t, n) {
      var r = "0x" + t - 65536;return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r);
    };try {
      M.apply(H = O.call(w.childNodes), w.childNodes), H[w.childNodes.length].nodeType;
    } catch (ot) {
      M = { apply: H.length ? function (e, t) {
          _.apply(e, O.call(t));
        } : function (e, t) {
          var n = e.length,
              r = 0;while (e[n++] = t[r++]) {}e.length = n - 1;
        } };
    }function at(e, t, n, i) {
      var o, a, s, l, u, c, d, m, y, x;if ((t ? t.ownerDocument || t : w) !== f && p(t), t = t || f, n = n || [], !e || "string" != typeof e) return n;if (1 !== (l = t.nodeType) && 9 !== l) return [];if (h && !i) {
        if (o = Z.exec(e)) if (s = o[1]) {
          if (9 === l) {
            if (a = t.getElementById(s), !a || !a.parentNode) return n;if (a.id === s) return n.push(a), n;
          } else if (t.ownerDocument && (a = t.ownerDocument.getElementById(s)) && v(t, a) && a.id === s) return n.push(a), n;
        } else {
          if (o[2]) return M.apply(n, t.getElementsByTagName(e)), n;if ((s = o[3]) && r.getElementsByClassName && t.getElementsByClassName) return M.apply(n, t.getElementsByClassName(s)), n;
        }if (r.qsa && (!g || !g.test(e))) {
          if (m = d = b, y = t, x = 9 === l && e, 1 === l && "object" !== t.nodeName.toLowerCase()) {
            c = mt(e), (d = t.getAttribute("id")) ? m = d.replace(nt, "\\$&") : t.setAttribute("id", m), m = "[id='" + m + "'] ", u = c.length;while (u--) {
              c[u] = m + yt(c[u]);
            }y = V.test(e) && t.parentNode || t, x = c.join(",");
          }if (x) try {
            return M.apply(n, y.querySelectorAll(x)), n;
          } catch (T) {} finally {
            d || t.removeAttribute("id");
          }
        }
      }return kt(e.replace(z, "$1"), t, n, i);
    }function st() {
      var e = [];function t(n, r) {
        return e.push(n += " ") > o.cacheLength && delete t[e.shift()], t[n] = r;
      }return t;
    }function lt(e) {
      return e[b] = !0, e;
    }function ut(e) {
      var t = f.createElement("div");try {
        return !!e(t);
      } catch (n) {
        return !1;
      } finally {
        t.parentNode && t.parentNode.removeChild(t), t = null;
      }
    }function ct(e, t) {
      var n = e.split("|"),
          r = e.length;while (r--) {
        o.attrHandle[n[r]] = t;
      }
    }function pt(e, t) {
      var n = t && e,
          r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || D) - (~e.sourceIndex || D);if (r) return r;if (n) while (n = n.nextSibling) {
        if (n === t) return -1;
      }return e ? 1 : -1;
    }function ft(e) {
      return function (t) {
        var n = t.nodeName.toLowerCase();return "input" === n && t.type === e;
      };
    }function dt(e) {
      return function (t) {
        var n = t.nodeName.toLowerCase();return ("input" === n || "button" === n) && t.type === e;
      };
    }function ht(e) {
      return lt(function (t) {
        return t = +t, lt(function (n, r) {
          var i,
              o = e([], n.length, t),
              a = o.length;while (a--) {
            n[i = o[a]] && (n[i] = !(r[i] = n[i]));
          }
        });
      });
    }s = at.isXML = function (e) {
      var t = e && (e.ownerDocument || e).documentElement;return t ? "HTML" !== t.nodeName : !1;
    }, r = at.support = {}, p = at.setDocument = function (e) {
      var n = e ? e.ownerDocument || e : w,
          i = n.defaultView;return n !== f && 9 === n.nodeType && n.documentElement ? (f = n, d = n.documentElement, h = !s(n), i && i.attachEvent && i !== i.top && i.attachEvent("onbeforeunload", function () {
        p();
      }), r.attributes = ut(function (e) {
        return e.className = "i", !e.getAttribute("className");
      }), r.getElementsByTagName = ut(function (e) {
        return e.appendChild(n.createComment("")), !e.getElementsByTagName("*").length;
      }), r.getElementsByClassName = ut(function (e) {
        return e.innerHTML = "<div class='a'></div><div class='a i'></div>", e.firstChild.className = "i", 2 === e.getElementsByClassName("i").length;
      }), r.getById = ut(function (e) {
        return d.appendChild(e).id = b, !n.getElementsByName || !n.getElementsByName(b).length;
      }), r.getById ? (o.find.ID = function (e, t) {
        if (_typeof(t.getElementById) !== j && h) {
          var n = t.getElementById(e);return n && n.parentNode ? [n] : [];
        }
      }, o.filter.ID = function (e) {
        var t = e.replace(rt, it);return function (e) {
          return e.getAttribute("id") === t;
        };
      }) : (delete o.find.ID, o.filter.ID = function (e) {
        var t = e.replace(rt, it);return function (e) {
          var n = _typeof(e.getAttributeNode) !== j && e.getAttributeNode("id");return n && n.value === t;
        };
      }), o.find.TAG = r.getElementsByTagName ? function (e, n) {
        return _typeof(n.getElementsByTagName) !== j ? n.getElementsByTagName(e) : t;
      } : function (e, t) {
        var n,
            r = [],
            i = 0,
            o = t.getElementsByTagName(e);if ("*" === e) {
          while (n = o[i++]) {
            1 === n.nodeType && r.push(n);
          }return r;
        }return o;
      }, o.find.CLASS = r.getElementsByClassName && function (e, n) {
        return _typeof(n.getElementsByClassName) !== j && h ? n.getElementsByClassName(e) : t;
      }, m = [], g = [], (r.qsa = K.test(n.querySelectorAll)) && (ut(function (e) {
        e.innerHTML = "<select><option selected=''></option></select>", e.querySelectorAll("[selected]").length || g.push("\\[" + P + "*(?:value|" + B + ")"), e.querySelectorAll(":checked").length || g.push(":checked");
      }), ut(function (e) {
        var t = n.createElement("input");t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("t", ""), e.querySelectorAll("[t^='']").length && g.push("[*^$]=" + P + "*(?:''|\"\")"), e.querySelectorAll(":enabled").length || g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:");
      })), (r.matchesSelector = K.test(y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)) && ut(function (e) {
        r.disconnectedMatch = y.call(e, "div"), y.call(e, "[s!='']:x"), m.push("!=", I);
      }), g = g.length && RegExp(g.join("|")), m = m.length && RegExp(m.join("|")), v = K.test(d.contains) || d.compareDocumentPosition ? function (e, t) {
        var n = 9 === e.nodeType ? e.documentElement : e,
            r = t && t.parentNode;return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
      } : function (e, t) {
        if (t) while (t = t.parentNode) {
          if (t === e) return !0;
        }return !1;
      }, A = d.compareDocumentPosition ? function (e, t) {
        if (e === t) return S = !0, 0;var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t);return i ? 1 & i || !r.sortDetached && t.compareDocumentPosition(e) === i ? e === n || v(w, e) ? -1 : t === n || v(w, t) ? 1 : c ? F.call(c, e) - F.call(c, t) : 0 : 4 & i ? -1 : 1 : e.compareDocumentPosition ? -1 : 1;
      } : function (e, t) {
        var r,
            i = 0,
            o = e.parentNode,
            a = t.parentNode,
            s = [e],
            l = [t];if (e === t) return S = !0, 0;if (!o || !a) return e === n ? -1 : t === n ? 1 : o ? -1 : a ? 1 : c ? F.call(c, e) - F.call(c, t) : 0;if (o === a) return pt(e, t);r = e;while (r = r.parentNode) {
          s.unshift(r);
        }r = t;while (r = r.parentNode) {
          l.unshift(r);
        }while (s[i] === l[i]) {
          i++;
        }return i ? pt(s[i], l[i]) : s[i] === w ? -1 : l[i] === w ? 1 : 0;
      }, n) : f;
    }, at.matches = function (e, t) {
      return at(e, null, null, t);
    }, at.matchesSelector = function (e, t) {
      if ((e.ownerDocument || e) !== f && p(e), t = t.replace(Y, "='$1']"), !(!r.matchesSelector || !h || m && m.test(t) || g && g.test(t))) try {
        var n = y.call(e, t);if (n || r.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n;
      } catch (i) {}return at(t, f, null, [e]).length > 0;
    }, at.contains = function (e, t) {
      return (e.ownerDocument || e) !== f && p(e), v(e, t);
    }, at.attr = function (e, n) {
      (e.ownerDocument || e) !== f && p(e);var i = o.attrHandle[n.toLowerCase()],
          a = i && L.call(o.attrHandle, n.toLowerCase()) ? i(e, n, !h) : t;return a === t ? r.attributes || !h ? e.getAttribute(n) : (a = e.getAttributeNode(n)) && a.specified ? a.value : null : a;
    }, at.error = function (e) {
      throw Error("Syntax error, unrecognized expression: " + e);
    }, at.uniqueSort = function (e) {
      var t,
          n = [],
          i = 0,
          o = 0;if (S = !r.detectDuplicates, c = !r.sortStable && e.slice(0), e.sort(A), S) {
        while (t = e[o++]) {
          t === e[o] && (i = n.push(o));
        }while (i--) {
          e.splice(n[i], 1);
        }
      }return e;
    }, a = at.getText = function (e) {
      var t,
          n = "",
          r = 0,
          i = e.nodeType;if (i) {
        if (1 === i || 9 === i || 11 === i) {
          if ("string" == typeof e.textContent) return e.textContent;for (e = e.firstChild; e; e = e.nextSibling) {
            n += a(e);
          }
        } else if (3 === i || 4 === i) return e.nodeValue;
      } else for (; t = e[r]; r++) {
        n += a(t);
      }return n;
    }, o = at.selectors = { cacheLength: 50, createPseudo: lt, match: Q, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function ATTR(e) {
          return e[1] = e[1].replace(rt, it), e[3] = (e[4] || e[5] || "").replace(rt, it), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
        }, CHILD: function CHILD(e) {
          return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || at.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && at.error(e[0]), e;
        }, PSEUDO: function PSEUDO(e) {
          var n,
              r = !e[5] && e[2];return Q.CHILD.test(e[0]) ? null : (e[3] && e[4] !== t ? e[2] = e[4] : r && J.test(r) && (n = mt(r, !0)) && (n = r.indexOf(")", r.length - n) - r.length) && (e[0] = e[0].slice(0, n), e[2] = r.slice(0, n)), e.slice(0, 3));
        } }, filter: { TAG: function TAG(e) {
          var t = e.replace(rt, it).toLowerCase();return "*" === e ? function () {
            return !0;
          } : function (e) {
            return e.nodeName && e.nodeName.toLowerCase() === t;
          };
        }, CLASS: function CLASS(e) {
          var t = N[e + " "];return t || (t = RegExp("(^|" + P + ")" + e + "(" + P + "|$)")) && N(e, function (e) {
            return t.test("string" == typeof e.className && e.className || _typeof(e.getAttribute) !== j && e.getAttribute("class") || "");
          });
        }, ATTR: function ATTR(e, t, n) {
          return function (r) {
            var i = at.attr(r, e);return null == i ? "!=" === t : t ? (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" : !1) : !0;
          };
        }, CHILD: function CHILD(e, t, n, r, i) {
          var o = "nth" !== e.slice(0, 3),
              a = "last" !== e.slice(-4),
              s = "of-type" === t;return 1 === r && 0 === i ? function (e) {
            return !!e.parentNode;
          } : function (t, n, l) {
            var u,
                c,
                p,
                f,
                d,
                h,
                g = o !== a ? "nextSibling" : "previousSibling",
                m = t.parentNode,
                y = s && t.nodeName.toLowerCase(),
                v = !l && !s;if (m) {
              if (o) {
                while (g) {
                  p = t;while (p = p[g]) {
                    if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) return !1;
                  }h = g = "only" === e && !h && "nextSibling";
                }return !0;
              }if (h = [a ? m.firstChild : m.lastChild], a && v) {
                c = m[b] || (m[b] = {}), u = c[e] || [], d = u[0] === T && u[1], f = u[0] === T && u[2], p = d && m.childNodes[d];while (p = ++d && p && p[g] || (f = d = 0) || h.pop()) {
                  if (1 === p.nodeType && ++f && p === t) {
                    c[e] = [T, d, f];break;
                  }
                }
              } else if (v && (u = (t[b] || (t[b] = {}))[e]) && u[0] === T) f = u[1];else while (p = ++d && p && p[g] || (f = d = 0) || h.pop()) {
                if ((s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) && ++f && (v && ((p[b] || (p[b] = {}))[e] = [T, f]), p === t)) break;
              }return f -= i, f === r || 0 === f % r && f / r >= 0;
            }
          };
        }, PSEUDO: function PSEUDO(e, t) {
          var n,
              r = o.pseudos[e] || o.setFilters[e.toLowerCase()] || at.error("unsupported pseudo: " + e);return r[b] ? r(t) : r.length > 1 ? (n = [e, e, "", t], o.setFilters.hasOwnProperty(e.toLowerCase()) ? lt(function (e, n) {
            var i,
                o = r(e, t),
                a = o.length;while (a--) {
              i = F.call(e, o[a]), e[i] = !(n[i] = o[a]);
            }
          }) : function (e) {
            return r(e, 0, n);
          }) : r;
        } }, pseudos: { not: lt(function (e) {
          var t = [],
              n = [],
              r = l(e.replace(z, "$1"));return r[b] ? lt(function (e, t, n, i) {
            var o,
                a = r(e, null, i, []),
                s = e.length;while (s--) {
              (o = a[s]) && (e[s] = !(t[s] = o));
            }
          }) : function (e, i, o) {
            return t[0] = e, r(t, null, o, n), !n.pop();
          };
        }), has: lt(function (e) {
          return function (t) {
            return at(e, t).length > 0;
          };
        }), contains: lt(function (e) {
          return function (t) {
            return (t.textContent || t.innerText || a(t)).indexOf(e) > -1;
          };
        }), lang: lt(function (e) {
          return G.test(e || "") || at.error("unsupported lang: " + e), e = e.replace(rt, it).toLowerCase(), function (t) {
            var n;do {
              if (n = h ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-");
            } while ((t = t.parentNode) && 1 === t.nodeType);return !1;
          };
        }), target: function target(t) {
          var n = e.location && e.location.hash;return n && n.slice(1) === t.id;
        }, root: function root(e) {
          return e === d;
        }, focus: function focus(e) {
          return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
        }, enabled: function enabled(e) {
          return e.disabled === !1;
        }, disabled: function disabled(e) {
          return e.disabled === !0;
        }, checked: function checked(e) {
          var t = e.nodeName.toLowerCase();return "input" === t && !!e.checked || "option" === t && !!e.selected;
        }, selected: function selected(e) {
          return e.parentNode && e.parentNode.selectedIndex, e.selected === !0;
        }, empty: function empty(e) {
          for (e = e.firstChild; e; e = e.nextSibling) {
            if (e.nodeName > "@" || 3 === e.nodeType || 4 === e.nodeType) return !1;
          }return !0;
        }, parent: function parent(e) {
          return !o.pseudos.empty(e);
        }, header: function header(e) {
          return tt.test(e.nodeName);
        }, input: function input(e) {
          return et.test(e.nodeName);
        }, button: function button(e) {
          var t = e.nodeName.toLowerCase();return "input" === t && "button" === e.type || "button" === t;
        }, text: function text(e) {
          var t;return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || t.toLowerCase() === e.type);
        }, first: ht(function () {
          return [0];
        }), last: ht(function (e, t) {
          return [t - 1];
        }), eq: ht(function (e, t, n) {
          return [0 > n ? n + t : n];
        }), even: ht(function (e, t) {
          var n = 0;for (; t > n; n += 2) {
            e.push(n);
          }return e;
        }), odd: ht(function (e, t) {
          var n = 1;for (; t > n; n += 2) {
            e.push(n);
          }return e;
        }), lt: ht(function (e, t, n) {
          var r = 0 > n ? n + t : n;for (; --r >= 0;) {
            e.push(r);
          }return e;
        }), gt: ht(function (e, t, n) {
          var r = 0 > n ? n + t : n;for (; t > ++r;) {
            e.push(r);
          }return e;
        }) } }, o.pseudos.nth = o.pseudos.eq;for (n in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {
      o.pseudos[n] = ft(n);
    }for (n in { submit: !0, reset: !0 }) {
      o.pseudos[n] = dt(n);
    }function gt() {}gt.prototype = o.filters = o.pseudos, o.setFilters = new gt();function mt(e, t) {
      var n,
          r,
          i,
          a,
          s,
          l,
          u,
          c = k[e + " "];if (c) return t ? 0 : c.slice(0);s = e, l = [], u = o.preFilter;while (s) {
        (!n || (r = X.exec(s))) && (r && (s = s.slice(r[0].length) || s), l.push(i = [])), n = !1, (r = U.exec(s)) && (n = r.shift(), i.push({ value: n, type: r[0].replace(z, " ") }), s = s.slice(n.length));for (a in o.filter) {
          !(r = Q[a].exec(s)) || u[a] && !(r = u[a](r)) || (n = r.shift(), i.push({ value: n, type: a, matches: r }), s = s.slice(n.length));
        }if (!n) break;
      }return t ? s.length : s ? at.error(e) : k(e, l).slice(0);
    }function yt(e) {
      var t = 0,
          n = e.length,
          r = "";for (; n > t; t++) {
        r += e[t].value;
      }return r;
    }function vt(e, t, n) {
      var r = t.dir,
          o = n && "parentNode" === r,
          a = C++;return t.first ? function (t, n, i) {
        while (t = t[r]) {
          if (1 === t.nodeType || o) return e(t, n, i);
        }
      } : function (t, n, s) {
        var l,
            u,
            c,
            p = T + " " + a;if (s) {
          while (t = t[r]) {
            if ((1 === t.nodeType || o) && e(t, n, s)) return !0;
          }
        } else while (t = t[r]) {
          if (1 === t.nodeType || o) if (c = t[b] || (t[b] = {}), (u = c[r]) && u[0] === p) {
            if ((l = u[1]) === !0 || l === i) return l === !0;
          } else if (u = c[r] = [p], u[1] = e(t, n, s) || i, u[1] === !0) return !0;
        }
      };
    }function bt(e) {
      return e.length > 1 ? function (t, n, r) {
        var i = e.length;while (i--) {
          if (!e[i](t, n, r)) return !1;
        }return !0;
      } : e[0];
    }function xt(e, t, n, r, i) {
      var o,
          a = [],
          s = 0,
          l = e.length,
          u = null != t;for (; l > s; s++) {
        (o = e[s]) && (!n || n(o, r, i)) && (a.push(o), u && t.push(s));
      }return a;
    }function wt(e, t, n, r, i, o) {
      return r && !r[b] && (r = wt(r)), i && !i[b] && (i = wt(i, o)), lt(function (o, a, s, l) {
        var u,
            c,
            p,
            f = [],
            d = [],
            h = a.length,
            g = o || Nt(t || "*", s.nodeType ? [s] : s, []),
            m = !e || !o && t ? g : xt(g, f, e, s, l),
            y = n ? i || (o ? e : h || r) ? [] : a : m;if (n && n(m, y, s, l), r) {
          u = xt(y, d), r(u, [], s, l), c = u.length;while (c--) {
            (p = u[c]) && (y[d[c]] = !(m[d[c]] = p));
          }
        }if (o) {
          if (i || e) {
            if (i) {
              u = [], c = y.length;while (c--) {
                (p = y[c]) && u.push(m[c] = p);
              }i(null, y = [], u, l);
            }c = y.length;while (c--) {
              (p = y[c]) && (u = i ? F.call(o, p) : f[c]) > -1 && (o[u] = !(a[u] = p));
            }
          }
        } else y = xt(y === a ? y.splice(h, y.length) : y), i ? i(null, a, y, l) : M.apply(a, y);
      });
    }function Tt(e) {
      var t,
          n,
          r,
          i = e.length,
          a = o.relative[e[0].type],
          s = a || o.relative[" "],
          l = a ? 1 : 0,
          c = vt(function (e) {
        return e === t;
      }, s, !0),
          p = vt(function (e) {
        return F.call(t, e) > -1;
      }, s, !0),
          f = [function (e, n, r) {
        return !a && (r || n !== u) || ((t = n).nodeType ? c(e, n, r) : p(e, n, r));
      }];for (; i > l; l++) {
        if (n = o.relative[e[l].type]) f = [vt(bt(f), n)];else {
          if (n = o.filter[e[l].type].apply(null, e[l].matches), n[b]) {
            for (r = ++l; i > r; r++) {
              if (o.relative[e[r].type]) break;
            }return wt(l > 1 && bt(f), l > 1 && yt(e.slice(0, l - 1).concat({ value: " " === e[l - 2].type ? "*" : "" })).replace(z, "$1"), n, r > l && Tt(e.slice(l, r)), i > r && Tt(e = e.slice(r)), i > r && yt(e));
          }f.push(n);
        }
      }return bt(f);
    }function Ct(e, t) {
      var n = 0,
          r = t.length > 0,
          a = e.length > 0,
          s = function s(_s, l, c, p, d) {
        var h,
            g,
            m,
            y = [],
            v = 0,
            b = "0",
            x = _s && [],
            w = null != d,
            C = u,
            N = _s || a && o.find.TAG("*", d && l.parentNode || l),
            k = T += null == C ? 1 : Math.random() || .1;for (w && (u = l !== f && l, i = n); null != (h = N[b]); b++) {
          if (a && h) {
            g = 0;while (m = e[g++]) {
              if (m(h, l, c)) {
                p.push(h);break;
              }
            }w && (T = k, i = ++n);
          }r && ((h = !m && h) && v--, _s && x.push(h));
        }if (v += b, r && b !== v) {
          g = 0;while (m = t[g++]) {
            m(x, y, l, c);
          }if (_s) {
            if (v > 0) while (b--) {
              x[b] || y[b] || (y[b] = q.call(p));
            }y = xt(y);
          }M.apply(p, y), w && !_s && y.length > 0 && v + t.length > 1 && at.uniqueSort(p);
        }return w && (T = k, u = C), x;
      };return r ? lt(s) : s;
    }l = at.compile = function (e, t) {
      var n,
          r = [],
          i = [],
          o = E[e + " "];if (!o) {
        t || (t = mt(e)), n = t.length;while (n--) {
          o = Tt(t[n]), o[b] ? r.push(o) : i.push(o);
        }o = E(e, Ct(i, r));
      }return o;
    };function Nt(e, t, n) {
      var r = 0,
          i = t.length;for (; i > r; r++) {
        at(e, t[r], n);
      }return n;
    }function kt(e, t, n, i) {
      var a,
          s,
          u,
          c,
          p,
          f = mt(e);if (!i && 1 === f.length) {
        if (s = f[0] = f[0].slice(0), s.length > 2 && "ID" === (u = s[0]).type && r.getById && 9 === t.nodeType && h && o.relative[s[1].type]) {
          if (t = (o.find.ID(u.matches[0].replace(rt, it), t) || [])[0], !t) return n;e = e.slice(s.shift().value.length);
        }a = Q.needsContext.test(e) ? 0 : s.length;while (a--) {
          if (u = s[a], o.relative[c = u.type]) break;if ((p = o.find[c]) && (i = p(u.matches[0].replace(rt, it), V.test(s[0].type) && t.parentNode || t))) {
            if (s.splice(a, 1), e = i.length && yt(s), !e) return M.apply(n, i), n;break;
          }
        }
      }return l(e, f)(i, t, !h, n, V.test(e)), n;
    }r.sortStable = b.split("").sort(A).join("") === b, r.detectDuplicates = S, p(), r.sortDetached = ut(function (e) {
      return 1 & e.compareDocumentPosition(f.createElement("div"));
    }), ut(function (e) {
      return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
    }) || ct("type|href|height|width", function (e, n, r) {
      return r ? t : e.getAttribute(n, "type" === n.toLowerCase() ? 1 : 2);
    }), r.attributes && ut(function (e) {
      return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
    }) || ct("value", function (e, n, r) {
      return r || "input" !== e.nodeName.toLowerCase() ? t : e.defaultValue;
    }), ut(function (e) {
      return null == e.getAttribute("disabled");
    }) || ct(B, function (e, n, r) {
      var i;return r ? t : (i = e.getAttributeNode(n)) && i.specified ? i.value : e[n] === !0 ? n.toLowerCase() : null;
    }), x.find = at, x.expr = at.selectors, x.expr[":"] = x.expr.pseudos, x.unique = at.uniqueSort, x.text = at.getText, x.isXMLDoc = at.isXML, x.contains = at.contains;
  }(e);var O = {};function F(e) {
    var t = O[e] = {};return x.each(e.match(T) || [], function (e, n) {
      t[n] = !0;
    }), t;
  }x.Callbacks = function (e) {
    e = "string" == typeof e ? O[e] || F(e) : x.extend({}, e);var n,
        r,
        i,
        o,
        a,
        s,
        l = [],
        u = !e.once && [],
        c = function c(t) {
      for (r = e.memory && t, i = !0, a = s || 0, s = 0, o = l.length, n = !0; l && o > a; a++) {
        if (l[a].apply(t[0], t[1]) === !1 && e.stopOnFalse) {
          r = !1;break;
        }
      }n = !1, l && (u ? u.length && c(u.shift()) : r ? l = [] : p.disable());
    },
        p = { add: function add() {
        if (l) {
          var t = l.length;(function i(t) {
            x.each(t, function (t, n) {
              var r = x.type(n);"function" === r ? e.unique && p.has(n) || l.push(n) : n && n.length && "string" !== r && i(n);
            });
          })(arguments), n ? o = l.length : r && (s = t, c(r));
        }return this;
      }, remove: function remove() {
        return l && x.each(arguments, function (e, t) {
          var r;while ((r = x.inArray(t, l, r)) > -1) {
            l.splice(r, 1), n && (o >= r && o--, a >= r && a--);
          }
        }), this;
      }, has: function has(e) {
        return e ? x.inArray(e, l) > -1 : !(!l || !l.length);
      }, empty: function empty() {
        return l = [], o = 0, this;
      }, disable: function disable() {
        return l = u = r = t, this;
      }, disabled: function disabled() {
        return !l;
      }, lock: function lock() {
        return u = t, r || p.disable(), this;
      }, locked: function locked() {
        return !u;
      }, fireWith: function fireWith(e, t) {
        return !l || i && !u || (t = t || [], t = [e, t.slice ? t.slice() : t], n ? u.push(t) : c(t)), this;
      }, fire: function fire() {
        return p.fireWith(this, arguments), this;
      }, fired: function fired() {
        return !!i;
      } };return p;
  }, x.extend({ Deferred: function Deferred(e) {
      var t = [["resolve", "done", x.Callbacks("once memory"), "resolved"], ["reject", "fail", x.Callbacks("once memory"), "rejected"], ["notify", "progress", x.Callbacks("memory")]],
          n = "pending",
          r = { state: function state() {
          return n;
        }, always: function always() {
          return i.done(arguments).fail(arguments), this;
        }, then: function then() {
          var e = arguments;return x.Deferred(function (n) {
            x.each(t, function (t, o) {
              var a = o[0],
                  s = x.isFunction(e[t]) && e[t];i[o[1]](function () {
                var e = s && s.apply(this, arguments);e && x.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[a + "With"](this === r ? n.promise() : this, s ? [e] : arguments);
              });
            }), e = null;
          }).promise();
        }, promise: function promise(e) {
          return null != e ? x.extend(e, r) : r;
        } },
          i = {};return r.pipe = r.then, x.each(t, function (e, o) {
        var a = o[2],
            s = o[3];r[o[1]] = a.add, s && a.add(function () {
          n = s;
        }, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function () {
          return i[o[0] + "With"](this === i ? r : this, arguments), this;
        }, i[o[0] + "With"] = a.fireWith;
      }), r.promise(i), e && e.call(i, i), i;
    }, when: function when(e) {
      var t = 0,
          n = g.call(arguments),
          r = n.length,
          i = 1 !== r || e && x.isFunction(e.promise) ? r : 0,
          o = 1 === i ? e : x.Deferred(),
          a = function a(e, t, n) {
        return function (r) {
          t[e] = this, n[e] = arguments.length > 1 ? g.call(arguments) : r, n === s ? o.notifyWith(t, n) : --i || o.resolveWith(t, n);
        };
      },
          s,
          l,
          u;if (r > 1) for (s = Array(r), l = Array(r), u = Array(r); r > t; t++) {
        n[t] && x.isFunction(n[t].promise) ? n[t].promise().done(a(t, u, n)).fail(o.reject).progress(a(t, l, s)) : --i;
      }return i || o.resolveWith(u, n), o.promise();
    } }), x.support = function (t) {
    var n,
        r,
        o,
        s,
        l,
        u,
        c,
        p,
        f,
        d = a.createElement("div");if (d.setAttribute("className", "t"), d.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", n = d.getElementsByTagName("*") || [], r = d.getElementsByTagName("a")[0], !r || !r.style || !n.length) return t;s = a.createElement("select"), u = s.appendChild(a.createElement("option")), o = d.getElementsByTagName("input")[0], r.style.cssText = "top:1px;float:left;opacity:.5", t.getSetAttribute = "t" !== d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType, t.tbody = !d.getElementsByTagName("tbody").length, t.htmlSerialize = !!d.getElementsByTagName("link").length, t.style = /top/.test(r.getAttribute("style")), t.hrefNormalized = "/a" === r.getAttribute("href"), t.opacity = /^0.5/.test(r.style.opacity), t.cssFloat = !!r.style.cssFloat, t.checkOn = !!o.value, t.optSelected = u.selected, t.enctype = !!a.createElement("form").enctype, t.html5Clone = "<:nav></:nav>" !== a.createElement("nav").cloneNode(!0).outerHTML, t.inlineBlockNeedsLayout = !1, t.shrinkWrapBlocks = !1, t.pixelPosition = !1, t.deleteExpando = !0, t.noCloneEvent = !0, t.reliableMarginRight = !0, t.boxSizingReliable = !0, o.checked = !0, t.noCloneChecked = o.cloneNode(!0).checked, s.disabled = !0, t.optDisabled = !u.disabled;try {
      delete d.test;
    } catch (h) {
      t.deleteExpando = !1;
    }o = a.createElement("input"), o.setAttribute("value", ""), t.input = "" === o.getAttribute("value"), o.value = "t", o.setAttribute("type", "radio"), t.radioValue = "t" === o.value, o.setAttribute("checked", "t"), o.setAttribute("name", "t"), l = a.createDocumentFragment(), l.appendChild(o), t.appendChecked = o.checked, t.checkClone = l.cloneNode(!0).cloneNode(!0).lastChild.checked, d.attachEvent && (d.attachEvent("onclick", function () {
      t.noCloneEvent = !1;
    }), d.cloneNode(!0).click());for (f in { submit: !0, change: !0, focusin: !0 }) {
      d.setAttribute(c = "on" + f, "t"), t[f + "Bubbles"] = c in e || d.attributes[c].expando === !1;
    }d.style.backgroundClip = "content-box", d.cloneNode(!0).style.backgroundClip = "", t.clearCloneStyle = "content-box" === d.style.backgroundClip;for (f in x(t)) {
      break;
    }return t.ownLast = "0" !== f, x(function () {
      var n,
          r,
          o,
          s = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
          l = a.getElementsByTagName("body")[0];l && (n = a.createElement("div"), n.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", l.appendChild(n).appendChild(d), d.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", o = d.getElementsByTagName("td"), o[0].style.cssText = "padding:0;margin:0;border:0;display:none", p = 0 === o[0].offsetHeight, o[0].style.display = "", o[1].style.display = "none", t.reliableHiddenOffsets = p && 0 === o[0].offsetHeight, d.innerHTML = "", d.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;", x.swap(l, null != l.style.zoom ? { zoom: 1 } : {}, function () {
        t.boxSizing = 4 === d.offsetWidth;
      }), e.getComputedStyle && (t.pixelPosition = "1%" !== (e.getComputedStyle(d, null) || {}).top, t.boxSizingReliable = "4px" === (e.getComputedStyle(d, null) || { width: "4px" }).width, r = d.appendChild(a.createElement("div")), r.style.cssText = d.style.cssText = s, r.style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight = !parseFloat((e.getComputedStyle(r, null) || {}).marginRight)), _typeof(d.style.zoom) !== i && (d.innerHTML = "", d.style.cssText = s + "width:1px;padding:1px;display:inline;zoom:1", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display = "block", d.innerHTML = "<div></div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3 !== d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild(n), n = d = o = r = null);
    }), n = s = l = u = r = o = null, t;
  }({});var B = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
      P = /([A-Z])/g;function R(e, n, r, i) {
    if (x.acceptData(e)) {
      var o,
          a,
          s = x.expando,
          l = e.nodeType,
          u = l ? x.cache : e,
          c = l ? e[s] : e[s] && s;if (c && u[c] && (i || u[c].data) || r !== t || "string" != typeof n) return c || (c = l ? e[s] = p.pop() || x.guid++ : s), u[c] || (u[c] = l ? {} : { toJSON: x.noop }), ("object" == (typeof n === "undefined" ? "undefined" : _typeof(n)) || "function" == typeof n) && (i ? u[c] = x.extend(u[c], n) : u[c].data = x.extend(u[c].data, n)), a = u[c], i || (a.data || (a.data = {}), a = a.data), r !== t && (a[x.camelCase(n)] = r), "string" == typeof n ? (o = a[n], null == o && (o = a[x.camelCase(n)])) : o = a, o;
    }
  }function W(e, t, n) {
    if (x.acceptData(e)) {
      var r,
          i,
          o = e.nodeType,
          a = o ? x.cache : e,
          s = o ? e[x.expando] : x.expando;if (a[s]) {
        if (t && (r = n ? a[s] : a[s].data)) {
          x.isArray(t) ? t = t.concat(x.map(t, x.camelCase)) : t in r ? t = [t] : (t = x.camelCase(t), t = t in r ? [t] : t.split(" ")), i = t.length;while (i--) {
            delete r[t[i]];
          }if (n ? !I(r) : !x.isEmptyObject(r)) return;
        }(n || (delete a[s].data, I(a[s]))) && (o ? x.cleanData([e], !0) : x.support.deleteExpando || a != a.window ? delete a[s] : a[s] = null);
      }
    }
  }x.extend({ cache: {}, noData: { applet: !0, embed: !0, object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" }, hasData: function hasData(e) {
      return e = e.nodeType ? x.cache[e[x.expando]] : e[x.expando], !!e && !I(e);
    }, data: function data(e, t, n) {
      return R(e, t, n);
    }, removeData: function removeData(e, t) {
      return W(e, t);
    }, _data: function _data(e, t, n) {
      return R(e, t, n, !0);
    }, _removeData: function _removeData(e, t) {
      return W(e, t, !0);
    }, acceptData: function acceptData(e) {
      if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType) return !1;var t = e.nodeName && x.noData[e.nodeName.toLowerCase()];return !t || t !== !0 && e.getAttribute("classid") === t;
    } }), x.fn.extend({ data: function data(e, n) {
      var r,
          i,
          o = null,
          a = 0,
          s = this[0];if (e === t) {
        if (this.length && (o = x.data(s), 1 === s.nodeType && !x._data(s, "parsedAttrs"))) {
          for (r = s.attributes; r.length > a; a++) {
            i = r[a].name, 0 === i.indexOf("data-") && (i = x.camelCase(i.slice(5)), $(s, i, o[i]));
          }x._data(s, "parsedAttrs", !0);
        }return o;
      }return "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) ? this.each(function () {
        x.data(this, e);
      }) : arguments.length > 1 ? this.each(function () {
        x.data(this, e, n);
      }) : s ? $(s, e, x.data(s, e)) : null;
    }, removeData: function removeData(e) {
      return this.each(function () {
        x.removeData(this, e);
      });
    } });function $(e, n, r) {
    if (r === t && 1 === e.nodeType) {
      var i = "data-" + n.replace(P, "-$1").toLowerCase();if (r = e.getAttribute(i), "string" == typeof r) {
        try {
          r = "true" === r ? !0 : "false" === r ? !1 : "null" === r ? null : +r + "" === r ? +r : B.test(r) ? x.parseJSON(r) : r;
        } catch (o) {}x.data(e, n, r);
      } else r = t;
    }return r;
  }function I(e) {
    var t;for (t in e) {
      if (("data" !== t || !x.isEmptyObject(e[t])) && "toJSON" !== t) return !1;
    }return !0;
  }x.extend({ queue: function queue(e, n, r) {
      var i;return e ? (n = (n || "fx") + "queue", i = x._data(e, n), r && (!i || x.isArray(r) ? i = x._data(e, n, x.makeArray(r)) : i.push(r)), i || []) : t;
    }, dequeue: function dequeue(e, t) {
      t = t || "fx";var n = x.queue(e, t),
          r = n.length,
          i = n.shift(),
          o = x._queueHooks(e, t),
          a = function a() {
        x.dequeue(e, t);
      };"inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire();
    }, _queueHooks: function _queueHooks(e, t) {
      var n = t + "queueHooks";return x._data(e, n) || x._data(e, n, { empty: x.Callbacks("once memory").add(function () {
          x._removeData(e, t + "queue"), x._removeData(e, n);
        }) });
    } }), x.fn.extend({ queue: function queue(e, n) {
      var r = 2;return "string" != typeof e && (n = e, e = "fx", r--), r > arguments.length ? x.queue(this[0], e) : n === t ? this : this.each(function () {
        var t = x.queue(this, e, n);x._queueHooks(this, e), "fx" === e && "inprogress" !== t[0] && x.dequeue(this, e);
      });
    }, dequeue: function dequeue(e) {
      return this.each(function () {
        x.dequeue(this, e);
      });
    }, delay: function delay(e, t) {
      return e = x.fx ? x.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function (t, n) {
        var r = setTimeout(t, e);n.stop = function () {
          clearTimeout(r);
        };
      });
    }, clearQueue: function clearQueue(e) {
      return this.queue(e || "fx", []);
    }, promise: function promise(e, n) {
      var r,
          i = 1,
          o = x.Deferred(),
          a = this,
          s = this.length,
          l = function l() {
        --i || o.resolveWith(a, [a]);
      };"string" != typeof e && (n = e, e = t), e = e || "fx";while (s--) {
        r = x._data(a[s], e + "queueHooks"), r && r.empty && (i++, r.empty.add(l));
      }return l(), o.promise(n);
    } });var z,
      X,
      U = /[\t\r\n\f]/g,
      V = /\r/g,
      Y = /^(?:input|select|textarea|button|object)$/i,
      J = /^(?:a|area)$/i,
      G = /^(?:checked|selected)$/i,
      Q = x.support.getSetAttribute,
      K = x.support.input;x.fn.extend({ attr: function attr(e, t) {
      return x.access(this, x.attr, e, t, arguments.length > 1);
    }, removeAttr: function removeAttr(e) {
      return this.each(function () {
        x.removeAttr(this, e);
      });
    }, prop: function prop(e, t) {
      return x.access(this, x.prop, e, t, arguments.length > 1);
    }, removeProp: function removeProp(e) {
      return e = x.propFix[e] || e, this.each(function () {
        try {
          this[e] = t, delete this[e];
        } catch (n) {}
      });
    }, addClass: function addClass(e) {
      var t,
          n,
          r,
          i,
          o,
          a = 0,
          s = this.length,
          l = "string" == typeof e && e;if (x.isFunction(e)) return this.each(function (t) {
        x(this).addClass(e.call(this, t, this.className));
      });if (l) for (t = (e || "").match(T) || []; s > a; a++) {
        if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : " ")) {
          o = 0;while (i = t[o++]) {
            0 > r.indexOf(" " + i + " ") && (r += i + " ");
          }n.className = x.trim(r);
        }
      }return this;
    }, removeClass: function removeClass(e) {
      var t,
          n,
          r,
          i,
          o,
          a = 0,
          s = this.length,
          l = 0 === arguments.length || "string" == typeof e && e;if (x.isFunction(e)) return this.each(function (t) {
        x(this).removeClass(e.call(this, t, this.className));
      });if (l) for (t = (e || "").match(T) || []; s > a; a++) {
        if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : "")) {
          o = 0;while (i = t[o++]) {
            while (r.indexOf(" " + i + " ") >= 0) {
              r = r.replace(" " + i + " ", " ");
            }
          }n.className = e ? x.trim(r) : "";
        }
      }return this;
    }, toggleClass: function toggleClass(e, t) {
      var n = typeof e === "undefined" ? "undefined" : _typeof(e);return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : x.isFunction(e) ? this.each(function (n) {
        x(this).toggleClass(e.call(this, n, this.className, t), t);
      }) : this.each(function () {
        if ("string" === n) {
          var t,
              r = 0,
              o = x(this),
              a = e.match(T) || [];while (t = a[r++]) {
            o.hasClass(t) ? o.removeClass(t) : o.addClass(t);
          }
        } else (n === i || "boolean" === n) && (this.className && x._data(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : x._data(this, "__className__") || "");
      });
    }, hasClass: function hasClass(e) {
      var t = " " + e + " ",
          n = 0,
          r = this.length;for (; r > n; n++) {
        if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(U, " ").indexOf(t) >= 0) return !0;
      }return !1;
    }, val: function val(e) {
      var n,
          r,
          i,
          o = this[0];{
        if (arguments.length) return i = x.isFunction(e), this.each(function (n) {
          var o;1 === this.nodeType && (o = i ? e.call(this, n, x(this).val()) : e, null == o ? o = "" : "number" == typeof o ? o += "" : x.isArray(o) && (o = x.map(o, function (e) {
            return null == e ? "" : e + "";
          })), r = x.valHooks[this.type] || x.valHooks[this.nodeName.toLowerCase()], r && "set" in r && r.set(this, o, "value") !== t || (this.value = o));
        });if (o) return r = x.valHooks[o.type] || x.valHooks[o.nodeName.toLowerCase()], r && "get" in r && (n = r.get(o, "value")) !== t ? n : (n = o.value, "string" == typeof n ? n.replace(V, "") : null == n ? "" : n);
      }
    } }), x.extend({ valHooks: { option: { get: function get(e) {
          var t = x.find.attr(e, "value");return null != t ? t : e.text;
        } }, select: { get: function get(e) {
          var t,
              n,
              r = e.options,
              i = e.selectedIndex,
              o = "select-one" === e.type || 0 > i,
              a = o ? null : [],
              s = o ? i + 1 : r.length,
              l = 0 > i ? s : o ? i : 0;for (; s > l; l++) {
            if (n = r[l], !(!n.selected && l !== i || (x.support.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && x.nodeName(n.parentNode, "optgroup"))) {
              if (t = x(n).val(), o) return t;a.push(t);
            }
          }return a;
        }, set: function set(e, t) {
          var n,
              r,
              i = e.options,
              o = x.makeArray(t),
              a = i.length;while (a--) {
            r = i[a], (r.selected = x.inArray(x(r).val(), o) >= 0) && (n = !0);
          }return n || (e.selectedIndex = -1), o;
        } } }, attr: function attr(e, n, r) {
      var o,
          a,
          s = e.nodeType;if (e && 3 !== s && 8 !== s && 2 !== s) return _typeof(e.getAttribute) === i ? x.prop(e, n, r) : (1 === s && x.isXMLDoc(e) || (n = n.toLowerCase(), o = x.attrHooks[n] || (x.expr.match.bool.test(n) ? X : z)), r === t ? o && "get" in o && null !== (a = o.get(e, n)) ? a : (a = x.find.attr(e, n), null == a ? t : a) : null !== r ? o && "set" in o && (a = o.set(e, r, n)) !== t ? a : (e.setAttribute(n, r + ""), r) : (x.removeAttr(e, n), t));
    }, removeAttr: function removeAttr(e, t) {
      var n,
          r,
          i = 0,
          o = t && t.match(T);if (o && 1 === e.nodeType) while (n = o[i++]) {
        r = x.propFix[n] || n, x.expr.match.bool.test(n) ? K && Q || !G.test(n) ? e[r] = !1 : e[x.camelCase("default-" + n)] = e[r] = !1 : x.attr(e, n, ""), e.removeAttribute(Q ? n : r);
      }
    }, attrHooks: { type: { set: function set(e, t) {
          if (!x.support.radioValue && "radio" === t && x.nodeName(e, "input")) {
            var n = e.value;return e.setAttribute("type", t), n && (e.value = n), t;
          }
        } } }, propFix: { "for": "htmlFor", "class": "className" }, prop: function prop(e, n, r) {
      var i,
          o,
          a,
          s = e.nodeType;if (e && 3 !== s && 8 !== s && 2 !== s) return a = 1 !== s || !x.isXMLDoc(e), a && (n = x.propFix[n] || n, o = x.propHooks[n]), r !== t ? o && "set" in o && (i = o.set(e, r, n)) !== t ? i : e[n] = r : o && "get" in o && null !== (i = o.get(e, n)) ? i : e[n];
    }, propHooks: { tabIndex: { get: function get(e) {
          var t = x.find.attr(e, "tabindex");return t ? parseInt(t, 10) : Y.test(e.nodeName) || J.test(e.nodeName) && e.href ? 0 : -1;
        } } } }), X = { set: function set(e, t, n) {
      return t === !1 ? x.removeAttr(e, n) : K && Q || !G.test(n) ? e.setAttribute(!Q && x.propFix[n] || n, n) : e[x.camelCase("default-" + n)] = e[n] = !0, n;
    } }, x.each(x.expr.match.bool.source.match(/\w+/g), function (e, n) {
    var r = x.expr.attrHandle[n] || x.find.attr;x.expr.attrHandle[n] = K && Q || !G.test(n) ? function (e, n, i) {
      var o = x.expr.attrHandle[n],
          a = i ? t : (x.expr.attrHandle[n] = t) != r(e, n, i) ? n.toLowerCase() : null;return x.expr.attrHandle[n] = o, a;
    } : function (e, n, r) {
      return r ? t : e[x.camelCase("default-" + n)] ? n.toLowerCase() : null;
    };
  }), K && Q || (x.attrHooks.value = { set: function set(e, n, r) {
      return x.nodeName(e, "input") ? (e.defaultValue = n, t) : z && z.set(e, n, r);
    } }), Q || (z = { set: function set(e, n, r) {
      var i = e.getAttributeNode(r);return i || e.setAttributeNode(i = e.ownerDocument.createAttribute(r)), i.value = n += "", "value" === r || n === e.getAttribute(r) ? n : t;
    } }, x.expr.attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = function (e, n, r) {
    var i;return r ? t : (i = e.getAttributeNode(n)) && "" !== i.value ? i.value : null;
  }, x.valHooks.button = { get: function get(e, n) {
      var r = e.getAttributeNode(n);return r && r.specified ? r.value : t;
    }, set: z.set }, x.attrHooks.contenteditable = { set: function set(e, t, n) {
      z.set(e, "" === t ? !1 : t, n);
    } }, x.each(["width", "height"], function (e, n) {
    x.attrHooks[n] = { set: function set(e, r) {
        return "" === r ? (e.setAttribute(n, "auto"), r) : t;
      } };
  })), x.support.hrefNormalized || x.each(["href", "src"], function (e, t) {
    x.propHooks[t] = { get: function get(e) {
        return e.getAttribute(t, 4);
      } };
  }), x.support.style || (x.attrHooks.style = { get: function get(e) {
      return e.style.cssText || t;
    }, set: function set(e, t) {
      return e.style.cssText = t + "";
    } }), x.support.optSelected || (x.propHooks.selected = { get: function get(e) {
      var t = e.parentNode;return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null;
    } }), x.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    x.propFix[this.toLowerCase()] = this;
  }), x.support.enctype || (x.propFix.enctype = "encoding"), x.each(["radio", "checkbox"], function () {
    x.valHooks[this] = { set: function set(e, n) {
        return x.isArray(n) ? e.checked = x.inArray(x(e).val(), n) >= 0 : t;
      } }, x.support.checkOn || (x.valHooks[this].get = function (e) {
      return null === e.getAttribute("value") ? "on" : e.value;
    });
  });var Z = /^(?:input|select|textarea)$/i,
      et = /^key/,
      tt = /^(?:mouse|contextmenu)|click/,
      nt = /^(?:focusinfocus|focusoutblur)$/,
      rt = /^([^.]*)(?:\.(.+)|)$/;function it() {
    return !0;
  }function ot() {
    return !1;
  }function at() {
    try {
      return a.activeElement;
    } catch (e) {}
  }x.event = { global: {}, add: function add(e, n, r, o, a) {
      var s,
          l,
          u,
          c,
          p,
          f,
          d,
          h,
          g,
          m,
          y,
          v = x._data(e);if (v) {
        r.handler && (c = r, r = c.handler, a = c.selector), r.guid || (r.guid = x.guid++), (l = v.events) || (l = v.events = {}), (f = v.handle) || (f = v.handle = function (e) {
          return (typeof x === "undefined" ? "undefined" : _typeof(x)) === i || e && x.event.triggered === e.type ? t : x.event.dispatch.apply(f.elem, arguments);
        }, f.elem = e), n = (n || "").match(T) || [""], u = n.length;while (u--) {
          s = rt.exec(n[u]) || [], g = y = s[1], m = (s[2] || "").split(".").sort(), g && (p = x.event.special[g] || {}, g = (a ? p.delegateType : p.bindType) || g, p = x.event.special[g] || {}, d = x.extend({ type: g, origType: y, data: o, handler: r, guid: r.guid, selector: a, needsContext: a && x.expr.match.needsContext.test(a), namespace: m.join(".") }, c), (h = l[g]) || (h = l[g] = [], h.delegateCount = 0, p.setup && p.setup.call(e, o, m, f) !== !1 || (e.addEventListener ? e.addEventListener(g, f, !1) : e.attachEvent && e.attachEvent("on" + g, f))), p.add && (p.add.call(e, d), d.handler.guid || (d.handler.guid = r.guid)), a ? h.splice(h.delegateCount++, 0, d) : h.push(d), x.event.global[g] = !0);
        }e = null;
      }
    }, remove: function remove(e, t, n, r, i) {
      var o,
          a,
          s,
          l,
          u,
          c,
          p,
          f,
          d,
          h,
          g,
          m = x.hasData(e) && x._data(e);if (m && (c = m.events)) {
        t = (t || "").match(T) || [""], u = t.length;while (u--) {
          if (s = rt.exec(t[u]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) {
            p = x.event.special[d] || {}, d = (r ? p.delegateType : p.bindType) || d, f = c[d] || [], s = s[2] && RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), l = o = f.length;while (o--) {
              a = f[o], !i && g !== a.origType || n && n.guid !== a.guid || s && !s.test(a.namespace) || r && r !== a.selector && ("**" !== r || !a.selector) || (f.splice(o, 1), a.selector && f.delegateCount--, p.remove && p.remove.call(e, a));
            }l && !f.length && (p.teardown && p.teardown.call(e, h, m.handle) !== !1 || x.removeEvent(e, d, m.handle), delete c[d]);
          } else for (d in c) {
            x.event.remove(e, d + t[u], n, r, !0);
          }
        }x.isEmptyObject(c) && (delete m.handle, x._removeData(e, "events"));
      }
    }, trigger: function trigger(n, r, i, o) {
      var s,
          l,
          u,
          c,
          p,
          f,
          d,
          h = [i || a],
          g = v.call(n, "type") ? n.type : n,
          m = v.call(n, "namespace") ? n.namespace.split(".") : [];if (u = f = i = i || a, 3 !== i.nodeType && 8 !== i.nodeType && !nt.test(g + x.event.triggered) && (g.indexOf(".") >= 0 && (m = g.split("."), g = m.shift(), m.sort()), l = 0 > g.indexOf(":") && "on" + g, n = n[x.expando] ? n : new x.Event(g, "object" == (typeof n === "undefined" ? "undefined" : _typeof(n)) && n), n.isTrigger = o ? 2 : 3, n.namespace = m.join("."), n.namespace_re = n.namespace ? RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, n.result = t, n.target || (n.target = i), r = null == r ? [n] : x.makeArray(r, [n]), p = x.event.special[g] || {}, o || !p.trigger || p.trigger.apply(i, r) !== !1)) {
        if (!o && !p.noBubble && !x.isWindow(i)) {
          for (c = p.delegateType || g, nt.test(c + g) || (u = u.parentNode); u; u = u.parentNode) {
            h.push(u), f = u;
          }f === (i.ownerDocument || a) && h.push(f.defaultView || f.parentWindow || e);
        }d = 0;while ((u = h[d++]) && !n.isPropagationStopped()) {
          n.type = d > 1 ? c : p.bindType || g, s = (x._data(u, "events") || {})[n.type] && x._data(u, "handle"), s && s.apply(u, r), s = l && u[l], s && x.acceptData(u) && s.apply && s.apply(u, r) === !1 && n.preventDefault();
        }if (n.type = g, !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(h.pop(), r) === !1) && x.acceptData(i) && l && i[g] && !x.isWindow(i)) {
          f = i[l], f && (i[l] = null), x.event.triggered = g;try {
            i[g]();
          } catch (y) {}x.event.triggered = t, f && (i[l] = f);
        }return n.result;
      }
    }, dispatch: function dispatch(e) {
      e = x.event.fix(e);var n,
          r,
          i,
          o,
          a,
          s = [],
          l = g.call(arguments),
          u = (x._data(this, "events") || {})[e.type] || [],
          c = x.event.special[e.type] || {};if (l[0] = e, e.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, e) !== !1) {
        s = x.event.handlers.call(this, e, u), n = 0;while ((o = s[n++]) && !e.isPropagationStopped()) {
          e.currentTarget = o.elem, a = 0;while ((i = o.handlers[a++]) && !e.isImmediatePropagationStopped()) {
            (!e.namespace_re || e.namespace_re.test(i.namespace)) && (e.handleObj = i, e.data = i.data, r = ((x.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, l), r !== t && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()));
          }
        }return c.postDispatch && c.postDispatch.call(this, e), e.result;
      }
    }, handlers: function handlers(e, n) {
      var r,
          i,
          o,
          a,
          s = [],
          l = n.delegateCount,
          u = e.target;if (l && u.nodeType && (!e.button || "click" !== e.type)) for (; u != this; u = u.parentNode || this) {
        if (1 === u.nodeType && (u.disabled !== !0 || "click" !== e.type)) {
          for (o = [], a = 0; l > a; a++) {
            i = n[a], r = i.selector + " ", o[r] === t && (o[r] = i.needsContext ? x(r, this).index(u) >= 0 : x.find(r, this, null, [u]).length), o[r] && o.push(i);
          }o.length && s.push({ elem: u, handlers: o });
        }
      }return n.length > l && s.push({ elem: this, handlers: n.slice(l) }), s;
    }, fix: function fix(e) {
      if (e[x.expando]) return e;var t,
          n,
          r,
          i = e.type,
          o = e,
          s = this.fixHooks[i];s || (this.fixHooks[i] = s = tt.test(i) ? this.mouseHooks : et.test(i) ? this.keyHooks : {}), r = s.props ? this.props.concat(s.props) : this.props, e = new x.Event(o), t = r.length;while (t--) {
        n = r[t], e[n] = o[n];
      }return e.target || (e.target = o.srcElement || a), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, s.filter ? s.filter(e, o) : e;
    }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function filter(e, t) {
        return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e;
      } }, mouseHooks: { props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function filter(e, n) {
        var r,
            i,
            o,
            s = n.button,
            l = n.fromElement;return null == e.pageX && null != n.clientX && (i = e.target.ownerDocument || a, o = i.documentElement, r = i.body, e.pageX = n.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)), !e.relatedTarget && l && (e.relatedTarget = l === e.target ? n.toElement : l), e.which || s === t || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e;
      } }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {
          if (this !== at() && this.focus) try {
            return this.focus(), !1;
          } catch (e) {}
        }, delegateType: "focusin" }, blur: { trigger: function trigger() {
          return this === at() && this.blur ? (this.blur(), !1) : t;
        }, delegateType: "focusout" }, click: { trigger: function trigger() {
          return x.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : t;
        }, _default: function _default(e) {
          return x.nodeName(e.target, "a");
        } }, beforeunload: { postDispatch: function postDispatch(e) {
          e.result !== t && (e.originalEvent.returnValue = e.result);
        } } }, simulate: function simulate(e, t, n, r) {
      var i = x.extend(new x.Event(), n, { type: e, isSimulated: !0, originalEvent: {} });r ? x.event.trigger(i, null, t) : x.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault();
    } }, x.removeEvent = a.removeEventListener ? function (e, t, n) {
    e.removeEventListener && e.removeEventListener(t, n, !1);
  } : function (e, t, n) {
    var r = "on" + t;e.detachEvent && (_typeof(e[r]) === i && (e[r] = null), e.detachEvent(r, n));
  }, x.Event = function (e, n) {
    return this instanceof x.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? it : ot) : this.type = e, n && x.extend(this, n), this.timeStamp = e && e.timeStamp || x.now(), this[x.expando] = !0, t) : new x.Event(e, n);
  }, x.Event.prototype = { isDefaultPrevented: ot, isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault: function preventDefault() {
      var e = this.originalEvent;this.isDefaultPrevented = it, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);
    }, stopPropagation: function stopPropagation() {
      var e = this.originalEvent;this.isPropagationStopped = it, e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0);
    }, stopImmediatePropagation: function stopImmediatePropagation() {
      this.isImmediatePropagationStopped = it, this.stopPropagation();
    } }, x.each({ mouseenter: "mouseover", mouseleave: "mouseout" }, function (e, t) {
    x.event.special[e] = { delegateType: t, bindType: t, handle: function handle(e) {
        var n,
            r = this,
            i = e.relatedTarget,
            o = e.handleObj;return (!i || i !== r && !x.contains(r, i)) && (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n;
      } };
  }), x.support.submitBubbles || (x.event.special.submit = { setup: function setup() {
      return x.nodeName(this, "form") ? !1 : (x.event.add(this, "click._submit keypress._submit", function (e) {
        var n = e.target,
            r = x.nodeName(n, "input") || x.nodeName(n, "button") ? n.form : t;r && !x._data(r, "submitBubbles") && (x.event.add(r, "submit._submit", function (e) {
          e._submit_bubble = !0;
        }), x._data(r, "submitBubbles", !0));
      }), t);
    }, postDispatch: function postDispatch(e) {
      e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && x.event.simulate("submit", this.parentNode, e, !0));
    }, teardown: function teardown() {
      return x.nodeName(this, "form") ? !1 : (x.event.remove(this, "._submit"), t);
    } }), x.support.changeBubbles || (x.event.special.change = { setup: function setup() {
      return Z.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (x.event.add(this, "propertychange._change", function (e) {
        "checked" === e.originalEvent.propertyName && (this._just_changed = !0);
      }), x.event.add(this, "click._change", function (e) {
        this._just_changed && !e.isTrigger && (this._just_changed = !1), x.event.simulate("change", this, e, !0);
      })), !1) : (x.event.add(this, "beforeactivate._change", function (e) {
        var t = e.target;Z.test(t.nodeName) && !x._data(t, "changeBubbles") && (x.event.add(t, "change._change", function (e) {
          !this.parentNode || e.isSimulated || e.isTrigger || x.event.simulate("change", this.parentNode, e, !0);
        }), x._data(t, "changeBubbles", !0));
      }), t);
    }, handle: function handle(e) {
      var n = e.target;return this !== n || e.isSimulated || e.isTrigger || "radio" !== n.type && "checkbox" !== n.type ? e.handleObj.handler.apply(this, arguments) : t;
    }, teardown: function teardown() {
      return x.event.remove(this, "._change"), !Z.test(this.nodeName);
    } }), x.support.focusinBubbles || x.each({ focus: "focusin", blur: "focusout" }, function (e, t) {
    var n = 0,
        r = function r(e) {
      x.event.simulate(t, e.target, x.event.fix(e), !0);
    };x.event.special[t] = { setup: function setup() {
        0 === n++ && a.addEventListener(e, r, !0);
      }, teardown: function teardown() {
        0 === --n && a.removeEventListener(e, r, !0);
      } };
  }), x.fn.extend({ on: function on(e, n, r, i, o) {
      var a, s;if ("object" == (typeof e === "undefined" ? "undefined" : _typeof(e))) {
        "string" != typeof n && (r = r || n, n = t);for (a in e) {
          this.on(a, n, r, e[a], o);
        }return this;
      }if (null == r && null == i ? (i = n, r = n = t) : null == i && ("string" == typeof n ? (i = r, r = t) : (i = r, r = n, n = t)), i === !1) i = ot;else if (!i) return this;return 1 === o && (s = i, i = function i(e) {
        return x().off(e), s.apply(this, arguments);
      }, i.guid = s.guid || (s.guid = x.guid++)), this.each(function () {
        x.event.add(this, e, i, r, n);
      });
    }, one: function one(e, t, n, r) {
      return this.on(e, t, n, r, 1);
    }, off: function off(e, n, r) {
      var i, o;if (e && e.preventDefault && e.handleObj) return i = e.handleObj, x(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;if ("object" == (typeof e === "undefined" ? "undefined" : _typeof(e))) {
        for (o in e) {
          this.off(o, n, e[o]);
        }return this;
      }return (n === !1 || "function" == typeof n) && (r = n, n = t), r === !1 && (r = ot), this.each(function () {
        x.event.remove(this, e, r, n);
      });
    }, trigger: function trigger(e, t) {
      return this.each(function () {
        x.event.trigger(e, t, this);
      });
    }, triggerHandler: function triggerHandler(e, n) {
      var r = this[0];return r ? x.event.trigger(e, n, r, !0) : t;
    } });var st = /^.[^:#\[\.,]*$/,
      lt = /^(?:parents|prev(?:Until|All))/,
      ut = x.expr.match.needsContext,
      ct = { children: !0, contents: !0, next: !0, prev: !0 };x.fn.extend({ find: function find(e) {
      var t,
          n = [],
          r = this,
          i = r.length;if ("string" != typeof e) return this.pushStack(x(e).filter(function () {
        for (t = 0; i > t; t++) {
          if (x.contains(r[t], this)) return !0;
        }
      }));for (t = 0; i > t; t++) {
        x.find(e, r[t], n);
      }return n = this.pushStack(i > 1 ? x.unique(n) : n), n.selector = this.selector ? this.selector + " " + e : e, n;
    }, has: function has(e) {
      var t,
          n = x(e, this),
          r = n.length;return this.filter(function () {
        for (t = 0; r > t; t++) {
          if (x.contains(this, n[t])) return !0;
        }
      });
    }, not: function not(e) {
      return this.pushStack(ft(this, e || [], !0));
    }, filter: function filter(e) {
      return this.pushStack(ft(this, e || [], !1));
    }, is: function is(e) {
      return !!ft(this, "string" == typeof e && ut.test(e) ? x(e) : e || [], !1).length;
    }, closest: function closest(e, t) {
      var n,
          r = 0,
          i = this.length,
          o = [],
          a = ut.test(e) || "string" != typeof e ? x(e, t || this.context) : 0;for (; i > r; r++) {
        for (n = this[r]; n && n !== t; n = n.parentNode) {
          if (11 > n.nodeType && (a ? a.index(n) > -1 : 1 === n.nodeType && x.find.matchesSelector(n, e))) {
            n = o.push(n);break;
          }
        }
      }return this.pushStack(o.length > 1 ? x.unique(o) : o);
    }, index: function index(e) {
      return e ? "string" == typeof e ? x.inArray(this[0], x(e)) : x.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    }, add: function add(e, t) {
      var n = "string" == typeof e ? x(e, t) : x.makeArray(e && e.nodeType ? [e] : e),
          r = x.merge(this.get(), n);return this.pushStack(x.unique(r));
    }, addBack: function addBack(e) {
      return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
    } });function pt(e, t) {
    do {
      e = e[t];
    } while (e && 1 !== e.nodeType);return e;
  }x.each({ parent: function parent(e) {
      var t = e.parentNode;return t && 11 !== t.nodeType ? t : null;
    }, parents: function parents(e) {
      return x.dir(e, "parentNode");
    }, parentsUntil: function parentsUntil(e, t, n) {
      return x.dir(e, "parentNode", n);
    }, next: function next(e) {
      return pt(e, "nextSibling");
    }, prev: function prev(e) {
      return pt(e, "previousSibling");
    }, nextAll: function nextAll(e) {
      return x.dir(e, "nextSibling");
    }, prevAll: function prevAll(e) {
      return x.dir(e, "previousSibling");
    }, nextUntil: function nextUntil(e, t, n) {
      return x.dir(e, "nextSibling", n);
    }, prevUntil: function prevUntil(e, t, n) {
      return x.dir(e, "previousSibling", n);
    }, siblings: function siblings(e) {
      return x.sibling((e.parentNode || {}).firstChild, e);
    }, children: function children(e) {
      return x.sibling(e.firstChild);
    }, contents: function contents(e) {
      return x.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : x.merge([], e.childNodes);
    } }, function (e, t) {
    x.fn[e] = function (n, r) {
      var i = x.map(this, t, n);return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = x.filter(r, i)), this.length > 1 && (ct[e] || (i = x.unique(i)), lt.test(e) && (i = i.reverse())), this.pushStack(i);
    };
  }), x.extend({ filter: function filter(e, t, n) {
      var r = t[0];return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? x.find.matchesSelector(r, e) ? [r] : [] : x.find.matches(e, x.grep(t, function (e) {
        return 1 === e.nodeType;
      }));
    }, dir: function dir(e, n, r) {
      var i = [],
          o = e[n];while (o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !x(o).is(r))) {
        1 === o.nodeType && i.push(o), o = o[n];
      }return i;
    }, sibling: function sibling(e, t) {
      var n = [];for (; e; e = e.nextSibling) {
        1 === e.nodeType && e !== t && n.push(e);
      }return n;
    } });function ft(e, t, n) {
    if (x.isFunction(t)) return x.grep(e, function (e, r) {
      return !!t.call(e, r, e) !== n;
    });if (t.nodeType) return x.grep(e, function (e) {
      return e === t !== n;
    });if ("string" == typeof t) {
      if (st.test(t)) return x.filter(t, e, n);t = x.filter(t, e);
    }return x.grep(e, function (e) {
      return x.inArray(e, t) >= 0 !== n;
    });
  }function dt(e) {
    var t = ht.split("|"),
        n = e.createDocumentFragment();if (n.createElement) while (t.length) {
      n.createElement(t.pop());
    }return n;
  }var ht = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
      gt = / jQuery\d+="(?:null|\d+)"/g,
      mt = RegExp("<(?:" + ht + ")[\\s/>]", "i"),
      yt = /^\s+/,
      vt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      bt = /<([\w:]+)/,
      xt = /<tbody/i,
      wt = /<|&#?\w+;/,
      Tt = /<(?:script|style|link)/i,
      Ct = /^(?:checkbox|radio)$/i,
      Nt = /checked\s*(?:[^=]|=\s*.checked.)/i,
      kt = /^$|\/(?:java|ecma)script/i,
      Et = /^true\/(.*)/,
      St = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      At = { option: [1, "<select multiple='multiple'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: x.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"] },
      jt = dt(a),
      Dt = jt.appendChild(a.createElement("div"));At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, x.fn.extend({ text: function text(e) {
      return x.access(this, function (e) {
        return e === t ? x.text(this) : this.empty().append((this[0] && this[0].ownerDocument || a).createTextNode(e));
      }, null, e, arguments.length);
    }, append: function append() {
      return this.domManip(arguments, function (e) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var t = Lt(this, e);t.appendChild(e);
        }
      });
    }, prepend: function prepend() {
      return this.domManip(arguments, function (e) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var t = Lt(this, e);t.insertBefore(e, t.firstChild);
        }
      });
    }, before: function before() {
      return this.domManip(arguments, function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this);
      });
    }, after: function after() {
      return this.domManip(arguments, function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
      });
    }, remove: function remove(e, t) {
      var n,
          r = e ? x.filter(e, this) : this,
          i = 0;for (; null != (n = r[i]); i++) {
        t || 1 !== n.nodeType || x.cleanData(Ft(n)), n.parentNode && (t && x.contains(n.ownerDocument, n) && _t(Ft(n, "script")), n.parentNode.removeChild(n));
      }return this;
    }, empty: function empty() {
      var e,
          t = 0;for (; null != (e = this[t]); t++) {
        1 === e.nodeType && x.cleanData(Ft(e, !1));while (e.firstChild) {
          e.removeChild(e.firstChild);
        }e.options && x.nodeName(e, "select") && (e.options.length = 0);
      }return this;
    }, clone: function clone(e, t) {
      return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function () {
        return x.clone(this, e, t);
      });
    }, html: function html(e) {
      return x.access(this, function (e) {
        var n = this[0] || {},
            r = 0,
            i = this.length;if (e === t) return 1 === n.nodeType ? n.innerHTML.replace(gt, "") : t;if (!("string" != typeof e || Tt.test(e) || !x.support.htmlSerialize && mt.test(e) || !x.support.leadingWhitespace && yt.test(e) || At[(bt.exec(e) || ["", ""])[1].toLowerCase()])) {
          e = e.replace(vt, "<$1></$2>");try {
            for (; i > r; r++) {
              n = this[r] || {}, 1 === n.nodeType && (x.cleanData(Ft(n, !1)), n.innerHTML = e);
            }n = 0;
          } catch (o) {}
        }n && this.empty().append(e);
      }, null, e, arguments.length);
    }, replaceWith: function replaceWith() {
      var e = x.map(this, function (e) {
        return [e.nextSibling, e.parentNode];
      }),
          t = 0;return this.domManip(arguments, function (n) {
        var r = e[t++],
            i = e[t++];i && (r && r.parentNode !== i && (r = this.nextSibling), x(this).remove(), i.insertBefore(n, r));
      }, !0), t ? this : this.remove();
    }, detach: function detach(e) {
      return this.remove(e, !0);
    }, domManip: function domManip(e, t, n) {
      e = d.apply([], e);var r,
          i,
          o,
          a,
          s,
          l,
          u = 0,
          c = this.length,
          p = this,
          f = c - 1,
          h = e[0],
          g = x.isFunction(h);if (g || !(1 >= c || "string" != typeof h || x.support.checkClone) && Nt.test(h)) return this.each(function (r) {
        var i = p.eq(r);g && (e[0] = h.call(this, r, i.html())), i.domManip(e, t, n);
      });if (c && (l = x.buildFragment(e, this[0].ownerDocument, !1, !n && this), r = l.firstChild, 1 === l.childNodes.length && (l = r), r)) {
        for (a = x.map(Ft(l, "script"), Ht), o = a.length; c > u; u++) {
          i = l, u !== f && (i = x.clone(i, !0, !0), o && x.merge(a, Ft(i, "script"))), t.call(this[u], i, u);
        }if (o) for (s = a[a.length - 1].ownerDocument, x.map(a, qt), u = 0; o > u; u++) {
          i = a[u], kt.test(i.type || "") && !x._data(i, "globalEval") && x.contains(s, i) && (i.src ? x._evalUrl(i.src) : x.globalEval((i.text || i.textContent || i.innerHTML || "").replace(St, "")));
        }l = r = null;
      }return this;
    } });function Lt(e, t) {
    return x.nodeName(e, "table") && x.nodeName(1 === t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e;
  }function Ht(e) {
    return e.type = (null !== x.find.attr(e, "type")) + "/" + e.type, e;
  }function qt(e) {
    var t = Et.exec(e.type);return t ? e.type = t[1] : e.removeAttribute("type"), e;
  }function _t(e, t) {
    var n,
        r = 0;for (; null != (n = e[r]); r++) {
      x._data(n, "globalEval", !t || x._data(t[r], "globalEval"));
    }
  }function Mt(e, t) {
    if (1 === t.nodeType && x.hasData(e)) {
      var n,
          r,
          i,
          o = x._data(e),
          a = x._data(t, o),
          s = o.events;if (s) {
        delete a.handle, a.events = {};for (n in s) {
          for (r = 0, i = s[n].length; i > r; r++) {
            x.event.add(t, n, s[n][r]);
          }
        }
      }a.data && (a.data = x.extend({}, a.data));
    }
  }function Ot(e, t) {
    var n, r, i;if (1 === t.nodeType) {
      if (n = t.nodeName.toLowerCase(), !x.support.noCloneEvent && t[x.expando]) {
        i = x._data(t);for (r in i.events) {
          x.removeEvent(t, r, i.handle);
        }t.removeAttribute(x.expando);
      }"script" === n && t.text !== e.text ? (Ht(t).text = e.text, qt(t)) : "object" === n ? (t.parentNode && (t.outerHTML = e.outerHTML), x.support.html5Clone && e.innerHTML && !x.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : "input" === n && Ct.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : "option" === n ? t.defaultSelected = t.selected = e.defaultSelected : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue);
    }
  }x.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, t) {
    x.fn[e] = function (e) {
      var n,
          r = 0,
          i = [],
          o = x(e),
          a = o.length - 1;for (; a >= r; r++) {
        n = r === a ? this : this.clone(!0), x(o[r])[t](n), h.apply(i, n.get());
      }return this.pushStack(i);
    };
  });function Ft(e, n) {
    var r,
        o,
        a = 0,
        s = _typeof(e.getElementsByTagName) !== i ? e.getElementsByTagName(n || "*") : _typeof(e.querySelectorAll) !== i ? e.querySelectorAll(n || "*") : t;if (!s) for (s = [], r = e.childNodes || e; null != (o = r[a]); a++) {
      !n || x.nodeName(o, n) ? s.push(o) : x.merge(s, Ft(o, n));
    }return n === t || n && x.nodeName(e, n) ? x.merge([e], s) : s;
  }function Bt(e) {
    Ct.test(e.type) && (e.defaultChecked = e.checked);
  }x.extend({ clone: function clone(e, t, n) {
      var r,
          i,
          o,
          a,
          s,
          l = x.contains(e.ownerDocument, e);if (x.support.html5Clone || x.isXMLDoc(e) || !mt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : (Dt.innerHTML = e.outerHTML, Dt.removeChild(o = Dt.firstChild)), !(x.support.noCloneEvent && x.support.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || x.isXMLDoc(e))) for (r = Ft(o), s = Ft(e), a = 0; null != (i = s[a]); ++a) {
        r[a] && Ot(i, r[a]);
      }if (t) if (n) for (s = s || Ft(e), r = r || Ft(o), a = 0; null != (i = s[a]); a++) {
        Mt(i, r[a]);
      } else Mt(e, o);return r = Ft(o, "script"), r.length > 0 && _t(r, !l && Ft(e, "script")), r = s = i = null, o;
    }, buildFragment: function buildFragment(e, t, n, r) {
      var i,
          o,
          a,
          s,
          l,
          u,
          c,
          p = e.length,
          f = dt(t),
          d = [],
          h = 0;for (; p > h; h++) {
        if (o = e[h], o || 0 === o) if ("object" === x.type(o)) x.merge(d, o.nodeType ? [o] : o);else if (wt.test(o)) {
          s = s || f.appendChild(t.createElement("div")), l = (bt.exec(o) || ["", ""])[1].toLowerCase(), c = At[l] || At._default, s.innerHTML = c[1] + o.replace(vt, "<$1></$2>") + c[2], i = c[0];while (i--) {
            s = s.lastChild;
          }if (!x.support.leadingWhitespace && yt.test(o) && d.push(t.createTextNode(yt.exec(o)[0])), !x.support.tbody) {
            o = "table" !== l || xt.test(o) ? "<table>" !== c[1] || xt.test(o) ? 0 : s : s.firstChild, i = o && o.childNodes.length;while (i--) {
              x.nodeName(u = o.childNodes[i], "tbody") && !u.childNodes.length && o.removeChild(u);
            }
          }x.merge(d, s.childNodes), s.textContent = "";while (s.firstChild) {
            s.removeChild(s.firstChild);
          }s = f.lastChild;
        } else d.push(t.createTextNode(o));
      }s && f.removeChild(s), x.support.appendChecked || x.grep(Ft(d, "input"), Bt), h = 0;while (o = d[h++]) {
        if ((!r || -1 === x.inArray(o, r)) && (a = x.contains(o.ownerDocument, o), s = Ft(f.appendChild(o), "script"), a && _t(s), n)) {
          i = 0;while (o = s[i++]) {
            kt.test(o.type || "") && n.push(o);
          }
        }
      }return s = null, f;
    }, cleanData: function cleanData(e, t) {
      var n,
          r,
          o,
          a,
          s = 0,
          l = x.expando,
          u = x.cache,
          c = x.support.deleteExpando,
          f = x.event.special;for (; null != (n = e[s]); s++) {
        if ((t || x.acceptData(n)) && (o = n[l], a = o && u[o])) {
          if (a.events) for (r in a.events) {
            f[r] ? x.event.remove(n, r) : x.removeEvent(n, r, a.handle);
          }u[o] && (delete u[o], c ? delete n[l] : _typeof(n.removeAttribute) !== i ? n.removeAttribute(l) : n[l] = null, p.push(o));
        }
      }
    }, _evalUrl: function _evalUrl(e) {
      return x.ajax({ url: e, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0 });
    } }), x.fn.extend({ wrapAll: function wrapAll(e) {
      if (x.isFunction(e)) return this.each(function (t) {
        x(this).wrapAll(e.call(this, t));
      });if (this[0]) {
        var t = x(e, this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
          var e = this;while (e.firstChild && 1 === e.firstChild.nodeType) {
            e = e.firstChild;
          }return e;
        }).append(this);
      }return this;
    }, wrapInner: function wrapInner(e) {
      return x.isFunction(e) ? this.each(function (t) {
        x(this).wrapInner(e.call(this, t));
      }) : this.each(function () {
        var t = x(this),
            n = t.contents();n.length ? n.wrapAll(e) : t.append(e);
      });
    }, wrap: function wrap(e) {
      var t = x.isFunction(e);return this.each(function (n) {
        x(this).wrapAll(t ? e.call(this, n) : e);
      });
    }, unwrap: function unwrap() {
      return this.parent().each(function () {
        x.nodeName(this, "body") || x(this).replaceWith(this.childNodes);
      }).end();
    } });var Pt,
      Rt,
      Wt,
      $t = /alpha\([^)]*\)/i,
      It = /opacity\s*=\s*([^)]*)/,
      zt = /^(top|right|bottom|left)$/,
      Xt = /^(none|table(?!-c[ea]).+)/,
      Ut = /^margin/,
      Vt = RegExp("^(" + w + ")(.*)$", "i"),
      Yt = RegExp("^(" + w + ")(?!px)[a-z%]+$", "i"),
      Jt = RegExp("^([+-])=(" + w + ")", "i"),
      Gt = { BODY: "block" },
      Qt = { position: "absolute", visibility: "hidden", display: "block" },
      Kt = { letterSpacing: 0, fontWeight: 400 },
      Zt = ["Top", "Right", "Bottom", "Left"],
      en = ["Webkit", "O", "Moz", "ms"];function tn(e, t) {
    if (t in e) return t;var n = t.charAt(0).toUpperCase() + t.slice(1),
        r = t,
        i = en.length;while (i--) {
      if (t = en[i] + n, t in e) return t;
    }return r;
  }function nn(e, t) {
    return e = t || e, "none" === x.css(e, "display") || !x.contains(e.ownerDocument, e);
  }function rn(e, t) {
    var n,
        r,
        i,
        o = [],
        a = 0,
        s = e.length;for (; s > a; a++) {
      r = e[a], r.style && (o[a] = x._data(r, "olddisplay"), n = r.style.display, t ? (o[a] || "none" !== n || (r.style.display = ""), "" === r.style.display && nn(r) && (o[a] = x._data(r, "olddisplay", ln(r.nodeName)))) : o[a] || (i = nn(r), (n && "none" !== n || !i) && x._data(r, "olddisplay", i ? n : x.css(r, "display"))));
    }for (a = 0; s > a; a++) {
      r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none"));
    }return e;
  }x.fn.extend({ css: function css(e, n) {
      return x.access(this, function (e, n, r) {
        var i,
            o,
            a = {},
            s = 0;if (x.isArray(n)) {
          for (o = Rt(e), i = n.length; i > s; s++) {
            a[n[s]] = x.css(e, n[s], !1, o);
          }return a;
        }return r !== t ? x.style(e, n, r) : x.css(e, n);
      }, e, n, arguments.length > 1);
    }, show: function show() {
      return rn(this, !0);
    }, hide: function hide() {
      return rn(this);
    }, toggle: function toggle(e) {
      return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
        nn(this) ? x(this).show() : x(this).hide();
      });
    } }), x.extend({ cssHooks: { opacity: { get: function get(e, t) {
          if (t) {
            var n = Wt(e, "opacity");return "" === n ? "1" : n;
          }
        } } }, cssNumber: { columnCount: !0, fillOpacity: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": x.support.cssFloat ? "cssFloat" : "styleFloat" }, style: function style(e, n, r, i) {
      if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
        var o,
            a,
            s,
            l = x.camelCase(n),
            u = e.style;if (n = x.cssProps[l] || (x.cssProps[l] = tn(u, l)), s = x.cssHooks[n] || x.cssHooks[l], r === t) return s && "get" in s && (o = s.get(e, !1, i)) !== t ? o : u[n];if (a = typeof r === "undefined" ? "undefined" : _typeof(r), "string" === a && (o = Jt.exec(r)) && (r = (o[1] + 1) * o[2] + parseFloat(x.css(e, n)), a = "number"), !(null == r || "number" === a && isNaN(r) || ("number" !== a || x.cssNumber[l] || (r += "px"), x.support.clearCloneStyle || "" !== r || 0 !== n.indexOf("background") || (u[n] = "inherit"), s && "set" in s && (r = s.set(e, r, i)) === t))) try {
          u[n] = r;
        } catch (c) {}
      }
    }, css: function css(e, n, r, i) {
      var o,
          a,
          s,
          l = x.camelCase(n);return n = x.cssProps[l] || (x.cssProps[l] = tn(e.style, l)), s = x.cssHooks[n] || x.cssHooks[l], s && "get" in s && (a = s.get(e, !0, r)), a === t && (a = Wt(e, n, i)), "normal" === a && n in Kt && (a = Kt[n]), "" === r || r ? (o = parseFloat(a), r === !0 || x.isNumeric(o) ? o || 0 : a) : a;
    } }), e.getComputedStyle ? (Rt = function Rt(t) {
    return e.getComputedStyle(t, null);
  }, Wt = function Wt(e, n, r) {
    var i,
        o,
        a,
        s = r || Rt(e),
        l = s ? s.getPropertyValue(n) || s[n] : t,
        u = e.style;return s && ("" !== l || x.contains(e.ownerDocument, e) || (l = x.style(e, n)), Yt.test(l) && Ut.test(n) && (i = u.width, o = u.minWidth, a = u.maxWidth, u.minWidth = u.maxWidth = u.width = l, l = s.width, u.width = i, u.minWidth = o, u.maxWidth = a)), l;
  }) : a.documentElement.currentStyle && (Rt = function Rt(e) {
    return e.currentStyle;
  }, Wt = function Wt(e, n, r) {
    var i,
        o,
        a,
        s = r || Rt(e),
        l = s ? s[n] : t,
        u = e.style;return null == l && u && u[n] && (l = u[n]), Yt.test(l) && !zt.test(n) && (i = u.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), u.left = "fontSize" === n ? "1em" : l, l = u.pixelLeft + "px", u.left = i, a && (o.left = a)), "" === l ? "auto" : l;
  });function on(e, t, n) {
    var r = Vt.exec(t);return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t;
  }function an(e, t, n, r, i) {
    var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0,
        a = 0;for (; 4 > o; o += 2) {
      "margin" === n && (a += x.css(e, n + Zt[o], !0, i)), r ? ("content" === n && (a -= x.css(e, "padding" + Zt[o], !0, i)), "margin" !== n && (a -= x.css(e, "border" + Zt[o] + "Width", !0, i))) : (a += x.css(e, "padding" + Zt[o], !0, i), "padding" !== n && (a += x.css(e, "border" + Zt[o] + "Width", !0, i)));
    }return a;
  }function sn(e, t, n) {
    var r = !0,
        i = "width" === t ? e.offsetWidth : e.offsetHeight,
        o = Rt(e),
        a = x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, o);if (0 >= i || null == i) {
      if (i = Wt(e, t, o), (0 > i || null == i) && (i = e.style[t]), Yt.test(i)) return i;r = a && (x.support.boxSizingReliable || i === e.style[t]), i = parseFloat(i) || 0;
    }return i + an(e, t, n || (a ? "border" : "content"), r, o) + "px";
  }function ln(e) {
    var t = a,
        n = Gt[e];return n || (n = un(e, t), "none" !== n && n || (Pt = (Pt || x("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")).appendTo(t.documentElement), t = (Pt[0].contentWindow || Pt[0].contentDocument).document, t.write("<!doctype html><html><body>"), t.close(), n = un(e, t), Pt.detach()), Gt[e] = n), n;
  }function un(e, t) {
    var n = x(t.createElement(e)).appendTo(t.body),
        r = x.css(n[0], "display");return n.remove(), r;
  }x.each(["height", "width"], function (e, n) {
    x.cssHooks[n] = { get: function get(e, r, i) {
        return r ? 0 === e.offsetWidth && Xt.test(x.css(e, "display")) ? x.swap(e, Qt, function () {
          return sn(e, n, i);
        }) : sn(e, n, i) : t;
      }, set: function set(e, t, r) {
        var i = r && Rt(e);return on(e, t, r ? an(e, n, r, x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, i), i) : 0);
      } };
  }), x.support.opacity || (x.cssHooks.opacity = { get: function get(e, t) {
      return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : "";
    }, set: function set(e, t) {
      var n = e.style,
          r = e.currentStyle,
          i = x.isNumeric(t) ? "alpha(opacity=" + 100 * t + ")" : "",
          o = r && r.filter || n.filter || "";n.zoom = 1, (t >= 1 || "" === t) && "" === x.trim(o.replace($t, "")) && n.removeAttribute && (n.removeAttribute("filter"), "" === t || r && !r.filter) || (n.filter = $t.test(o) ? o.replace($t, i) : o + " " + i);
    } }), x(function () {
    x.support.reliableMarginRight || (x.cssHooks.marginRight = { get: function get(e, n) {
        return n ? x.swap(e, { display: "inline-block" }, Wt, [e, "marginRight"]) : t;
      } }), !x.support.pixelPosition && x.fn.position && x.each(["top", "left"], function (e, n) {
      x.cssHooks[n] = { get: function get(e, r) {
          return r ? (r = Wt(e, n), Yt.test(r) ? x(e).position()[n] + "px" : r) : t;
        } };
    });
  }), x.expr && x.expr.filters && (x.expr.filters.hidden = function (e) {
    return 0 >= e.offsetWidth && 0 >= e.offsetHeight || !x.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || x.css(e, "display"));
  }, x.expr.filters.visible = function (e) {
    return !x.expr.filters.hidden(e);
  }), x.each({ margin: "", padding: "", border: "Width" }, function (e, t) {
    x.cssHooks[e + t] = { expand: function expand(n) {
        var r = 0,
            i = {},
            o = "string" == typeof n ? n.split(" ") : [n];for (; 4 > r; r++) {
          i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0];
        }return i;
      } }, Ut.test(e) || (x.cssHooks[e + t].set = on);
  });var cn = /%20/g,
      pn = /\[\]$/,
      fn = /\r?\n/g,
      dn = /^(?:submit|button|image|reset|file)$/i,
      hn = /^(?:input|select|textarea|keygen)/i;x.fn.extend({ serialize: function serialize() {
      return x.param(this.serializeArray());
    }, serializeArray: function serializeArray() {
      return this.map(function () {
        var e = x.prop(this, "elements");return e ? x.makeArray(e) : this;
      }).filter(function () {
        var e = this.type;return this.name && !x(this).is(":disabled") && hn.test(this.nodeName) && !dn.test(e) && (this.checked || !Ct.test(e));
      }).map(function (e, t) {
        var n = x(this).val();return null == n ? null : x.isArray(n) ? x.map(n, function (e) {
          return { name: t.name, value: e.replace(fn, "\r\n") };
        }) : { name: t.name, value: n.replace(fn, "\r\n") };
      }).get();
    } }), x.param = function (e, n) {
    var r,
        i = [],
        o = function o(e, t) {
      t = x.isFunction(t) ? t() : null == t ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t);
    };if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray(e) || e.jquery && !x.isPlainObject(e)) x.each(e, function () {
      o(this.name, this.value);
    });else for (r in e) {
      gn(r, e[r], n, o);
    }return i.join("&").replace(cn, "+");
  };function gn(e, t, n, r) {
    var i;if (x.isArray(t)) x.each(t, function (t, i) {
      n || pn.test(e) ? r(e, i) : gn(e + "[" + ("object" == (typeof i === "undefined" ? "undefined" : _typeof(i)) ? t : "") + "]", i, n, r);
    });else if (n || "object" !== x.type(t)) r(e, t);else for (i in t) {
      gn(e + "[" + i + "]", t[i], n, r);
    }
  }x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (e, t) {
    x.fn[t] = function (e, n) {
      return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);
    };
  }), x.fn.extend({ hover: function hover(e, t) {
      return this.mouseenter(e).mouseleave(t || e);
    }, bind: function bind(e, t, n) {
      return this.on(e, null, t, n);
    }, unbind: function unbind(e, t) {
      return this.off(e, null, t);
    }, delegate: function delegate(e, t, n, r) {
      return this.on(t, e, n, r);
    }, undelegate: function undelegate(e, t, n) {
      return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
    } });var mn,
      yn,
      vn = x.now(),
      bn = /\?/,
      xn = /#.*$/,
      wn = /([?&])_=[^&]*/,
      Tn = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
      Cn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      Nn = /^(?:GET|HEAD)$/,
      kn = /^\/\//,
      En = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
      Sn = x.fn.load,
      An = {},
      jn = {},
      Dn = "*/".concat("*");try {
    yn = o.href;
  } catch (Ln) {
    yn = a.createElement("a"), yn.href = "", yn = yn.href;
  }mn = En.exec(yn.toLowerCase()) || [];function Hn(e) {
    return function (t, n) {
      "string" != typeof t && (n = t, t = "*");var r,
          i = 0,
          o = t.toLowerCase().match(T) || [];if (x.isFunction(n)) while (r = o[i++]) {
        "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n);
      }
    };
  }function qn(e, n, r, i) {
    var o = {},
        a = e === jn;function s(l) {
      var u;return o[l] = !0, x.each(e[l] || [], function (e, l) {
        var c = l(n, r, i);return "string" != typeof c || a || o[c] ? a ? !(u = c) : t : (n.dataTypes.unshift(c), s(c), !1);
      }), u;
    }return s(n.dataTypes[0]) || !o["*"] && s("*");
  }function _n(e, n) {
    var r,
        i,
        o = x.ajaxSettings.flatOptions || {};for (i in n) {
      n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]);
    }return r && x.extend(!0, e, r), e;
  }x.fn.load = function (e, n, r) {
    if ("string" != typeof e && Sn) return Sn.apply(this, arguments);var i,
        o,
        a,
        s = this,
        l = e.indexOf(" ");return l >= 0 && (i = e.slice(l, e.length), e = e.slice(0, l)), x.isFunction(n) ? (r = n, n = t) : n && "object" == (typeof n === "undefined" ? "undefined" : _typeof(n)) && (a = "POST"), s.length > 0 && x.ajax({ url: e, type: a, dataType: "html", data: n }).done(function (e) {
      o = arguments, s.html(i ? x("<div>").append(x.parseHTML(e)).find(i) : e);
    }).complete(r && function (e, t) {
      s.each(r, o || [e.responseText, t, e]);
    }), this;
  }, x.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
    x.fn[t] = function (e) {
      return this.on(t, e);
    };
  }), x.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: yn, type: "GET", isLocal: Cn.test(mn[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Dn, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": x.parseJSON, "text xml": x.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(e, t) {
      return t ? _n(_n(e, x.ajaxSettings), t) : _n(x.ajaxSettings, e);
    }, ajaxPrefilter: Hn(An), ajaxTransport: Hn(jn), ajax: function ajax(e, n) {
      "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) && (n = e, e = t), n = n || {};var r,
          i,
          o,
          a,
          s,
          l,
          u,
          c,
          p = x.ajaxSetup({}, n),
          f = p.context || p,
          d = p.context && (f.nodeType || f.jquery) ? x(f) : x.event,
          h = x.Deferred(),
          g = x.Callbacks("once memory"),
          m = p.statusCode || {},
          y = {},
          v = {},
          b = 0,
          w = "canceled",
          C = { readyState: 0, getResponseHeader: function getResponseHeader(e) {
          var t;if (2 === b) {
            if (!c) {
              c = {};while (t = Tn.exec(a)) {
                c[t[1].toLowerCase()] = t[2];
              }
            }t = c[e.toLowerCase()];
          }return null == t ? null : t;
        }, getAllResponseHeaders: function getAllResponseHeaders() {
          return 2 === b ? a : null;
        }, setRequestHeader: function setRequestHeader(e, t) {
          var n = e.toLowerCase();return b || (e = v[n] = v[n] || e, y[e] = t), this;
        }, overrideMimeType: function overrideMimeType(e) {
          return b || (p.mimeType = e), this;
        }, statusCode: function statusCode(e) {
          var t;if (e) if (2 > b) for (t in e) {
            m[t] = [m[t], e[t]];
          } else C.always(e[C.status]);return this;
        }, abort: function abort(e) {
          var t = e || w;return u && u.abort(t), k(0, t), this;
        } };if (h.promise(C).complete = g.add, C.success = C.done, C.error = C.fail, p.url = ((e || p.url || yn) + "").replace(xn, "").replace(kn, mn[1] + "//"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = x.trim(p.dataType || "*").toLowerCase().match(T) || [""], null == p.crossDomain && (r = En.exec(p.url.toLowerCase()), p.crossDomain = !(!r || r[1] === mn[1] && r[2] === mn[2] && (r[3] || ("http:" === r[1] ? "80" : "443")) === (mn[3] || ("http:" === mn[1] ? "80" : "443")))), p.data && p.processData && "string" != typeof p.data && (p.data = x.param(p.data, p.traditional)), qn(An, p, n, C), 2 === b) return C;l = p.global, l && 0 === x.active++ && x.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Nn.test(p.type), o = p.url, p.hasContent || (p.data && (o = p.url += (bn.test(o) ? "&" : "?") + p.data, delete p.data), p.cache === !1 && (p.url = wn.test(o) ? o.replace(wn, "$1_=" + vn++) : o + (bn.test(o) ? "&" : "?") + "_=" + vn++)), p.ifModified && (x.lastModified[o] && C.setRequestHeader("If-Modified-Since", x.lastModified[o]), x.etag[o] && C.setRequestHeader("If-None-Match", x.etag[o])), (p.data && p.hasContent && p.contentType !== !1 || n.contentType) && C.setRequestHeader("Content-Type", p.contentType), C.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Dn + "; q=0.01" : "") : p.accepts["*"]);for (i in p.headers) {
        C.setRequestHeader(i, p.headers[i]);
      }if (p.beforeSend && (p.beforeSend.call(f, C, p) === !1 || 2 === b)) return C.abort();w = "abort";for (i in { success: 1, error: 1, complete: 1 }) {
        C[i](p[i]);
      }if (u = qn(jn, p, n, C)) {
        C.readyState = 1, l && d.trigger("ajaxSend", [C, p]), p.async && p.timeout > 0 && (s = setTimeout(function () {
          C.abort("timeout");
        }, p.timeout));try {
          b = 1, u.send(y, k);
        } catch (N) {
          if (!(2 > b)) throw N;k(-1, N);
        }
      } else k(-1, "No Transport");function k(e, n, r, i) {
        var c,
            y,
            v,
            w,
            T,
            N = n;2 !== b && (b = 2, s && clearTimeout(s), u = t, a = i || "", C.readyState = e > 0 ? 4 : 0, c = e >= 200 && 300 > e || 304 === e, r && (w = Mn(p, C, r)), w = On(p, w, C, c), c ? (p.ifModified && (T = C.getResponseHeader("Last-Modified"), T && (x.lastModified[o] = T), T = C.getResponseHeader("etag"), T && (x.etag[o] = T)), 204 === e || "HEAD" === p.type ? N = "nocontent" : 304 === e ? N = "notmodified" : (N = w.state, y = w.data, v = w.error, c = !v)) : (v = N, (e || !N) && (N = "error", 0 > e && (e = 0))), C.status = e, C.statusText = (n || N) + "", c ? h.resolveWith(f, [y, N, C]) : h.rejectWith(f, [C, N, v]), C.statusCode(m), m = t, l && d.trigger(c ? "ajaxSuccess" : "ajaxError", [C, p, c ? y : v]), g.fireWith(f, [C, N]), l && (d.trigger("ajaxComplete", [C, p]), --x.active || x.event.trigger("ajaxStop")));
      }return C;
    }, getJSON: function getJSON(e, t, n) {
      return x.get(e, t, n, "json");
    }, getScript: function getScript(e, n) {
      return x.get(e, t, n, "script");
    } }), x.each(["get", "post"], function (e, n) {
    x[n] = function (e, r, i, o) {
      return x.isFunction(r) && (o = o || i, i = r, r = t), x.ajax({ url: e, type: n, dataType: o, data: r, success: i });
    };
  });function Mn(e, n, r) {
    var i,
        o,
        a,
        s,
        l = e.contents,
        u = e.dataTypes;while ("*" === u[0]) {
      u.shift(), o === t && (o = e.mimeType || n.getResponseHeader("Content-Type"));
    }if (o) for (s in l) {
      if (l[s] && l[s].test(o)) {
        u.unshift(s);break;
      }
    }if (u[0] in r) a = u[0];else {
      for (s in r) {
        if (!u[0] || e.converters[s + " " + u[0]]) {
          a = s;break;
        }i || (i = s);
      }a = a || i;
    }return a ? (a !== u[0] && u.unshift(a), r[a]) : t;
  }function On(e, t, n, r) {
    var i,
        o,
        a,
        s,
        l,
        u = {},
        c = e.dataTypes.slice();if (c[1]) for (a in e.converters) {
      u[a.toLowerCase()] = e.converters[a];
    }o = c.shift();while (o) {
      if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift()) if ("*" === o) o = l;else if ("*" !== l && l !== o) {
        if (a = u[l + " " + o] || u["* " + o], !a) for (i in u) {
          if (s = i.split(" "), s[1] === o && (a = u[l + " " + s[0]] || u["* " + s[0]])) {
            a === !0 ? a = u[i] : u[i] !== !0 && (o = s[0], c.unshift(s[1]));break;
          }
        }if (a !== !0) if (a && e["throws"]) t = a(t);else try {
          t = a(t);
        } catch (p) {
          return { state: "parsererror", error: a ? p : "No conversion from " + l + " to " + o };
        }
      }
    }return { state: "success", data: t };
  }x.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /(?:java|ecma)script/ }, converters: { "text script": function textScript(e) {
        return x.globalEval(e), e;
      } } }), x.ajaxPrefilter("script", function (e) {
    e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1);
  }), x.ajaxTransport("script", function (e) {
    if (e.crossDomain) {
      var n,
          r = a.head || x("head")[0] || a.documentElement;return { send: function send(t, i) {
          n = a.createElement("script"), n.async = !0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, t) {
            (t || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), n = null, t || i(200, "success"));
          }, r.insertBefore(n, r.firstChild);
        }, abort: function abort() {
          n && n.onload(t, !0);
        } };
    }
  });var Fn = [],
      Bn = /(=)\?(?=&|$)|\?\?/;x.ajaxSetup({ jsonp: "callback", jsonpCallback: function jsonpCallback() {
      var e = Fn.pop() || x.expando + "_" + vn++;return this[e] = !0, e;
    } }), x.ajaxPrefilter("json jsonp", function (n, r, i) {
    var o,
        a,
        s,
        l = n.jsonp !== !1 && (Bn.test(n.url) ? "url" : "string" == typeof n.data && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Bn.test(n.data) && "data");return l || "jsonp" === n.dataTypes[0] ? (o = n.jsonpCallback = x.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, l ? n[l] = n[l].replace(Bn, "$1" + o) : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? "&" : "?") + n.jsonp + "=" + o), n.converters["script json"] = function () {
      return s || x.error(o + " was not called"), s[0];
    }, n.dataTypes[0] = "json", a = e[o], e[o] = function () {
      s = arguments;
    }, i.always(function () {
      e[o] = a, n[o] && (n.jsonpCallback = r.jsonpCallback, Fn.push(o)), s && x.isFunction(a) && a(s[0]), s = a = t;
    }), "script") : t;
  });var Pn,
      Rn,
      Wn = 0,
      $n = e.ActiveXObject && function () {
    var e;for (e in Pn) {
      Pn[e](t, !0);
    }
  };function In() {
    try {
      return new e.XMLHttpRequest();
    } catch (t) {}
  }function zn() {
    try {
      return new e.ActiveXObject("Microsoft.XMLHTTP");
    } catch (t) {}
  }x.ajaxSettings.xhr = e.ActiveXObject ? function () {
    return !this.isLocal && In() || zn();
  } : In, Rn = x.ajaxSettings.xhr(), x.support.cors = !!Rn && "withCredentials" in Rn, Rn = x.support.ajax = !!Rn, Rn && x.ajaxTransport(function (n) {
    if (!n.crossDomain || x.support.cors) {
      var _r;return { send: function send(i, o) {
          var a,
              s,
              l = n.xhr();if (n.username ? l.open(n.type, n.url, n.async, n.username, n.password) : l.open(n.type, n.url, n.async), n.xhrFields) for (s in n.xhrFields) {
            l[s] = n.xhrFields[s];
          }n.mimeType && l.overrideMimeType && l.overrideMimeType(n.mimeType), n.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest");try {
            for (s in i) {
              l.setRequestHeader(s, i[s]);
            }
          } catch (u) {}l.send(n.hasContent && n.data || null), _r = function r(e, i) {
            var s, u, c, p;try {
              if (_r && (i || 4 === l.readyState)) if (_r = t, a && (l.onreadystatechange = x.noop, $n && delete Pn[a]), i) 4 !== l.readyState && l.abort();else {
                p = {}, s = l.status, u = l.getAllResponseHeaders(), "string" == typeof l.responseText && (p.text = l.responseText);try {
                  c = l.statusText;
                } catch (f) {
                  c = "";
                }s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : s = p.text ? 200 : 404;
              }
            } catch (d) {
              i || o(-1, d);
            }p && o(s, c, p, u);
          }, n.async ? 4 === l.readyState ? setTimeout(_r) : (a = ++Wn, $n && (Pn || (Pn = {}, x(e).unload($n)), Pn[a] = _r), l.onreadystatechange = _r) : _r();
        }, abort: function abort() {
          _r && _r(t, !0);
        } };
    }
  });var Xn,
      Un,
      Vn = /^(?:toggle|show|hide)$/,
      Yn = RegExp("^(?:([+-])=|)(" + w + ")([a-z%]*)$", "i"),
      Jn = /queueHooks$/,
      Gn = [nr],
      Qn = { "*": [function (e, t) {
      var n = this.createTween(e, t),
          r = n.cur(),
          i = Yn.exec(t),
          o = i && i[3] || (x.cssNumber[e] ? "" : "px"),
          a = (x.cssNumber[e] || "px" !== o && +r) && Yn.exec(x.css(n.elem, e)),
          s = 1,
          l = 20;if (a && a[3] !== o) {
        o = o || a[3], i = i || [], a = +r || 1;do {
          s = s || ".5", a /= s, x.style(n.elem, e, a + o);
        } while (s !== (s = n.cur() / r) && 1 !== s && --l);
      }return i && (a = n.start = +a || +r || 0, n.unit = o, n.end = i[1] ? a + (i[1] + 1) * i[2] : +i[2]), n;
    }] };function Kn() {
    return setTimeout(function () {
      Xn = t;
    }), Xn = x.now();
  }function Zn(e, t, n) {
    var r,
        i = (Qn[t] || []).concat(Qn["*"]),
        o = 0,
        a = i.length;for (; a > o; o++) {
      if (r = i[o].call(n, t, e)) return r;
    }
  }function er(e, t, n) {
    var r,
        i,
        o = 0,
        a = Gn.length,
        s = x.Deferred().always(function () {
      delete l.elem;
    }),
        l = function l() {
      if (i) return !1;var t = Xn || Kn(),
          n = Math.max(0, u.startTime + u.duration - t),
          r = n / u.duration || 0,
          o = 1 - r,
          a = 0,
          l = u.tweens.length;for (; l > a; a++) {
        u.tweens[a].run(o);
      }return s.notifyWith(e, [u, o, n]), 1 > o && l ? n : (s.resolveWith(e, [u]), !1);
    },
        u = s.promise({ elem: e, props: x.extend({}, t), opts: x.extend(!0, { specialEasing: {} }, n), originalProperties: t, originalOptions: n, startTime: Xn || Kn(), duration: n.duration, tweens: [], createTween: function createTween(t, n) {
        var r = x.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);return u.tweens.push(r), r;
      }, stop: function stop(t) {
        var n = 0,
            r = t ? u.tweens.length : 0;if (i) return this;for (i = !0; r > n; n++) {
          u.tweens[n].run(1);
        }return t ? s.resolveWith(e, [u, t]) : s.rejectWith(e, [u, t]), this;
      } }),
        c = u.props;for (tr(c, u.opts.specialEasing); a > o; o++) {
      if (r = Gn[o].call(u, e, c, u.opts)) return r;
    }return x.map(c, Zn, u), x.isFunction(u.opts.start) && u.opts.start.call(e, u), x.fx.timer(x.extend(l, { elem: e, anim: u, queue: u.opts.queue })), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always);
  }function tr(e, t) {
    var n, r, i, o, a;for (n in e) {
      if (r = x.camelCase(n), i = t[r], o = e[n], x.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), a = x.cssHooks[r], a && "expand" in a) {
        o = a.expand(o), delete e[r];for (n in o) {
          n in e || (e[n] = o[n], t[n] = i);
        }
      } else t[r] = i;
    }
  }x.Animation = x.extend(er, { tweener: function tweener(e, t) {
      x.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");var n,
          r = 0,
          i = e.length;for (; i > r; r++) {
        n = e[r], Qn[n] = Qn[n] || [], Qn[n].unshift(t);
      }
    }, prefilter: function prefilter(e, t) {
      t ? Gn.unshift(e) : Gn.push(e);
    } });function nr(e, t, n) {
    var r,
        i,
        o,
        a,
        s,
        l,
        u = this,
        c = {},
        p = e.style,
        f = e.nodeType && nn(e),
        d = x._data(e, "fxshow");n.queue || (s = x._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function () {
      s.unqueued || l();
    }), s.unqueued++, u.always(function () {
      u.always(function () {
        s.unqueued--, x.queue(e, "fx").length || s.empty.fire();
      });
    })), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], "inline" === x.css(e, "display") && "none" === x.css(e, "float") && (x.support.inlineBlockNeedsLayout && "inline" !== ln(e.nodeName) ? p.zoom = 1 : p.display = "inline-block")), n.overflow && (p.overflow = "hidden", x.support.shrinkWrapBlocks || u.always(function () {
      p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2];
    }));for (r in t) {
      if (i = t[r], Vn.exec(i)) {
        if (delete t[r], o = o || "toggle" === i, i === (f ? "hide" : "show")) continue;c[r] = d && d[r] || x.style(e, r);
      }
    }if (!x.isEmptyObject(c)) {
      d ? "hidden" in d && (f = d.hidden) : d = x._data(e, "fxshow", {}), o && (d.hidden = !f), f ? x(e).show() : u.done(function () {
        x(e).hide();
      }), u.done(function () {
        var t;x._removeData(e, "fxshow");for (t in c) {
          x.style(e, t, c[t]);
        }
      });for (r in c) {
        a = Zn(f ? d[r] : 0, r, u), r in d || (d[r] = a.start, f && (a.end = a.start, a.start = "width" === r || "height" === r ? 1 : 0));
      }
    }
  }function rr(e, t, n, r, i) {
    return new rr.prototype.init(e, t, n, r, i);
  }x.Tween = rr, rr.prototype = { constructor: rr, init: function init(e, t, n, r, i, o) {
      this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (x.cssNumber[n] ? "" : "px");
    }, cur: function cur() {
      var e = rr.propHooks[this.prop];return e && e.get ? e.get(this) : rr.propHooks._default.get(this);
    }, run: function run(e) {
      var t,
          n = rr.propHooks[this.prop];return this.pos = t = this.options.duration ? x.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : rr.propHooks._default.set(this), this;
    } }, rr.prototype.init.prototype = rr.prototype, rr.propHooks = { _default: { get: function get(e) {
        var t;return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = x.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop];
      }, set: function set(e) {
        x.fx.step[e.prop] ? x.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[x.cssProps[e.prop]] || x.cssHooks[e.prop]) ? x.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now;
      } } }, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = { set: function set(e) {
      e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
    } }, x.each(["toggle", "show", "hide"], function (e, t) {
    var n = x.fn[t];x.fn[t] = function (e, r, i) {
      return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i);
    };
  }), x.fn.extend({ fadeTo: function fadeTo(e, t, n, r) {
      return this.filter(nn).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r);
    }, animate: function animate(e, t, n, r) {
      var i = x.isEmptyObject(e),
          o = x.speed(t, n, r),
          a = function a() {
        var t = er(this, x.extend({}, e), o);(i || x._data(this, "finish")) && t.stop(!0);
      };return a.finish = a, i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a);
    }, stop: function stop(e, n, r) {
      var i = function i(e) {
        var t = e.stop;delete e.stop, t(r);
      };return "string" != typeof e && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || "fx", []), this.each(function () {
        var t = !0,
            n = null != e && e + "queueHooks",
            o = x.timers,
            a = x._data(this);if (n) a[n] && a[n].stop && i(a[n]);else for (n in a) {
          a[n] && a[n].stop && Jn.test(n) && i(a[n]);
        }for (n = o.length; n--;) {
          o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(r), t = !1, o.splice(n, 1));
        }(t || !r) && x.dequeue(this, e);
      });
    }, finish: function finish(e) {
      return e !== !1 && (e = e || "fx"), this.each(function () {
        var t,
            n = x._data(this),
            r = n[e + "queue"],
            i = n[e + "queueHooks"],
            o = x.timers,
            a = r ? r.length : 0;for (n.finish = !0, x.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;) {
          o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
        }for (t = 0; a > t; t++) {
          r[t] && r[t].finish && r[t].finish.call(this);
        }delete n.finish;
      });
    } });function ir(e, t) {
    var n,
        r = { height: e },
        i = 0;for (t = t ? 1 : 0; 4 > i; i += 2 - t) {
      n = Zt[i], r["margin" + n] = r["padding" + n] = e;
    }return t && (r.opacity = r.width = e), r;
  }x.each({ slideDown: ir("show"), slideUp: ir("hide"), slideToggle: ir("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, t) {
    x.fn[e] = function (e, n, r) {
      return this.animate(t, e, n, r);
    };
  }), x.speed = function (e, t, n) {
    var r = e && "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) ? x.extend({}, e) : { complete: n || !n && t || x.isFunction(e) && e, duration: e, easing: n && t || t && !x.isFunction(t) && t };return r.duration = x.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in x.fx.speeds ? x.fx.speeds[r.duration] : x.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {
      x.isFunction(r.old) && r.old.call(this), r.queue && x.dequeue(this, r.queue);
    }, r;
  }, x.easing = { linear: function linear(e) {
      return e;
    }, swing: function swing(e) {
      return .5 - Math.cos(e * Math.PI) / 2;
    } }, x.timers = [], x.fx = rr.prototype.init, x.fx.tick = function () {
    var e,
        n = x.timers,
        r = 0;for (Xn = x.now(); n.length > r; r++) {
      e = n[r], e() || n[r] !== e || n.splice(r--, 1);
    }n.length || x.fx.stop(), Xn = t;
  }, x.fx.timer = function (e) {
    e() && x.timers.push(e) && x.fx.start();
  }, x.fx.interval = 13, x.fx.start = function () {
    Un || (Un = setInterval(x.fx.tick, x.fx.interval));
  }, x.fx.stop = function () {
    clearInterval(Un), Un = null;
  }, x.fx.speeds = { slow: 600, fast: 200, _default: 400 }, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = function (e) {
    return x.grep(x.timers, function (t) {
      return e === t.elem;
    }).length;
  }), x.fn.offset = function (e) {
    if (arguments.length) return e === t ? this : this.each(function (t) {
      x.offset.setOffset(this, e, t);
    });var n,
        r,
        o = { top: 0, left: 0 },
        a = this[0],
        s = a && a.ownerDocument;if (s) return n = s.documentElement, x.contains(n, a) ? (_typeof(a.getBoundingClientRect) !== i && (o = a.getBoundingClientRect()), r = or(s), { top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0) }) : o;
  }, x.offset = { setOffset: function setOffset(e, t, n) {
      var r = x.css(e, "position");"static" === r && (e.style.position = "relative");var i = x(e),
          o = i.offset(),
          a = x.css(e, "top"),
          s = x.css(e, "left"),
          l = ("absolute" === r || "fixed" === r) && x.inArray("auto", [a, s]) > -1,
          u = {},
          c = {},
          p,
          f;l ? (c = i.position(), p = c.top, f = c.left) : (p = parseFloat(a) || 0, f = parseFloat(s) || 0), x.isFunction(t) && (t = t.call(e, n, o)), null != t.top && (u.top = t.top - o.top + p), null != t.left && (u.left = t.left - o.left + f), "using" in t ? t.using.call(e, u) : i.css(u);
    } }, x.fn.extend({ position: function position() {
      if (this[0]) {
        var e,
            t,
            n = { top: 0, left: 0 },
            r = this[0];return "fixed" === x.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), x.nodeName(e[0], "html") || (n = e.offset()), n.top += x.css(e[0], "borderTopWidth", !0), n.left += x.css(e[0], "borderLeftWidth", !0)), { top: t.top - n.top - x.css(r, "marginTop", !0), left: t.left - n.left - x.css(r, "marginLeft", !0) };
      }
    }, offsetParent: function offsetParent() {
      return this.map(function () {
        var e = this.offsetParent || s;while (e && !x.nodeName(e, "html") && "static" === x.css(e, "position")) {
          e = e.offsetParent;
        }return e || s;
      });
    } }), x.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (e, n) {
    var r = /Y/.test(n);x.fn[e] = function (i) {
      return x.access(this, function (e, i, o) {
        var a = or(e);return o === t ? a ? n in a ? a[n] : a.document.documentElement[i] : e[i] : (a ? a.scrollTo(r ? x(a).scrollLeft() : o, r ? o : x(a).scrollTop()) : e[i] = o, t);
      }, e, i, arguments.length, null);
    };
  });function or(e) {
    return x.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1;
  }x.each({ Height: "height", Width: "width" }, function (e, n) {
    x.each({ padding: "inner" + e, content: n, "": "outer" + e }, function (r, i) {
      x.fn[i] = function (i, o) {
        var a = arguments.length && (r || "boolean" != typeof i),
            s = r || (i === !0 || o === !0 ? "margin" : "border");return x.access(this, function (n, r, i) {
          var o;return x.isWindow(n) ? n.document.documentElement["client" + e] : 9 === n.nodeType ? (o = n.documentElement, Math.max(n.body["scroll" + e], o["scroll" + e], n.body["offset" + e], o["offset" + e], o["client" + e])) : i === t ? x.css(n, r, s) : x.style(n, r, i, s);
        }, n, a ? i : t, a, null);
      };
    });
  }), x.fn.size = function () {
    return this.length;
  }, x.fn.andSelf = x.fn.addBack, "object" == ( false ? "undefined" : _typeof(module)) && module && "object" == _typeof(module.exports) ? module.exports = x : (e.jQuery = e.$ = x, "function" == "function" && __webpack_require__(18) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
    return x;
  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)));
})(window);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @license
 * Lo-Dash 1.3.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.4.4 <http://underscorejs.org/>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * Available under MIT license <http://lodash.com/license>
 */
;(function (window) {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date() + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to detect functions containing a `this` reference */
  var reThis = (reThis = /\bthis\b/) && reThis.test(runInContext) && reThis;

  /** Used to detect and test whitespace */
  var whitespace =
  // whitespace
  ' \t\x0B\f\xA0\uFEFF' +

  // line terminators
  '\n\r\u2028\u2029' +

  // unicode category "Zs" space separators
  '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000';

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to match HTML characters */
  var reUnescapedHtml = /[&<>"']/g;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = ['Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object', 'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN', 'parseInt', 'setImmediate', 'setTimeout'];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports` */
  var freeExports = objectTypes[ false ? 'undefined' : _typeof(exports)] && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[ false ? 'undefined' : _typeof(module)] && module && module.exports == freeExports && module;

  /** Detect free variable `global`, from Node.js or Browserified code, and use it as `window` */
  var freeGlobal = objectTypes[typeof global === 'undefined' ? 'undefined' : _typeof(global)] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    window = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * A basic implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Number} [fromIndex=0] The index to search from.
   * @returns {Number} Returns the index of the matched value or `-1`.
   */
  function basicIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {Mixed} value The value to search for.
   * @returns {Number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value];
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = cache[type] || (cache[type] = {});

    return type == 'object' ? cache[key] && basicIndexOf(cache[key], value) > -1 ? 0 : -1 : cache[key] ? 0 : -1;
  }

  /**
   * Adds a given `value` to the corresponding cache object.
   *
   * @private
   * @param {Mixed} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        if ((typeCache[key] || (typeCache[key] = [])).push(value) == this.array.length) {
          cache[type] = false;
        }
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default `callback` when a given
   * `collection` is a string value.
   *
   * @private
   * @param {String} value The character to inspect.
   * @returns {Number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` values, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {Number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ai = a.index,
        bi = b.index;

    a = a.criteria;
    b = b.criteria;

    // ensure a stable sort in V8 and other engines
    // http://code.google.com/p/v8/issues/detail?id=90
    if (a !== b) {
      if (a > b || typeof a == 'undefined') {
        return 1;
      }
      if (a < b || typeof b == 'undefined') {
        return -1;
      }
    }
    return ai < bi ? -1 : 1;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {Null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length;

    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return cache.object === false ? (releaseObject(result), null) : result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {String} match The matched character to escape.
   * @returns {String} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'leading': false,
      'maxWait': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'trailing': false,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * A no-operation function.
   *
   * @private
   */
  function noop() {}
  // no operation performed


  /**
   * Releases the given `array` back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given `object` back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used, instead of `Array#slice`, to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|String} collection The collection to slice.
   * @param {Number} start The start index.
   * @param {Number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=window] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.com/#x11.1.5.
    context = context ? _.defaults(window.Object(), context, _.pick(window, contextProps)) : window;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' + String(objectProto.valueOf).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/valueOf|for [^\]]+/g, '.+?') + '$');

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        concat = arrayRef.concat,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        setImmediate = context.setImmediate,
        setTimeout = context.setTimeout,
        toString = objectProto.toString;

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind,
        nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeSlice = arrayRef.slice;

    /** Detect various environments */
    var isIeOpera = reNative.test(context.attachEvent),
        isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object, which wraps the given `value`, to enable method
     * chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `createCallback`, `debounce`, `defaults`,
     * `defer`, `delay`, `difference`, `filter`, `flatten`, `forEach`, `forIn`,
     * `forOwn`, `functions`, `groupBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `push`, `range`,
     * `reject`, `rest`, `reverse`, `shuffle`, `slice`, `sort`, `sortBy`, `splice`,
     * `tap`, `throttle`, `times`, `toArray`, `transform`, `union`, `uniq`, `unshift`,
     * `unzip`, `values`, `where`, `without`, `wrap`, and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `has`,
     * `identity`, `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`,
     * `isElement`, `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`,
     * `isNull`, `isNumber`, `isObject`, `isPlainObject`, `isRegExp`, `isString`,
     * `isUndefined`, `join`, `lastIndexOf`, `mixin`, `noConflict`, `parseInt`,
     * `pop`, `random`, `reduce`, `reduceRight`, `result`, `shift`, `size`, `some`,
     * `sortedIndex`, `runInContext`, `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * passed, otherwise they return unwrapped values.
     *
     * @name _
     * @constructor
     * @alias chain
     * @category Chaining
     * @param {Mixed} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {Mixed} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value) {
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if `Function#bind` exists and is inferred to be fast (all but V8).
     *
     * @memberOf _.support
     * @type Boolean
     */
    support.fastBind = nativeBind && !isV8;

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type String
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that, when called, invokes `func` with the `this` binding
     * of `thisArg` and prepends any `partialArgs` to the arguments passed to the
     * bound function.
     *
     * @private
     * @param {Function|String} func The function to bind or the method name.
     * @param {Mixed} [thisArg] The `this` binding of `func`.
     * @param {Array} partialArgs An array of arguments to be partially applied.
     * @param {Object} [idicator] Used to indicate binding by key or partially
     *  applying arguments from the right.
     * @returns {Function} Returns the new bound function.
     */
    function createBound(func, thisArg, partialArgs, indicator) {
      var isFunc = isFunction(func),
          isPartial = !partialArgs,
          key = thisArg;

      // juggle arguments
      if (isPartial) {
        var rightIndicator = indicator;
        partialArgs = thisArg;
      } else if (!isFunc) {
        if (!indicator) {
          throw new TypeError();
        }
        thisArg = func;
      }

      function bound() {
        // `Function#bind` spec
        // http://es5.github.com/#x15.3.4.5
        var args = arguments,
            thisBinding = isPartial ? this : thisArg;

        if (!isFunc) {
          func = thisArg[key];
        }
        if (partialArgs.length) {
          args = args.length ? (args = nativeSlice.call(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args)) : partialArgs;
        }
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          thisBinding = createObject(func.prototype);

          // mimic the constructor's `return` behavior
          // http://es5.github.com/#x13.2.2
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      return bound;
    }

    /**
     * Creates a new object with the specified `prototype`.
     *
     * @private
     * @param {Object} prototype The prototype object.
     * @returns {Object} Returns the new object.
     */
    function createObject(prototype) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {String} match The matched character to escape.
     * @returns {String} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `basicIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf(array, value, fromIndex) {
      var result = (result = lodash.indexOf) === indexOf ? basicIndexOf : result;
      return result;
    }

    /**
     * Creates a function that juggles arguments, allowing argument overloading
     * for `_.flatten` and `_.uniq`, before passing them to the given `func`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @returns {Function} Returns the new function.
     */
    function overloadWrapper(func) {
      return function (array, flag, callback, thisArg) {
        // juggle arguments
        if (typeof flag != 'boolean' && flag != null) {
          thisArg = callback;
          callback = !(thisArg && thisArg[flag] === array) ? flag : undefined;
          flag = false;
        }
        if (callback != null) {
          callback = lodash.createCallback(callback, thisArg);
        }
        return func(array, flag, callback, thisArg);
      };
    }

    /**
     * A fallback implementation of `isPlainObject` which checks if a given `value`
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor, result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function (value, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {String} match The matched character to unescape.
     * @returns {String} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return toString.call(value) == argsClass;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray;

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property names.
     */
    var shimKeys = function shimKeys(object) {
      var index,
          iterable = object,
          result = [];
      if (!iterable) return result;
      if (!objectTypes[typeof object === 'undefined' ? 'undefined' : _typeof(object)]) return result;
      for (index in iterable) {
        if (hasOwnProperty.call(iterable, index)) {
          result.push(index);
        }
      }
      return result;
    };

    /**
     * Creates an array composed of the own enumerable property names of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (order is not guaranteed)
     */
    var keys = !nativeKeys ? shimKeys : function (object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a `callback` function is passed, it will be executed to produce
     * the assigned values. The `callback` is bound to `thisArg` and invoked with
     * two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {Object} [source1, source2, ...] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'moe' }, { 'age': 40 });
     * // => { 'name': 'moe', 'age': 40 }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var food = { 'name': 'apple' };
     * defaults(food, { 'name': 'banana', 'type': 'fruit' });
     * // => { 'name': 'apple', 'type': 'fruit' }
     */
    var assign = function assign(object, source, guard) {
      var index,
          iterable = object,
          result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = lodash.createCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable === 'undefined' ? 'undefined' : _typeof(iterable)]) {
          var ownIndex = -1,
              ownProps = objectTypes[typeof iterable === 'undefined' ? 'undefined' : _typeof(iterable)] && keys(iterable),
              length = ownProps ? ownProps.length : 0;

          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
          }
        }
      }
      return result;
    };

    /**
     * Creates a clone of `value`. If `deep` is `true`, nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a `callback`
     * function is passed, it will be executed to produce the cloned values. If
     * `callback` returns `undefined`, cloning will be handled by the method instead.
     * The `callback` is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to clone.
     * @param {Boolean} [deep=false] A flag to indicate a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @param- {Array} [stackA=[]] Tracks traversed source objects.
     * @param- {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {Mixed} Returns the cloned `value`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * var shallow = _.clone(stooges);
     * shallow[0] === stooges[0];
     * // => true
     *
     * var deep = _.clone(stooges, true);
     * deep[0] === stooges[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, deep, callback, thisArg, stackA, stackB) {
      var result = value;

      // allows working with "Collections" methods without using their `callback`
      // argument, `index|key`, for this method's `callback`
      if (typeof deep != 'boolean' && deep != null) {
        thisArg = callback;
        callback = deep;
        deep = false;
      }
      if (typeof callback == 'function') {
        callback = typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg, 1);

        result = callback(result);
        if (typeof result != 'undefined') {
          return result;
        }
        result = value;
      }
      // inspect [[Class]]
      var isObj = isObject(result);
      if (isObj) {
        var className = toString.call(result);
        if (!cloneableClasses[className]) {
          return result;
        }
        var isArr = isArray(result);
      }
      // shallow clone
      if (!isObj || !deep) {
        return isObj ? isArr ? slice(result) : assign({}, result) : result;
      }
      var ctor = ctorByClass[className];
      switch (className) {
        case boolClass:
        case dateClass:
          return new ctor(+result);

        case numberClass:
        case stringClass:
          return new ctor(result);

        case regexpClass:
          return ctor(result.source, reFlags.exec(result));
      }
      // check for circular references and return corresponding clone
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // init cloned object
      result = isArr ? ctor(result.length) : {};

      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function (objValue, key) {
        result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * Creates a deep clone of `value`. If a `callback` function is passed,
     * it will be executed to produce the cloned values. If `callback` returns
     * `undefined`, cloning will be handled by the method instead. The `callback`
     * is bound to `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the deep cloned `value`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * var deep = _.cloneDeep(stooges);
     * deep[0] === stooges[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return clone(value, true, callback, thisArg);
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {Object} [source1, source2, ...] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  callback's `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var food = { 'name': 'apple' };
     * _.defaults(food, { 'name': 'banana', 'type': 'fruit' });
     * // => { 'name': 'apple', 'type': 'fruit' }
     */
    var defaults = function defaults(object, source, guard) {
      var index,
          iterable = object,
          result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable === 'undefined' ? 'undefined' : _typeof(iterable)]) {
          var ownIndex = -1,
              ownProps = objectTypes[typeof iterable === 'undefined' ? 'undefined' : _typeof(iterable)] && keys(iterable),
              length = ownProps ? ownProps.length : 0;

          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            if (typeof result[index] == 'undefined') result[index] = iterable[index];
          }
        }
      }
      return result;
    };

    /**
     * This method is similar to `_.find`, except that it returns the key of the
     * element that passes the callback check, instead of the element itself.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the key of the found element, else `undefined`.
     * @example
     *
     * _.findKey({ 'a': 1, 'b': 2, 'c': 3, 'd': 4 }, function(num) {
     *   return num % 2 == 0;
     * });
     * // => 'b'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg);
      forOwn(object, function (value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over `object`'s own and inherited enumerable properties, executing
     * the `callback` for each property. The `callback` is bound to `thisArg` and
     * invoked with three arguments; (value, key, object). Callbacks may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Dog(name) {
     *   this.name = name;
     * }
     *
     * Dog.prototype.bark = function() {
     *   alert('Woof, woof!');
     * };
     *
     * _.forIn(new Dog('Dagny'), function(value, key) {
     *   alert(key);
     * });
     * // => alerts 'name' and 'bark' (order is not guaranteed)
     */
    var forIn = function forIn(collection, callback, thisArg) {
      var index,
          iterable = collection,
          result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable === 'undefined' ? 'undefined' : _typeof(iterable)]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
      for (index in iterable) {
        if (callback(iterable[index], index, collection) === false) return result;
      }
      return result;
    };

    /**
     * Iterates over an object's own enumerable properties, executing the `callback`
     * for each property. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
     * returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   alert(key);
     * });
     * // => alerts '0', '1', and 'length' (order is not guaranteed)
     */
    var forOwn = function forOwn(collection, callback, thisArg) {
      var index,
          iterable = collection,
          result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable === 'undefined' ? 'undefined' : _typeof(iterable)]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
      var ownIndex = -1,
          ownProps = objectTypes[typeof iterable === 'undefined' ? 'undefined' : _typeof(iterable)] && keys(iterable),
          length = ownProps ? ownProps.length : 0;

      while (++ownIndex < length) {
        index = ownProps[ownIndex];
        if (callback(iterable[index], index, collection) === false) return result;
      }
      return result;
    };

    /**
     * Creates a sorted array of all enumerable properties, own and inherited,
     * of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function (value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified object `property` exists and is a direct property,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to check.
     * @param {String} property The property to check for.
     * @returns {Boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, property) {
      return object ? hasOwnProperty.call(object, property) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     *  _.invert({ 'first': 'moe', 'second': 'larry' });
     * // => { 'moe': 'first', 'larry': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || toString.call(value) == boolClass;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value ? (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && toString.call(value) == dateClass : false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value ? value.nodeType === 1 : false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|String} value The value to inspect.
     * @returns {Boolean} Returns `true`, if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
        return !length;
      }
      forOwn(value, function () {
        return result = false;
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If `callback` is passed, it will be executed to
     * compare values. If `callback` returns `undefined`, comparisons will be handled
     * by the method instead. The `callback` is bound to `thisArg` and invoked with
     * two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} a The value to compare.
     * @param {Mixed} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @param- {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param- {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {Boolean} Returns `true`, if the values are equivalent, else `false`.
     * @example
     *
     * var moe = { 'name': 'moe', 'age': 40 };
     * var copy = { 'name': 'moe', 'age': 40 };
     *
     * moe == copy;
     * // => false
     *
     * _.isEqual(moe, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      var whereIndicator = callback === indicatorObject;
      if (typeof callback == 'function' && !whereIndicator) {
        callback = lodash.createCallback(callback, thisArg, 2);
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || 1 / a == 1 / b;
      }
      var type = typeof a === 'undefined' ? 'undefined' : _typeof(a),
          otherType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

      // exit early for unlike primitive values
      if (a === a && (!a || type != 'function' && type != 'object') && (!b || otherType != 'function' && otherType != 'object')) {
        return false;
      }
      // exit early for `null` and `undefined`, avoiding ES3's Function#call behavior
      // http://es5.github.com/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return a != +a ? b != +b
          // but treat `+0` vs. `-0` as not equal
          : a == 0 ? 1 / a == 1 / b : a == +b;

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        if (hasOwnProperty.call(a, '__wrapped__ ') || hasOwnProperty.call(b, '__wrapped__')) {
          return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        length = a.length;
        size = b.length;

        // compare lengths to determine if a deep comparison is necessary
        result = size == a.length;
        if (!result && !whereIndicator) {
          return result;
        }
        // deep compare the contents, ignoring non-numeric properties
        while (size--) {
          var index = length,
              value = b[size];

          if (whereIndicator) {
            while (index--) {
              if (result = isEqual(a[index], value, callback, thisArg, stackA, stackB)) {
                break;
              }
            }
          } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
            break;
          }
        }
        return result;
      }
      // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
      // which, in this case, is more costly
      forIn(b, function (value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          // count the number of properties.
          size++;
          // deep compare each property value.
          return result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB);
        }
      });

      if (result && !whereIndicator) {
        // ensure both objects have the same number of properties
        forIn(a, function (value, key, a) {
          if (hasOwnProperty.call(a, key)) {
            // `size` will be `-1` if `a` has more properties than `b`
            return result = --size > -1;
          }
        });
      }
      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite`, which will return true for
     * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.com/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value === 'undefined' ? 'undefined' : _typeof(value)]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN`, which will return `true` for
     * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' || toString.call(value) == numberClass;
    }

    /**
     * Checks if a given `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
     * @example
     *
     * function Stooge(name, age) {
     *   this.name = name;
     *   this.age = age;
     * }
     *
     * _.isPlainObject(new Stooge('moe', 40));
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'name': 'moe', 'age': 40 });
     * // => true
     */
    var isPlainObject = function isPlainObject(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/moe/);
     * // => true
     */
    function isRegExp(value) {
      return value ? (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && toString.call(value) == regexpClass : false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('moe');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' || toString.call(value) == stringClass;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined`, into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a `callback` function
     * is passed, it will be executed to produce the merged values of the destination
     * and source properties. If `callback` returns `undefined`, merging will be
     * handled by the method instead. The `callback` is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {Object} [source1, source2, ...] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @param- {Object} [deepIndicator] Indicates that `stackA` and `stackB` are
     *  arrays of traversed objects, instead of source objects.
     * @param- {Array} [stackA=[]] Tracks traversed source objects.
     * @param- {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'stooges': [
     *     { 'name': 'moe' },
     *     { 'name': 'larry' }
     *   ]
     * };
     *
     * var ages = {
     *   'stooges': [
     *     { 'age': 40 },
     *     { 'age': 50 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'stooges': [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object, source, deepIndicator) {
      var args = arguments,
          index = 0,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      if (deepIndicator === indicatorObject) {
        var callback = args[3],
            stackA = args[4],
            stackB = args[5];
      } else {
        var initedStack = true;
        stackA = getArray();
        stackB = getArray();

        // allows working with `_.reduce` and `_.reduceRight` without
        // using their `callback` arguments, `index|key` and `collection`
        if (typeof deepIndicator != 'number') {
          length = args.length;
        }
        if (length > 3 && typeof args[length - 2] == 'function') {
          callback = lodash.createCallback(args[--length - 1], args[length--], 2);
        } else if (length > 2 && typeof args[length - 1] == 'function') {
          callback = args[--length];
        }
      }
      while (++index < length) {
        (isArray(args[index]) ? forEach : forOwn)(args[index], function (source, key) {
          var found,
              isArr,
              result = source,
              value = object[key];

          if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
            // avoid merging previously merged cyclic sources
            var stackLength = stackA.length;
            while (stackLength--) {
              if (found = stackA[stackLength] == source) {
                value = stackB[stackLength];
                break;
              }
            }
            if (!found) {
              var isShallow;
              if (callback) {
                result = callback(value, source);
                if (isShallow = typeof result != 'undefined') {
                  value = result;
                }
              }
              if (!isShallow) {
                value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
              }
              // add `source` and associated `value` to the stack of traversed objects
              stackA.push(source);
              stackB.push(value);

              // recursively merge objects and arrays (susceptible to call stack limits)
              if (!isShallow) {
                value = merge(value, source, indicatorObject, callback, stackA, stackB);
              }
            }
          } else {
            if (callback) {
              result = callback(value, source);
              if (typeof result == 'undefined') {
                result = source;
              }
            }
            if (typeof result != 'undefined') {
              value = result;
            }
          }
          object[key] = value;
        });
      }

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a `callback` function is passed, it will be executed
     * for each property in the `object`, omitting the properties `callback`
     * returns truthy for. The `callback` is bound to `thisArg` and invoked
     * with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit
     *  or the function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'moe', 'age': 40 }, 'age');
     * // => { 'name': 'moe' }
     *
     * _.omit({ 'name': 'moe', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'moe' }
     */
    function omit(object, callback, thisArg) {
      var indexOf = getIndexOf(),
          isFunc = typeof callback == 'function',
          result = {};

      if (isFunc) {
        callback = lodash.createCallback(callback, thisArg);
      } else {
        var props = concat.apply(arrayRef, nativeSlice.call(arguments, 1));
      }
      forIn(object, function (value, key, object) {
        if (isFunc ? !callback(value, key, object) : indexOf(props, key) < 0) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Creates a two dimensional array of the given object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'moe': 30, 'larry': 40 });
     * // => [['moe', 30], ['larry', 40]] (order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of property
     * names. If `callback` is passed, it will be executed for each property in the
     * `object`, picking the properties `callback` returns truthy for. The `callback`
     * is bound to `thisArg` and invoked with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Array|Function|String} callback|[prop1, prop2, ...] The function called
     *  per iteration or properties to pick, either as individual arguments or arrays.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'moe', '_userid': 'moe1' }, 'name');
     * // => { 'name': 'moe' }
     *
     * _.pick({ 'name': 'moe', '_userid': 'moe1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'moe' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg);
        forIn(object, function (value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce`, this method transforms an `object` to a new
     * `accumulator` object which is the result of running each of its elements
     * through the `callback`, with each `callback` execution potentially mutating
     * the `accumulator` object. The `callback` is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [accumulator] The custom accumulator value.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      callback = lodash.createCallback(callback, thisArg, 4);

      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = createObject(proto);
        }
      }
      (isArr ? forEach : forOwn)(object, function (value, index, object) {
        return callback(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (order is not guaranteed)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Array|Number|String} [index1, index2, ...] The indexes of
     *  `collection` to retrieve, either as individual arguments or arrays.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['moe', 'larry', 'curly'], 0, 2);
     * // => ['moe', 'curly']
     */
    function at(collection) {
      var index = -1,
          props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given `target` element is present in a `collection` using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Mixed} target The value to check for.
     * @param {Number} [fromIndex=0] The index to search from.
     * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');
     * // => true
     *
     * _.contains('curly', 'ur');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (length && typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function (value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys returned from running each element of the
     * `collection` through the given `callback`. The corresponding value of each key
     * is the number of times the key was returned by the `callback`. The `callback`
     * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    function countBy(collection, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg);

      forEach(collection, function (value, key, collection) {
        key = String(callback(value, key, collection));
        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
      });
      return result;
    }

    /**
     * Checks if the `callback` returns a truthy value for **all** elements of a
     * `collection`. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Boolean} Returns `true` if all elements pass the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(stooges, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(stooges, { 'age': 50 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          return result = !!callback(value, index, collection);
        });
      }
      return result;
    }

    /**
     * Examines each element in a `collection`, returning an array of all elements
     * the `callback` returns truthy for. The `callback` is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(food, 'organic');
     * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
     *
     * // using "_.where" callback shorthand
     * _.filter(food, { 'type': 'fruit' });
     * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Examines each element in a `collection`, returning the first that the `callback`
     * returns truthy for. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the found element, else `undefined`.
     * @example
     *
     * _.find([1, 2, 3, 4], function(num) {
     *   return num % 2 == 0;
     * });
     * // => 2
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },
     *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.find(food, { 'type': 'vegetable' });
     * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }
     *
     * // using "_.pluck" callback shorthand
     * _.find(food, 'organic');
     * // => { 'name': 'banana', 'organic': true, 'type': 'fruit' }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function (value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * Iterates over a `collection`, executing the `callback` for each element in
     * the `collection`. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection). Callbacks may exit iteration early
     * by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|String} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(alert).join(',');
     * // => alerts each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, alert);
     * // => alerts each number value (order is not guaranteed)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * Creates an object composed of keys returned from running each element of the
     * `collection` through the `callback`. The corresponding value of each key is
     * an array of elements passed to `callback` that returned the key. The `callback`
     * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    function groupBy(collection, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg);

      forEach(collection, function (value, key, collection) {
        key = String(callback(value, key, collection));
        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
      });
      return result;
    }

    /**
     * Invokes the method named by `methodName` on each element in the `collection`,
     * returning an array of the results of each invoked method. Additional arguments
     * will be passed to each invoked method. If `methodName` is a function, it will
     * be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|String} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = nativeSlice.call(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function (value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the `collection`
     * through the `callback`. The `callback` is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (order is not guaranteed)
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(stooges, 'name');
     * // => ['moe', 'larry']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function (value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of an `array`. If `callback` is passed,
     * it will be executed for each value in the `array` to generate the
     * criterion by which the value is ranked. The `callback` is bound to
     * `thisArg` and invoked with three arguments; (value, index, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.max(stooges, function(stooge) { return stooge.age; });
     * // => { 'name': 'larry', 'age': 50 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(stooges, 'age');
     * // => { 'name': 'larry', 'age': 50 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      if (!callback && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);

        forEach(collection, function (value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of an `array`. If `callback` is passed,
     * it will be executed for each value in the `array` to generate the
     * criterion by which the value is ranked. The `callback` is bound to `thisArg`
     * and invoked with three arguments; (value, index, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.min(stooges, function(stooge) { return stooge.age; });
     * // => { 'name': 'moe', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(stooges, 'age');
     * // => { 'name': 'moe', 'age': 40 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      if (!callback && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);

        forEach(collection, function (value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the `collection`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {String} property The property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.pluck(stooges, 'name');
     * // => ['moe', 'larry']
     */
    function pluck(collection, property) {
      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = collection[index][property];
        }
      }
      return result || map(collection, property);
    }

    /**
     * Reduces a `collection` to a value which is the accumulated result of running
     * each element in the `collection` through the `callback`, where each successive
     * `callback` execution consumes the return value of the previous execution.
     * If `accumulator` is not passed, the first element of the `collection` will be
     * used as the initial `accumulator` value. The `callback` is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [accumulator] Initial value of the accumulator.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
        });
      }
      return accumulator;
    }

    /**
     * This method is similar to `_.reduce`, except that it iterates over a
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [accumulator] Initial value of the accumulator.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var iterable = collection,
          length = collection ? collection.length : 0,
          noaccum = arguments.length < 3;

      if (typeof length != 'number') {
        var props = keys(collection);
        length = props.length;
      }
      callback = lodash.createCallback(callback, thisArg, 4);
      forEach(collection, function (value, index, collection) {
        index = props ? props[--length] : --length;
        accumulator = noaccum ? (noaccum = false, iterable[index]) : callback(accumulator, iterable[index], index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter`, this method returns the elements of a
     * `collection` that `callback` does **not** return truthy for.
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that did **not** pass the
     *  callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(food, 'organic');
     * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
     *
     * // using "_.where" callback shorthand
     * _.reject(food, { 'type': 'fruit' });
     * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg);
      return filter(collection, function (value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Creates an array of shuffled `array` values, using a version of the
     * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function (value) {
        var rand = floor(nativeRandom() * (++index + 1));
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to inspect.
     * @returns {Number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('curly');
     * // => 5
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the `callback` returns a truthy value for **any** element of a
     * `collection`. The function returns as soon as it finds passing value, and
     * does not iterate over the entire `collection`. The `callback` is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Boolean} Returns `true` if any element passes the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(food, 'organic');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(food, { 'type': 'meat' });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (result = callback(collection[index], index, collection)) {
            break;
          }
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in the `collection` through the `callback`. This method
     * performs a stable sort, that is, it will preserve the original sort order of
     * equal elements. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * // using "_.pluck" callback shorthand
     * _.sortBy(['banana', 'strawberry', 'apple'], 'length');
     * // => ['apple', 'banana', 'strawberry']
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      callback = lodash.createCallback(callback, thisArg);
      forEach(collection, function (value, key, collection) {
        var object = result[++index] = getObject();
        object.criteria = callback(value, key, collection);
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Examines each element in a `collection`, returning an array of all elements
     * that have the given `properties`. When checking `properties`, this method
     * performs a deep comparison between values to determine if they are equivalent
     * to each other.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Object} properties The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given `properties`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.where(stooges, { 'age': 40 });
     * // => [{ 'name': 'moe', 'age': 40 }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values of `array` removed. The values
     * `false`, `null`, `0`, `""`, `undefined` and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new filtered array.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array of `array` elements not present in the other arrays
     * using strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {Array} [array1, array2, ...] Arrays to check.
     * @returns {Array} Returns a new array of `array` elements not present in the
     *  other arrays.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          seen = concat.apply(arrayRef, nativeSlice.call(arguments, 1)),
          result = [];

      var isLarge = length >= largeArraySize && indexOf === basicIndexOf;

      if (isLarge) {
        var cache = createCache(seen);
        if (cache) {
          indexOf = cacheIndexOf;
          seen = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(seen, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(seen);
      }
      return result;
    }

    /**
     * This method is similar to `_.find`, except that it returns the index of
     * the element that passes the callback check, instead of the element itself.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the index of the found element, else `-1`.
     * @example
     *
     * _.findIndex(['apple', 'banana', 'beet'], function(food) {
     *   return /^b/.test(food);
     * });
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Gets the first element of the `array`. If a number `n` is passed, the first
     * `n` elements of the `array` are returned. If a `callback` function is passed,
     * elements at the beginning of the array are returned as long as the `callback`
     * returns truthy. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var food = [
     *   { 'name': 'banana', 'organic': true },
     *   { 'name': 'beet',   'organic': false },
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(food, 'organic');
     * // => [{ 'name': 'banana', 'organic': true }]
     *
     * var food = [
     *   { 'name': 'apple',  'type': 'fruit' },
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.first(food, { 'type': 'fruit' });
     * // => [{ 'name': 'apple', 'type': 'fruit' }, { 'name': 'banana', 'type': 'fruit' }]
     */
    function first(array, callback, thisArg) {
      if (array) {
        var n = 0,
            length = array.length;

        if (typeof callback != 'number' && callback != null) {
          var index = -1;
          callback = lodash.createCallback(callback, thisArg);
          while (++index < length && callback(array[index], index, array)) {
            n++;
          }
        } else {
          n = callback;
          if (n == null || thisArg) {
            return array[0];
          }
        }
        return slice(array, 0, nativeMin(nativeMax(0, n), length));
      }
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truthy, `array` will only be flattened a single level. If `callback`
     * is passed, each element of `array` is passed through a `callback` before
     * flattening. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {Boolean} [isShallow=false] A flag to indicate only flattening a single level.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var stooges = [
     *   { 'name': 'curly', 'quotes': ['Oh, a wise guy, eh?', 'Poifect!'] },
     *   { 'name': 'moe', 'quotes': ['Spread out!', 'You knucklehead!'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(stooges, 'quotes');
     * // => ['Oh, a wise guy, eh?', 'Poifect!', 'Spread out!', 'You knucklehead!']
     */
    var flatten = overloadWrapper(function flatten(array, isShallow, callback) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (callback) {
          value = callback(value, index, array);
        }
        // recursively flatten arrays (susceptible to call stack limits)
        if (isArray(value)) {
          push.apply(result, isShallow ? value : flatten(value));
        } else {
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the `array` is already
     * sorted, passing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Mixed} value The value to search for.
     * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to
     *  perform a binary search on a sorted `array`.
     * @returns {Number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return array ? basicIndexOf(array, value, fromIndex) : -1;
    }

    /**
     * Gets all but the last element of `array`. If a number `n` is passed, the
     * last `n` elements are excluded from the result. If a `callback` function
     * is passed, elements at the end of the array are excluded from the result
     * as long as the `callback` returns truthy. The `callback` is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var food = [
     *   { 'name': 'beet',   'organic': false },
     *   { 'name': 'carrot', 'organic': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(food, 'organic');
     * // => [{ 'name': 'beet',   'organic': false }]
     *
     * var food = [
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' },
     *   { 'name': 'carrot', 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.initial(food, { 'type': 'vegetable' });
     * // => [{ 'name': 'banana', 'type': 'fruit' }]
     */
    function initial(array, callback, thisArg) {
      if (!array) {
        return [];
      }
      var n = 0,
          length = array.length;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback == null || thisArg ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Computes the intersection of all the passed-in arrays using strict equality
     * for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} [array1, array2, ...] Arrays to process.
     * @returns {Array} Returns a new array of unique elements that are present
     *  in **all** of the arrays.
     * @example
     *
     * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2]
     */
    function intersection(array) {
      var args = arguments,
          argsLength = args.length,
          argsIndex = -1,
          caches = getArray(),
          index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [],
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = args[argsIndex];
        caches[argsIndex] = indexOf === basicIndexOf && (value ? value.length : 0) >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen);
      }
      outer: while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element of the `array`. If a number `n` is passed, the
     * last `n` elements of the `array` are returned. If a `callback` function
     * is passed, elements at the end of the array are returned as long as the
     * `callback` returns truthy. The `callback` is bound to `thisArg` and
     * invoked with three arguments;(value, index, array).
     *
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var food = [
     *   { 'name': 'beet',   'organic': false },
     *   { 'name': 'carrot', 'organic': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.last(food, 'organic');
     * // => [{ 'name': 'carrot', 'organic': true }]
     *
     * var food = [
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' },
     *   { 'name': 'carrot', 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.last(food, { 'type': 'vegetable' });
     * // => [{ 'name': 'beet', 'type': 'vegetable' }, { 'name': 'carrot', 'type': 'vegetable' }]
     */
    function last(array, callback, thisArg) {
      if (array) {
        var n = 0,
            length = array.length;

        if (typeof callback != 'number' && callback != null) {
          var index = length;
          callback = lodash.createCallback(callback, thisArg);
          while (index-- && callback(array[index], index, array)) {
            n++;
          }
        } else {
          n = callback;
          if (n == null || thisArg) {
            return array[length - 1];
          }
        }
        return slice(array, nativeMax(0, length - n));
      }
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Mixed} value The value to search for.
     * @param {Number} [fromIndex=array.length-1] The index to search from.
     * @returns {Number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Number} [start=0] The start of the range.
     * @param {Number} end The end of the range.
     * @param {Number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(10);
     * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     *
     * _.range(1, 11);
     * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     *
     * _.range(0, 30, 5);
     * // => [0, 5, 10, 15, 20, 25]
     *
     * _.range(0, -10, -1);
     * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = +step || 1;

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so V8 will avoid the slower "dictionary" mode
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / step)),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The opposite of `_.initial`, this method gets all but the first value of
     * `array`. If a number `n` is passed, the first `n` values are excluded from
     * the result. If a `callback` function is passed, elements at the beginning
     * of the array are excluded from the result as long as the `callback` returns
     * truthy. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var food = [
     *   { 'name': 'banana', 'organic': true },
     *   { 'name': 'beet',   'organic': false },
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.rest(food, 'organic');
     * // => [{ 'name': 'beet', 'organic': false }]
     *
     * var food = [
     *   { 'name': 'apple',  'type': 'fruit' },
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.rest(food, { 'type': 'fruit' });
     * // => [{ 'name': 'beet', 'type': 'vegetable' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback == null || thisArg ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which the `value`
     * should be inserted into `array` in order to maintain the sort order of the
     * sorted `array`. If `callback` is passed, it will be executed for `value` and
     * each element in `array` to compute their sort ranking. The `callback` is
     * bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {Mixed} value The value to evaluate.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Number} Returns the index at which the value should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = low + high >>> 1;
        callback(array[mid]) < value ? low = mid + 1 : high = mid;
      }
      return low;
    }

    /**
     * Computes the union of the passed-in arrays using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} [array1, array2, ...] Arrays to process.
     * @returns {Array} Returns a new array of unique values, in order, that are
     *  present in one or more of the arrays.
     * @example
     *
     * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2, 3, 101, 10]
     */
    function union(array) {
      if (!isArray(array)) {
        arguments[0] = array ? nativeSlice.call(array) : arrayRef;
      }
      return uniq(concat.apply(arrayRef, arguments));
    }

    /**
     * Creates a duplicate-value-free version of the `array` using strict equality
     * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`
     * for `isSorted` will run a faster algorithm. If `callback` is passed, each
     * element of `array` is passed through the `callback` before uniqueness is computed.
     * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var uniq = overloadWrapper(function (array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === basicIndexOf,
          seen = callback || isLarge ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        if (cache) {
          indexOf = cacheIndexOf;
          seen = cache;
        } else {
          isLarge = false;
          seen = callback ? seen : (releaseArray(seen), result);
        }
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    });

    /**
     * The inverse of `_.zip`, this method splits groups of elements into arrays
     * composed of elements from each group at their corresponding indexes.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @returns {Array} Returns a new array of the composed arrays.
     * @example
     *
     * _.unzip([['moe', 30, true], ['larry', 40, false]]);
     * // => [['moe', 'larry'], [30, 40], [true, false]];
     */
    function unzip(array) {
      var index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an array with all occurrences of the passed values removed using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {Mixed} [value1, value2, ...] Values to remove.
     * @returns {Array} Returns a new filtered array.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return difference(array, nativeSlice.call(arguments, 1));
    }

    /**
     * Groups the elements of each array at their corresponding indexes. Useful for
     * separate data sources that are coordinated through matching array indexes.
     * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix
     * in a similar fashion.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} [array1, array2, ...] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['moe', 'larry'], [30, 40], [true, false]);
     * // => [['moe', 30, true], ['larry', 40, false]]
     */
    function zip(array) {
      return array ? unzip(arguments) : [];
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Pass either
     * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or
     * two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['moe', 'larry'], [30, 40]);
     * // => { 'moe': 30, 'larry': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * If `n` is greater than `0`, a function is created that is restricted to
     * executing `func`, with the `this` binding and arguments of the created
     * function, only after it is called `n` times. If `n` is less than `1`,
     * `func` is executed immediately, without a `this` binding or additional
     * arguments, and its result is returned.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Number} n The number of times the function must be called before
     * it is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var renderNotes = _.after(notes.length, render);
     * _.forEach(notes, function(note) {
     *   note.asyncSave({ 'success': renderNotes });
     * });
     * // `renderNotes` is run once, after all notes have saved
     */
    function after(n, func) {
      if (n < 1) {
        return func();
      }
      return function () {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * passed to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {Mixed} [thisArg] The `this` binding of `func`.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'moe' }, 'hi');
     * func();
     * // => 'hi moe'
     */
    function bind(func, thisArg) {
      // use `Function#bind` if it exists and is fast
      // (in V8 `Function#bind` is slower except when partially applied)
      return support.fastBind || nativeBind && arguments.length > 2 ? nativeBind.call.apply(nativeBind, arguments) : createBound(func, thisArg, nativeSlice.call(arguments, 2));
    }

    /**
     * Binds methods on `object` to `object`, overwriting the existing method.
     * Method names may be specified as individual arguments or as arrays of method
     * names. If no method names are provided, all the function properties of `object`
     * will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *  'label': 'docs',
     *  'onClick': function() { alert('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => alerts 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? concat.apply(arrayRef, nativeSlice.call(arguments, 1)) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = bind(object[key], object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those passed to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {String} key The key of the method.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'moe',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi moe'
     *
     * object.greet = function(greeting) {
     *   return greeting + ', ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hi, moe!'
     */
    function bindKey(object, key) {
      return createBound(object, key, nativeSlice.call(arguments, 2), indicatorObject);
    }

    /**
     * Creates a function that is the composition of the passed functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} [func1, func2, ...] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var greet = function(name) { return 'hi ' + name; };
     * var exclaim = function(statement) { return statement + '!'; };
     * var welcome = _.compose(exclaim, greet);
     * welcome('moe');
     * // => 'hi moe!'
     */
    function compose() {
      var funcs = arguments;
      return function () {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name, the created callback will return the property value for a given element.
     * If `func` is an object, the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * Note: All Lo-Dash methods, that accept a `callback` argument, use `_.createCallback`.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Mixed} [func=identity] The value to convert to a callback.
     * @param {Mixed} [thisArg] The `this` binding of the created callback.
     * @param {Number} [argCount=3] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(stooges, 'age__gt45');
     * // => [{ 'name': 'larry', 'age': 50 }]
     *
     * // create mixins with support for "_.pluck" and "_.where" callback shorthands
     * _.mixin({
     *   'toLookup': function(collection, callback, thisArg) {
     *     callback = _.createCallback(callback, thisArg);
     *     return _.reduce(collection, function(result, value, index, collection) {
     *       return (result[callback(value, index, collection)] = value, result);
     *     }, {});
     *   }
     * });
     *
     * _.toLookup(stooges, 'name');
     * // => { 'moe': { 'name': 'moe', 'age': 40 }, 'larry': { 'name': 'larry', 'age': 50 } }
     */
    function createCallback(func, thisArg, argCount) {
      if (func == null) {
        return identity;
      }
      var type = typeof func === 'undefined' ? 'undefined' : _typeof(func);
      if (type != 'function') {
        if (type != 'object') {
          return function (object) {
            return object[func];
          };
        }
        var props = keys(func);
        return function (object) {
          var length = props.length,
              result = false;
          while (length--) {
            if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
              break;
            }
          }
          return result;
        };
      }
      if (typeof thisArg == 'undefined' || reThis && !reThis.test(fnToString.call(func))) {
        return func;
      }
      if (argCount === 1) {
        return function (value) {
          return func.call(thisArg, value);
        };
      }
      if (argCount === 2) {
        return function (a, b) {
          return func.call(thisArg, a, b);
        };
      }
      if (argCount === 4) {
        return function (accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return function (value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked. Pass
     * an `options` object to indicate that `func` should be invoked on the leading
     * and/or trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true`, `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {Number} wait The number of milliseconds to delay.
     * @param {Object} options The options object.
     *  [leading=false] A boolean to specify execution on the leading edge of the timeout.
     *  [maxWait] The maximum time `func` is allowed to be delayed before it's called.
     *  [trailing=true] A boolean to specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * var lazyLayout = _.debounce(calculateLayout, 300);
     * jQuery(window).on('resize', lazyLayout);
     *
     * jQuery('#postbox').on('click', _.debounce(sendMail, 200, {
     *   'leading': true,
     *   'trailing': false
     * });
     */
    function debounce(func, wait, options) {
      var args,
          result,
          thisArg,
          callCount = 0,
          lastCalled = 0,
          maxWait = false,
          maxTimeoutId = null,
          timeoutId = null,
          trailing = true;

      function clear() {
        clearTimeout(maxTimeoutId);
        clearTimeout(timeoutId);
        callCount = 0;
        maxTimeoutId = timeoutId = null;
      }

      function delayed() {
        var isCalled = trailing && (!leading || callCount > 1);
        clear();
        if (isCalled) {
          if (maxWait !== false) {
            lastCalled = new Date();
          }
          result = func.apply(thisArg, args);
        }
      }

      function maxDelayed() {
        clear();
        if (trailing || maxWait !== wait) {
          lastCalled = new Date();
          result = func.apply(thisArg, args);
        }
      }

      wait = nativeMax(0, wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(wait, options.maxWait || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      return function () {
        args = arguments;
        thisArg = this;
        callCount++;

        // avoid issues with Titanium and `undefined` timeout ids
        // https://github.com/appcelerator/titanium_mobile/blob/3_1_0_GA/android/titanium/src/java/ti/modules/titanium/TitaniumModule.java#L185-L192
        clearTimeout(timeoutId);

        if (maxWait === false) {
          if (leading && callCount < 2) {
            result = func.apply(thisArg, args);
          }
        } else {
          var now = new Date();
          if (!maxTimeoutId && !leading) {
            lastCalled = now;
          }
          var remaining = maxWait - (now - lastCalled);
          if (remaining <= 0) {
            clearTimeout(maxTimeoutId);
            maxTimeoutId = null;
            lastCalled = now;
            result = func.apply(thisArg, args);
          } else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be passed to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
     * @returns {Number} Returns the timer id.
     * @example
     *
     * _.defer(function() { alert('deferred'); });
     * // returns from the function before `alert` is called
     */
    function defer(func) {
      var args = nativeSlice.call(arguments, 1);
      return setTimeout(function () {
        func.apply(undefined, args);
      }, 1);
    }
    // use `setImmediate` if it's available in Node.js
    if (isV8 && freeModule && typeof setImmediate == 'function') {
      defer = bind(setImmediate, context);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be passed to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {Number} wait The number of milliseconds to delay execution.
     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
     * @returns {Number} Returns the timer id.
     * @example
     *
     * var log = _.bind(console.log, console);
     * _.delay(log, 1000, 'logged later');
     * // => 'logged later' (Appears after one second.)
     */
    function delay(func, wait) {
      var args = nativeSlice.call(arguments, 2);
      return setTimeout(function () {
        func.apply(undefined, args);
      }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * passed, it will be used to determine the cache key for storing the result
     * based on the arguments passed to the memoized function. By default, the first
     * argument passed to the memoized function is used as the cache key. The `func`
     * is executed with the `this` binding of the memoized function. The result
     * cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     */
    function memoize(func, resolver) {
      function memoized() {
        var cache = memoized.cache,
            key = keyPrefix + (resolver ? resolver.apply(this, arguments) : arguments[0]);

        return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran, result;

      return function () {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those passed to the new function. This
     * method is similar to `_.bind`, except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('moe');
     * // => 'hi moe'
     */
    function partial(func) {
      return createBound(func, nativeSlice.call(arguments, 1));
    }

    /**
     * This method is similar to `_.partial`, except that `partial` arguments are
     * appended to those passed to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createBound(func, nativeSlice.call(arguments, 1), null, indicatorObject);
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Pass an `options` object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true`, `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {Number} wait The number of milliseconds to throttle executions to.
     * @param {Object} options The options object.
     *  [leading=true] A boolean to specify execution on the leading edge of the timeout.
     *  [trailing=true] A boolean to specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      options = getObject();
      options.leading = leading;
      options.maxWait = wait;
      options.trailing = trailing;

      var result = debounce(func, wait, options);
      releaseObject(options);
      return result;
    }

    /**
     * Creates a function that passes `value` to the `wrapper` function as its
     * first argument. Additional arguments passed to the function are appended
     * to those passed to the `wrapper` function. The `wrapper` is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Mixed} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var hello = function(name) { return 'hello ' + name; };
     * hello = _.wrap(hello, function(func) {
     *   return 'before, ' + func('moe') + ', after';
     * });
     * hello();
     * // => 'before, hello moe, after'
     */
    function wrap(value, wrapper) {
      return function () {
        var args = [value];
        push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} string The string to escape.
     * @returns {String} Returns the escaped string.
     * @example
     *
     * _.escape('Moe, Larry & Curly');
     * // => 'Moe, Larry &amp; Curly'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument passed to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Mixed} value Any value.
     * @returns {Mixed} Returns `value`.
     * @example
     *
     * var moe = { 'name': 'moe' };
     * moe === _.identity(moe);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds functions properties of `object` to the `lodash` function and chainable
     * wrapper.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object of function properties to add to `lodash`.
     * @example
     *
     * _.mixin({
     *   'capitalize': function(string) {
     *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     *   }
     * });
     *
     * _.capitalize('moe');
     * // => 'Moe'
     *
     * _('moe').capitalize();
     * // => 'Moe'
     */
    function mixin(object) {
      forEach(functions(object), function (methodName) {
        var func = lodash[methodName] = object[methodName];

        lodash.prototype[methodName] = function () {
          var value = this.__wrapped__,
              args = [value];

          push.apply(args, arguments);
          var result = func.apply(lodash, args);
          return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && value === result ? this : new lodashWrapper(result);
        };
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * Converts the given `value` into an integer of the specified `radix`.
     * If `radix` is `undefined` or `0`, a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.com/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} value The value to parse.
     * @param {Number} [radix] The radix used to interpret the value to parse.
     * @returns {Number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
      // Firefox and Opera still follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is passed, a number between `0` and the given number will be returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Number} [min=0] The minimum possible value.
     * @param {Number} [max=1] The maximum possible value.
     * @returns {Number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => a number between 0 and 5
     *
     * _.random(5);
     * // => also a number between 0 and 5
     */
    function random(min, max) {
      if (min == null && max == null) {
        max = 1;
      }
      min = +min || 0;
      if (max == null) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      var rand = nativeRandom();
      return min % 1 || max % 1 ? min + nativeMin(rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max) : min + floor(rand * (max - min + 1));
    }

    /**
     * Resolves the value of `property` on `object`. If `property` is a function,
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey, then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {String} property The property to get the value of.
     * @returns {Mixed} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, property) {
      var value = object ? object[property] : undefined;
      return isFunction(value) ? object[property]() : value;
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/#custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} options The options object.
     *  escape - The "escape" delimiter regexp.
     *  evaluate - The "evaluate" delimiter regexp.
     *  interpolate - The "interpolate" delimiter regexp.
     *  sourceURL - The sourceURL of the template's compiled source.
     *  variable - The data object variable name.
     * @returns {Function|String} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'moe' });
     * // => 'hello moe'
     *
     * var list = '<% _.forEach(people, function(name) { %><li><%= name %></li><% }); %>';
     * _.template(list, { 'people': ['moe', 'larry'] });
     * // => '<li>moe</li><li>larry</li>'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'curly' });
     * // => 'hello curly'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + epithet); %>!', { 'epithet': 'stooge' });
     * // => 'hello stooge!'
     *
     * // using custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text || (text = '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');

      text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';

      // Use a sourceURL for easier debugging and wrap in a multi-line comment to
      // avoid issues with Narwhal, IE conditional compilation, and the JS engine
      // embedded in Adobe products.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch (e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source via its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the `callback` function `n` times, returning an array of the results
     * of each `callback` execution. The `callback` is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = lodash.createCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape`, this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} string The string to unescape.
     * @returns {String} Returns the unescaped string.
     * @example
     *
     * _.unescape('Moe, Larry &amp; Curly');
     * // => 'Moe, Larry & Curly'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is passed, the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} [prefix] The value to prefix the ID with.
     * @returns {String} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Invokes `interceptor` with the `value` as the first argument, and then
     * returns `value`. The purpose of this method is to "tap into" a method chain,
     * in order to perform operations on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {Mixed} value The value to pass to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {Mixed} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .filter(function(num) { return num % 2 == 0; })
     *  .tap(alert)
     *  .map(function(num) { return num * num; })
     *  .value();
     * // => // [2, 4] (alerted)
     * // => [4, 16]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {String} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {Mixed} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.countBy = countBy;
    lodash.createCallback = createCallback;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forIn = forIn;
    lodash.forOwn = forOwn;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.range = range;
    lodash.reject = reject;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // add functions to `lodash.prototype`
    mixin(lodash);

    // add Underscore compat
    lodash.chain = lodash;
    lodash.prototype.chain = function () {
      return this;
    };

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    forOwn(lodash, function (func, methodName) {
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName] = function () {
          var args = [this.__wrapped__];
          push.apply(args, arguments);
          return func.apply(lodash, args);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function (func, methodName) {
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName] = function (callback, thisArg) {
          var result = func(this.__wrapped__, callback, thisArg);
          return callback == null || thisArg && typeof callback != 'function' ? result : new lodashWrapper(result);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type String
     */
    lodash.VERSION = '1.3.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function (methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function () {
        return func.apply(this.__wrapped__, arguments);
      };
    });

    // add `Array` functions that return the wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function (methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function () {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function (methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function () {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments));
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  if ("function" == 'function' && _typeof(__webpack_require__(18)) == 'object' && __webpack_require__(18)) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash was injected by a third-party script and not intended to be
    // loaded as a module. The global assignment can be reverted in the Lo-Dash
    // module via its `noConflict()` method.
    window._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return _;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && !freeExports.nodeType) {
      // in Node.js or RingoJS v0.8.0+
      if (freeModule) {
        (freeModule.exports = _)._ = _;
      }
      // in Narwhal or RingoJS v0.7.0-
      else {
          freeExports._ = _;
        }
    } else {
      // in a browser or Rhino
      window._ = _;
    }
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module), __webpack_require__(40)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(41), __webpack_require__(19), __webpack_require__(20), __webpack_require__(12), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, dummy_jquery_cookie, Blob, FileSaver, Test, Msg) {

    /**
     * Module encapsulating a number of utility functions
     * @type {{Test: *}}
     */
    var Module = {
        Test: Test
    };

    /**
     * Returns a generic Axiom object
     * @param {string} typeStr - object type id
     * @returns {{}}
     */
    Module.object = function (typeStr) {
        var obj = {
            __typeStrings: [typeStr]
        };

        obj.extend = function (typeStr) {
            obj.__typeStrings.push(typeStr);
        };

        return obj;
    };

    Module.isObjectType = function (obj, typeStr) {
        if (!obj) return false;
        if (!obj.__typeStrings) return false;
        if (obj.__typeStrings.indexOf(typeStr) < 0) return false;
        return true;
    };

    /**
     * Determines if a value is an array
     * @param v
     * @returns {boolean}
     */
    Module.isArray = function (v) {
        return v && v.constructor && v.constructor == Array;
    };

    /**
     * Determines if a value is a string
     * @param v
     * @returns {boolean}
     */
    Module.isString = function (v) {
        return typeof v == 'string';
    };

    /**
     * Determines if a value is a boolean
     * @param v
     * @returns {boolean}
     */
    Module.isBoolean = function (v) {
        return typeof v == 'boolean';
    };

    /**
     * Determines if a value is a number
     * @param v
     * @returns {boolean}
     */
    Module.isNumber = function (v) {
        return typeof v == 'number';
    };

    /**
     * Determines if a value is a function
     * @param v
     * @returns {boolean}
     */
    Module.isFunction = function (v) {
        return typeof v == 'function';
    };

    /**
     * Determines if an object has a property with given name
     * @param {{}} obj - object
     * @param {string} property - property name
     */
    Module.objectHasProperty = function (obj, property) {
        return typeof obj[property] != 'undefined';
    };

    /**
     * Determines if a string contains ASCII text only
     * @param v
     * @returns {boolean}
     */
    Module.isASCIIText = function (v) {
        if (!Module.isString(v)) return false;
        for (var i = 0; i < v.length; i++) {
            if (v.charCodeAt(i) > 127) return false;
        }return true;
    };

    /**
     * Determines if a string contains ASCII text only, and no spaces or tabs
     * @param v
     * @returns {boolean}
     */
    Module.isValidLoginName = function (v) {
        if (!Module.isString(v)) return false;
        var ascii = /^[!-~]+$/;
        return ascii.test(v);
    };

    /**
     * Calculates the logarithm with base 10
     * @param {float} v - argument
     * @returns {number} - result
     */
    Module.log10 = function (v) {
        return Math.log(v) / Math.log(10);
    };

    /**
     * Returns the query parameters for the url provided to run this app
     * @returns {{}} - paramaters key-value pairs
     */
    Module.getUrlParameters = function () {
        var urlParams;
        var match,
            pl = /\+/g,
            // Regex for replacing addition symbol with a space
        search = /([^&=]+)=?([^&]*)/g,
            decode = function decode(s) {
            return decodeURIComponent(s.replace(pl, " "));
        },
            query = decodeURIComponent(window.location.search.substring(1));

        urlParams = {};
        while (match = search.exec(query)) {
            urlParams[decode(match[1])] = decode(match[2]);
        }return urlParams;
    };

    /**
     * Returns a value range object
     * @param {number} minValue - minimum value
     * @param {number}maxValue - maximum value
     * @returns {{}} - value range object
     */
    Module.valueRange = function (minValue, maxValue) {
        var range = Module.object('@ValueRange');
        range._minValue = minValue;
        range._maxValue = maxValue;
        range.getMin = function () {
            return range._minValue;
        };
        range.getMax = function () {
            return range._maxValue;
        };
        range.extendFraction = function (fr) {
            var ext = (range._maxValue - range._minValue) * fr / 2;
            if (ext == 0) ext = range._minValue * fr / 2;
            range._minValue -= ext;
            range._maxValue += ext;
        };
        return range;
    };

    /**
     * Sort helper
     * @param {string} prop
     * @returns {Function}
     * @constructor
     */
    Module.ByProperty = function (prop) {
        return function (a, b) {
            if (typeof a[prop] == "number") {
                return a[prop] - b[prop];
            } else {
                return a[prop] < b[prop] ? -1 : a[prop] > b[prop] ? 1 : 0;
            }
        };
    };

    /**
     * Sort helper
     * @param {string} prop
     * @returns {Function}
     * @constructor
     */
    Module.ByPropertyReverse = function (prop) {
        return function (b, a) {
            if (typeof a[prop] == "number") {
                return a[prop] - b[prop];
            } else {
                return a[prop] < b[prop] ? -1 : a[prop] > b[prop] ? 1 : 0;
            }
        };
    };

    /**
     * Augments the string class with a function that interpolates tokens of the style {token}
     * @param {{}} args - key-value pairs with interpolation tokens
     * @returns {String} - interpolated string
     * @constructor
     */
    String.prototype.AXMInterpolate = function (args) {
        var newStr = this;
        for (var key in args) {
            var regex = new RegExp('{' + key + '}', 'g');
            newStr = newStr.replace(regex, args[key]); //keep replacing until all instances of the keys are replaced
        }
        return newStr;
    };

    /**
     * Limits a string to a certain number of characters, using html ellipsis
     * @param {string} str - input string
     * @param {int} len - maxmimum number of characters
     * @returns {string} - limited string
     */
    Module.limitStringHtml = function (str, len) {
        if (str.length > len) return str.substring(0, Math.max(1, len - 4)) + '&hellip;';else return str;
    };

    /**
     * Logs a line to the browser console
     * @param {string} line
     */
    Module.log = function (line) {
        //if (!console || !console.log)
        //    return;
        //console.log(line);
    };

    /**
     * Returns a throttled function that wraps around the argument function, making sure it is called not more often than delay specifies
     * @param {function} fn - argument function to be throttled
     * @param {int} delay - minimum delay (ms)
     * @returns {Function} - throttled function
     */
    Module.debounce = function (fn, delay) {
        var timer = null;
        return function () {
            var context = this,
                args = arguments;
            clearTimeout(timer);
            timer = setTimeout(function () {
                fn.apply(context, args);
            }, delay);
        };
    };

    /**
     * Returns a throttled function that wraps around the argument function, making sure it is called not more often than delay specifies
     * @param {function} fn - argument function to be throttled
     * @param {int} delay - minimum delay (ms)
     * @returns {Function} - throttled function
     */
    Module.debounce2 = function (fn, delay) {
        var timer = null;
        return function () {
            var context = this,
                args = arguments;
            if (!timer) {
                timer = setTimeout(function () {
                    timer = null;
                    fn.apply(context, args);
                }, delay);
            }
        };
    };

    Module._uniqueID = 0;

    /**
     * Returns a session-wide unique string
     * @returns {string}
     */
    Module.getUniqueID = function () {
        Module._uniqueID++;
        return 'ID' + Module._uniqueID;
    };

    Module._zindex = 0;

    /**
     * Returns an ever increasing number, used to keep track of stacking of z-indexes
     * @returns {number}
     */
    Module.getNextZIndex = function () {
        Module._zindex += 100;
        return Module._zindex;
    };

    Module.getCurrentZIndex = function () {
        return Module._zindex;
    };

    /**
     * Reports a bug
     * @param msg
     */
    Module.reportBug = function (msg) {
        //throw(msg);
        //alert(msg);
        //debugger;
    };

    /**
     * Returns the size of the browser client area
     * @returns {{sizeX: number, sizeY: number}}
     */
    Module.getBrowserSize = function () {
        return {
            sizeX: $(window).width(),
            sizeY: $(window).height()
        };
    };

    /**
     * Creates a drag handler for a jquery element
     * @param {jQuery} $El - jQuery element
     * @param {function} handlerStart - called when dragging starts
     * @param {function} handlerMove - called when dragging moves
     * @param {function} handlerStop - called when dragging stops
     */
    Module.create$ElDragHandler = function ($El, handlerStart, handlerMove, handlerStop) {

        var handlerId = 'DGH' + Module.getUniqueID();

        var positStartX = null;
        var positStartY = null;

        var handleMouseDown = function handleMouseDown(ev) {
            Module.closeTransientPopups();
            positStartX = ev.pageX;
            positStartY = ev.pageY;
            $(document).bind("mouseup." + handlerId, handleMouseUp);
            $(document).bind("mousemove." + handlerId, handleMouseMove);
            handlerStart({
                event: ev,
                shiftPressed: ev.shiftKey,
                controlPressed: ev.ctrlKey,
                altPressed: ev.altKey
            });
            ev.stopPropagation();
            return false;
        };

        var handleMouseUp = function handleMouseUp(ev) {
            $(document).unbind("mouseup." + handlerId);
            $(document).unbind("mousemove." + handlerId);
            handlerStop({});
            ev.stopPropagation();
            return false;
        };

        var handleMouseMove = function handleMouseMove(ev) {
            var positX = ev.pageX;
            var positY = ev.pageY;
            handlerMove({
                event: ev,
                diffTotalX: positX - positStartX,
                diffTotalY: positY - positStartY
            });
            ev.stopPropagation();
            return false;
        };

        $El.mousedown(handleMouseDown);
    };

    Module.remove$ElDragHandler = function ($El) {
        $El.unbind('mousedown');
    };

    /**
     * Creates a mouse scroll handler for a jQuery element
     * @param {jQuery} $El - jQuery element
     * @param {function} handler - called when scrolling happens
     */
    Module.create$ElScrollHandler = function ($El, handler, preventDefault) {

        var getMouseWheelDeltaY = function getMouseWheelDeltaY(ev) {
            var delta = 0;
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            if (ev1.wheelDeltaX !== undefined && ev1.wheelDelta) {
                // check that we are scrolling vertically
                if (Math.abs(ev1.wheelDeltaX) >= Math.abs(ev1.wheelDelta)) return 0;
            }
            if (ev1.wheelDelta) {
                delta = ev1.wheelDelta / 120;
            } else if (ev1.detail) {
                delta = -ev1.detail / 3;
            } else if (ev.deltaY) {
                delta = ev.deltaY;
                if (ev.deltaFactor) delta = delta * ev.deltaFactor / 16;
            }
            return delta;
        };

        var getMouseWheelDeltaX = function getMouseWheelDeltaX(ev) {
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            if (ev1.wheelDeltaX !== undefined && ev1.wheelDelta) {
                // check that we are scrolling horizontally
                if (Math.abs(ev1.wheelDeltaX) >= Math.abs(ev1.wheelDelta)) return ev1.wheelDeltaX / 120;
            }
            return 0;
        };

        $El.bind('DOMMouseScroll mousewheel', function (ev) {
            Module.closeTransientPopups();
            handler({
                deltaY: getMouseWheelDeltaY(ev),
                deltaX: getMouseWheelDeltaX(ev),
                controlPressed: ev.ctrlKey,
                altPressed: ev.altKey,
                event: ev
            });
            if (preventDefault) {
                ev.preventDefault();
                return false;
            }
        });
    };

    Module.remove$ElScrollHandler = function ($El) {
        $El.unbind('DOMMouseScroll mousewheel');
    };

    var _keyDownHandlerStack = [];
    var _keyDownHandlersHover = {};

    Module.addKeyDownHandler = function (handler) {
        _keyDownHandlerStack.unshift(handler);
    };

    Module.removeKeyDownHandler = function (handler) {
        var fndIdx = null;
        $.each(_keyDownHandlerStack, function (idx, hnd) {
            if (hnd === handler) fndIdx = idx;
        });
        if (fndIdx !== null) _keyDownHandlerStack.splice(fndIdx, 1);
    };

    var _onKeyDown = function _onKeyDown(ev) {
        if (ev.keyCode == 27) ev.isEscape = true;
        if (ev.keyCode == 13) ev.isEnter = true;
        if (_keyDownHandlerStack.length > 0) {
            _keyDownHandlerStack[0](ev);
            return;
        }
        //for (var id in _keyDownHandlersHover)
        //    if (DQX._keyDownHandlersHover[id])
        //        if (DQX._keyDownHandlersHover[id](ev)) {
        //            return false;
        //        }
    };

    $(document).keydown(_onKeyDown);

    /**
     * Creates a class helping the scheduling of functions that execute asynchronously
     * @returns {{}} - class instance
     * @constructor
     */
    Module.Scheduler = function () {
        var sched = {};

        sched.scheduledFunctions = [];
        sched.completedTokens = {};

        /**
         * Add a scheduled function. The execution will only start if all required tokens are marked as completed
         * @param requiredTokens
         * @param func
         */
        sched.add = function (requiredTokens, func) {
            sched.scheduledFunctions.push({
                requiredList: requiredTokens,
                func: func
            });
        };

        /**
         * Call this function to mark a token as being completed
         * @param token
         */
        sched.setCompleted = function (token) {
            sched.completedTokens[token] = true;
        };

        sched._tryNext = function () {
            var nextAction = null;
            var completed = true;
            $.each(sched.scheduledFunctions, function (idx, item) {
                if (!item.started) {
                    completed = false;
                    var canExecute = true;
                    $.each(item.requiredList, function (idx2, requiredToken) {
                        if (!sched.completedTokens[requiredToken]) canExecute = false;
                    });
                    if (canExecute) nextAction = item;
                }
            });

            if (nextAction) {
                nextAction.started = true;
                nextAction.func();
            }
            if (!completed) setTimeout(sched._tryNext, 50);
        };

        /**
         * Start the execution of the scheduled functions
         */
        sched.execute = function () {
            sched._tryNext();
        };

        return sched;
    };

    /**
     * Returns a class helping with persistent association of elements in a variable context
     * @param itemCount
     * @returns {{}}
     * @constructor
     */
    Module.PersistentAssociator = function (itemCount) {
        var assoc = {};
        assoc.itemCount = itemCount;
        assoc.associations = {};

        assoc.map = function (idlist) {
            var freeItemMap = {};
            var i;
            for (i = 0; i < assoc.itemCount; i++) {
                freeItemMap[i] = 1;
            }$.each(idlist, function (idx, id) {
                if (idx < assoc.itemCount) {
                    if (id in assoc.associations) delete freeItemMap[id];
                }
            });
            var freeItems = [];
            for (i = 0; i < assoc.itemCount; i++) {
                if (freeItemMap[i] == 1) freeItems.push(i);
            }
            var freenr = 0;

            var usedItemMap = {};
            $.each(idlist, function (idx, id) {
                if (idx < assoc.itemCount) {
                    var missing = false;
                    if (!(id in assoc.associations)) missing = true;else {
                        if (assoc.associations[id] in usedItemMap) missing = true;
                    }
                    if (missing) {
                        assoc.associations[id] = freeItems[freenr];
                        freenr++;
                    }
                    usedItemMap[assoc.associations[id]] = 1;
                }
            });

            assoc.mapped = true;
        };

        assoc.getAssociations = function () {
            return assoc.associations;
        };

        assoc.get = function (id) {
            if (!(id in assoc.associations)) return -1;else return assoc.associations[id];
        };

        return assoc;
    };

    Module._textInterpolators = {};

    /**
     * Defines the set of text interpolators tokens used for the _TRL function
     * @param dct
     */
    Module.setTextInterpolators = function (dct) {
        Module._textInterpolators = dct;
    };

    /**
     * Adds a new text interpolator token
     * @param key
     * @param value
     */
    Module.addTextInterpolator = function (key, value) {
        Module._textInterpolators[key] = value;
    };

    Module._useTextDecoration = function () {
        if (typeof __AXMTextDecoration === "undefined") return false;
        return __AXMTextDecoration;
    };

    /**
     * Converts the first character of a string to a capital
     * @param {string} str - input string
     * @returns {string} - result string
     */
    Module.makeStartCapital = function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    };

    /**
     * Interpolates a text string by replacing {_xxx_} tokens with snippets taken from Module._textInterpolators
     * For future use: translates the string using a translation table
     * @param {string} txt - Text to be translated and interpolated
     * @returns {string} - Result text
     * @private
     * @global
     */
    /*global _TRL*/
    _TRL = function _TRL(txt) {
        var reg = new RegExp(/{_.*?_}/g);
        var tokens = [];
        var match;
        while (match = reg.exec(txt)) {
            tokens.push(match[0]);
        }$.each(tokens, function (idx, token) {
            if (token.length < 5) {
                //Module.Test.reportBug('Invalid token: '+token);
            }
            var tokenString = token.substring(2, token.length - 2);
            var isCapital = tokenString[0] != tokenString[0].toLowerCase();
            tokenString = tokenString.toLowerCase();
            var replacement = Module._textInterpolators[tokenString];
            if (!replacement) {
                //Module.Test.reportBug('Invalid token: '+token);
                replacement = tokenString;
            }
            if (isCapital) replacement = replacement.charAt(0).toUpperCase() + replacement.slice(1);
            //if (Module._useTextDecoration())
            //    replacement = '|' + replacement + '|';
            txt = txt.replace(token, replacement);
        });
        if (Module._useTextDecoration()) txt = '‘' + txt + "’";
        return txt;
    };

    /**
     * Saves content to a local file on the client's computer
     * @param {string} data - file content
     * @param {string} fileName - file name
     */
    Module.saveTextFile = function (data, fileName) {
        var blob = new Blob([data], { type: "text/plain;charset=utf-8" });
        FileSaver(blob, fileName);
    };

    /**
     * (To be overwritten) Determines if the user has universal privileges
     * @returns {boolean}
     */
    Module.isSuperUser = function () {
        return false;
    };

    Module.loadLocalFile = function (onProceed) {

        var input = document.createElement('input');
        input.setAttribute('type', 'file');
        input.style.display = 'none';
        input.onchange = function (e) {
            if (input.files.length > 0) {
                var file = input.files[0];

                var reader = new FileReader();

                reader.onload = function (event) {
                    var textFile = event.target;
                    var txt = textFile.result;
                    onProceed(file.name, txt);
                    //Module.loadFromText(file.name, txt, true);
                };
                reader.readAsText(file);
            }
        };
        input.focus();
        input.click();
    };

    Module.animateBoxTransition = function (elementFrom, elementTo, settings, onStarted, onCompleted) {
        var transId = '_transientAnim_' + Module.getUniqueID();
        var px0 = elementFrom.offset().left;
        var py0 = elementFrom.offset().top;
        var lx0 = elementFrom.outerWidth();
        var ly0 = elementFrom.outerHeight();

        var px1 = elementTo.offset().left;
        var py1 = elementTo.offset().top;
        var lx1 = elementTo.outerWidth();
        var ly1 = elementTo.outerHeight();

        //var thebox = DOM.Div({ id: transId });
        //thebox.addStyle("position", "absolute");
        //thebox.addStyle("left", px0 + 'px');
        //thebox.addStyle("top", py0 + 'px');
        //thebox.addStyle("width", lx0 + 'px');
        //thebox.addStyle("height", ly0 + 'px');
        //thebox.addStyle('border', '4px solid black');
        //thebox.addStyle('z-index', Module.getNextZIndex());

        var theBox = '<div id="{id}" style="position:absolute;opacity:0.3;left:{left};top:{top};width:{width};height:{height};border:{border};z-index:{zindex}"></div>'.AXMInterpolate({
            id: transId,
            left: px0 + 'px',
            top: py0 + 'px',
            width: lx0 + 'px',
            height: ly0 + 'px',
            border: '4px solid black',
            zindex: Module.getNextZIndex()
        });

        $('.AXMContainer').append(theBox);

        var animationSpeed = 300;
        if (settings && settings.slow) animationSpeed = 500;

        if (onStarted) onStarted();
        $('#' + transId).animate({ left: px1 + 'px', top: py1 + 'px', width: lx1 + 'px', height: ly1 + 'px' }, animationSpeed, function () {
            $('#' + transId).remove();
            if (onCompleted) onCompleted();
        });
    };

    /**
     * Call this function to close all temporary popups
     */
    Module.closeTransientPopups = function () {
        Msg.broadcast("CloseTransientPopups");
    };

    /**
     * Call this function to close all temporary popups that are not toolboxes
     */
    Module.closeRegularTransientPopups = function () {
        Msg.broadcast("CloseRegularTransientPopups");
    };

    /**
     * Requires an object to be present, and returns it
     * @param obj
     * @returns {*}
     */
    AXMReq = function AXMReq(obj) {
        if (obj === undefined) Test.reportBug("Requered object not present");
        return obj;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(44), __webpack_require__(46), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(14), __webpack_require__(8), __webpack_require__(22), __webpack_require__(27), __webpack_require__(47)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, datetimepicker, awesomplete, _, AXMUtils, DOM, Icon, Color, Compound, CodeMirror) {

    /**
     * Module encapsulating a set of classes that represent HTML controls
     * @type {{}}
     */
    var Module = {
        Compound: Compound
    };

    /**
     * Base class for a single control
     * @returns {Object}
     * @constructor
     */
    Module.SingleControlBase = function () {
        var control = AXMUtils.object('@Control');
        control._id = 'CT' + AXMUtils.getUniqueID();
        control._hasDefaultFocus = false;
        control._notificationHandlers = [];

        /**
         * Returns the element ID of a subcomponent
         * @param {string} extension - subcomponent id
         * @returns {string}
         * @private
         */
        control._getSubId = function (extension) {
            return control._id + extension;
        };

        /**
         * Returns a jQuery element of a subcomponent
         * @param {string} extension - subcomponent id
         * @returns {jQuer-HTMLElement}
         * @private
         */
        control._getSub$El = function (extension) {
            return $('#' + control._getSubId(extension));
        };

        /**
         * Adds a handler function that is called when the status of the control changes
         * @param {function} handlerFunc - callback
         * @returns {Object} - self
         */
        control.addNotificationHandler = function (handlerFunc) {
            if (!handlerFunc) debugger;
            control._notificationHandlers.push(handlerFunc);
            return control;
        };

        /**
         * Call this function to assign default focus to the control upon initialisation
         * @returns {Object} - self
         */
        control.setHasDefaultFocus = function () {
            control._hasDefaultFocus = true;
            return control;
        };

        /**
         * Empty base class function
         */
        control.attachEventHandlers = function () {};

        /**
         * Empty base class function
         */
        control.detachEventHandlers = function () {};

        /**
         * Notifies all notification handlers
         * @param {{}} msg - (optional) notification message
         */
        control.performNotify = function (msg) {
            $.each(control._notificationHandlers, function (idx, fnc) {
                if (fnc) fnc(msg);
            });
        };

        /**
         * Called by the framework when a control needs to be teared down. To be implemented in derived classes
         */
        control.tearDown = function () {};

        return control;
    };

    /**
     * Implements a static text control
     * @param {{}} settings - control settings
     * @param {string} settings.text - control text
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Static = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._text = settings.text || '';
        control._cssClass = settings.cssClass || '';
        control._reactOnClick = settings.reactOnClick || false;
        control._inLine = true;
        control._title = settings.title || '';
        if (settings.fullWidth) control._inLine = false;

        control.setCssClass = function (cssClass) {
            control._cssClass = cssClass;
            return control;
        };

        control.setReactOnClick = function () {
            control._reactOnClick = true;
            return control;
        };

        /**
         * Creates the html of the control
         * @returns {String}
         */
        control.createHtml = function () {
            var div = DOM.Div({ id: control._getSubId('') });
            if (control._title) div.addAttribute('title', control._title);
            if (control._inLine) div.addStyle('display', 'inline-block').addStyle('vertical-align', 'middle');
            if (settings.maxWidth) div.addStyle('max-width', settings.maxWidth + 'px').addStyle('overflow-x', 'hidden').addStyle('text-overflow', 'ellipsis');
            if (control._cssClass) div.addCssClass(control._cssClass);
            div.addElem(control._text);
            return div.toString();
        };

        /**
         * Returns the jQuery element containing the control
         * @returns {jQuery}
         */
        control.get$El = function () {
            return $("#" + control._getSubId(''));
        };

        /**
         * Modifies the text of the control
         * @param {string} newText - new text content
         */
        control.modifyText = function (newText) {
            control._text = newText;
            $('#' + control._id).html(newText);
        };

        /**
         * Modifies the css Class of the control
         * @param {string} newClass - new css class
         */
        control.modifyCssClass = function (newClass) {
            control._getSub$El('').removeClass(control._cssClass);
            control.setCssClass(newClass);
            control._getSub$El('').addClass(newClass);
        };

        /**
         * Modifies the tooltip of the control
         * @param {string} newText - new tooltip content
         */
        control.modifyTooltip = function (newText) {
            control._title = newText;
            control.get$El().prop('title', newText);
        };

        /**
         * Attaches html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            if (control._reactOnClick) control._getSub$El('').click(control._onClicked);
        };

        /**
         * Detaches html event handlers
         */
        control.detachEventHandlers = function () {
            if (control._reactOnClick) control._getSub$El('').unbind('click');
        };

        /**
         * Handles the on click event
         * @param ev
         * @returns {boolean}
         * @private
         */
        control._onClicked = function (ev) {
            control.performNotify();
            ev.stopPropagation();
            return false;
        };

        return control;
    };

    /**
     * Implements a control representing HTML content
     * @param {string} content - html content
     * @returns {Object} - control instance
     * @constructor
     */
    Module.RawHtml = function (content) {
        var control = Module.SingleControlBase({});

        control.createHtml = function () {
            return content;
        };

        return control;
    };

    /**
     * Implements a button control. clicking the button invokes a notification
     * @param {{}} settings - control settings
     * @param {int} settings.width - (optional) button width
     * @param {int} settings.height - (optional) button height
     * @param {string} settings.buttonClass - (optional) css class of the button
     * @param {boolean} settings.enabled - (optional) initial enabled state of the control
     * @param {AXM.Icon|string} settings.icon - (optional) icon displayed in the button
     * @param {float} settings.iconSizeFraction - (optional) icon magnification factor
     * @param {string} settings.text - (optional) button text
     * @param {string} settings.hint - (optional) button hover hint
     * @param {string} settings.helpId - (optional) document Id of a help text associated with the control. displayed as a little help icon on top of the button
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Button = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 110;
        control._height = settings.height || 50;
        control._buttonClass = settings.buttonClass || 'AXMButton';
        control._extraClasses = [];
        control._enabled = true;
        if (settings.enabled === false) control._enabled = false;
        control._checked = false;
        if (settings.checked) control._checked = true;

        control._icon = null; //default: no icon
        if (settings.icon) {
            if (AXMUtils.isObjectType(settings.icon, "icon")) control._icon = settings.icon.clone();else {
                control._icon = Icon.createFA(settings.icon);
            }
            var sizeFactor = 1.0;
            if (settings.iconSizeFraction) sizeFactor *= settings.iconSizeFraction;
            control._icon.changeSize(sizeFactor);
        }

        /**
         * Adds a css class to the button html
         * @param {string} className - css class
         * @returns {Object} - self
         */
        control.addClass = function (className) {
            control._extraClasses.push(className);
            return control;
        };

        /**
         * Creates the control html
         * @returns {String}
         */
        control.createHtml = function () {
            var div = DOM.Div({ id: control._getSubId('') }).addStyle('width', control._width + 'px').addStyle('height', control._height + 'px').addStyle('white-space', 'normal').addStyle('position', 'relative');
            div.addCssClass(control._buttonClass);
            $.each(control._extraClasses, function (idx, className) {
                div.addCssClass(className);
            });

            var aligner = DOM.Div({ parent: div }).addStyle('display', 'inline-block').addStyle('line-height', 'inherit').addStyle('vertical-align', 'middle').addStyle('height', '100%').addStyle('width', '1px');

            if (control._icon && !settings.text) {
                var iconSize = control._icon.getSize();
                div.addStyle('text-align', 'center');
                var divIcon = DOM.Div({ parent: div }).addCssClass('AXMButtonIcon').addStyle('display', 'inline-block').addStyle('line-height', 'inherit').addStyle('vertical-align', 'middle');
                divIcon.addElem(control._icon.renderHtml());
            }

            if (!control._icon && settings.text) {
                //div.addStyle('text-align','center');
                var divText = DOM.Div({ parent: div }).addStyle('display', 'inline-block').addStyle('line-height', 'inherit').addStyle('vertical-align', 'middle').addStyle('padding-left', '5px').addElem(settings.text);
                if (control._width) divText.addStyle('max-width', control._width - 12 + 'px');
            }

            if (control._icon && settings.text) {
                var iconWidth = Math.round(control._height * 0.75);
                var iconSize = control._icon.getSize();
                if (control._icon) {
                    var divIcon = DOM.Div({ parent: div }).addCssClass('AXMButtonIcon').addStyle('display', 'inline-block').addStyle('line-height', 'inherit').addStyle('vertical-align', 'middle').addStyle('width', iconWidth + 'px').addStyle('text-align', 'center');
                    divIcon.addElem(control._icon.renderHtml());
                }
                if (settings.text) {
                    var divText = DOM.Div({ parent: div }).addStyle('display', 'inline-block').addStyle('line-height', '14px').addStyle('vertical-align', 'middle').addElem(settings.text).addStyle('width', control._width - iconWidth - 10 + 'px');
                }
            }

            if (settings.hint) div.addAttribute('title', settings.hint);

            if (settings.helpId) {
                var helpDiv = DOM.Div({ parent: div }).addStyle('position', 'absolute').addStyle('font-size', '18px').addStyle('top', '2px').addStyle('right', '2px').addCssClass('AXMButtonHelp');
                helpDiv.addElem('<i class="fa fa-question-circle"></i>');
            }

            return div.toString();
        };

        /**
         * Updates the html for a change in enabled state
         * @private
         */
        control._updateEnabledState = function () {
            if (control._enabled) control._getSub$El('').css('opacity', 1);else control._getSub$El('').css('opacity', 0.4);
        };

        /**
         * Modifies the enabled state of the button
         * @param {boolean} newStatus - new enabled status
         */
        control.setEnabled = function (newStatus) {
            control._enabled = newStatus;
            control._updateEnabledState();
        };

        /**
         * Updates the html for a change in checked state
         * @private
         */
        control._updateCheckedState = function () {
            if (control._checked) control._getSub$El('').addClass('AXMButtonChecked');else control._getSub$El('').removeClass('AXMButtonChecked');
        };

        /**
         * Modifies the checked state of the button
         * @param {boolean} newStatus - new checked state
         */
        control.setChecked = function (newStatus) {
            control._checked = newStatus;
            control._updateCheckedState();
        };

        /**
         * Attaches html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            control._getSub$El('').click(control._onClicked);
            control._getSub$El('').find('.AXMButtonHelp').click(control._onHelp);
            control._updateEnabledState();
            control._updateCheckedState();
        };

        /**
         * Detaches html event handlers
         */
        control.detachEventHandlers = function () {
            control._getSub$El('').unbind('click');
            control._getSub$El('').find('.AXMButtonHelp').unbind('click');
        };

        /**
         * Handles the on click event
         * @param ev
         * @returns {boolean}
         * @private
         */
        control._onClicked = function (ev) {
            if (!control._enabled) return;
            control.performNotify();
            ev.stopPropagation();
            return false;
        };

        /**
         * Handles the on click event for the optional help button
         * @param ev
         * @returns {boolean}
         * @private
         */
        control._onHelp = function (ev) {
            __webpack_require__(23).create(settings.helpId);
            ev.stopPropagation();
            return false;
        };

        return control;
    };

    /**
     * Creates a standard template button displaying an 'open' action
     * @returns {Object} - control instance
     * @constructor
     */
    Module.OpenButton = function () {
        var control = Module.Button({
            icon: 'fa-external-link-square',
            buttonClass: 'AXMButtonInline',
            width: 25,
            height: 20,
            iconSizeFraction: 0.9
        });
        return control;
    };

    /**
     * Creates a standard template button displaying an 'edit' action
     * @returns {Object} - control instance
     * @constructor
     */
    Module.EditTextItemButton = function () {
        var control = Module.Button({
            icon: 'fa-pencil',
            buttonClass: 'AXMButtonInline',
            width: 25,
            height: 16,
            iconSizeFraction: 0.75
        });
        return control;
    };

    /**
     * Creates a standard template button
     * @param {string} helpId - doc id of the help text
     * @returns {Object} - control instance
     * @constructor
     */
    Module.HelpButton = function (helpId) {
        var control = Module.Button({
            icon: 'fa-question-circle',
            buttonClass: 'AXMButtonHelp',
            width: 26,
            height: 20,
            iconSizeFraction: 1.05

        });
        control.addNotificationHandler(function () {
            __webpack_require__(23).create(helpId);
        });
        return control;
    };

    /**
     * Implements a hyperlink control. clicking on the link invokes a notification
     * @param {{}} settings - control settings
     * @param {string} settings.text - hyperlink text
     * @param {string} settings.class - (optional) hyperlink css class
     * @returns {Object} - control instance
     * @constructor
     */
    Module.HyperLink = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._class = settings.class || 'AXMHyperLinkButton';
        control._extraClasses = [];

        /**
         * Adds a css class to the hyperlink
         * @param {string} className
         * @returns {Object} - self
         */
        control.addClass = function (className) {
            control._extraClasses.push(className);
            return control;
        };

        /**
         * Creates the control html
         * @returns {string} - html
         */
        control.createHtml = function () {
            var div = DOM.Create('div', { id: control._getSubId('') });
            div.addCssClass(control._class);
            $.each(control._extraClasses, function (idx, className) {
                div.addCssClass(className);
            });

            div.addElem(settings.text);

            return div.toString();
        };

        /**
         * Attached the html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            control._getSub$El('').click(control._onClicked);
        };

        /**
         * Detach the html event handlers
         */
        control.detachEventHandlers = function () {
            control._getSub$El('').unbind('click');
        };

        /**
         * Handles the on click event
         * @param ev
         * @returns {boolean}
         * @private
         */
        control._onClicked = function (ev) {
            control.performNotify();
            ev.stopPropagation();
            return false;
        };

        return control;
    };

    /**
     * Implements a check box control. changing the checked state invokes a notification
     * @param {{}} settings - control settings
     * @param {boolean} settings.enabled - (optional) initial enabled state
     * @param {boolean} settings.checked - (optional) initial checked state
     * @param {string} settings.checkedClass - (optional) css class of the checked state
     * @param {string} settings.text - text of the control
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Check = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 120;
        control._height = settings.height || 45;
        control._enabled = true;
        if (settings.enabled === false) control._enabled = false;
        control._value = settings.checked || false;
        control._checkedClass = settings.checkedClass || null;

        control.createHtml = function () {

            var rootEl = DOM.Create("input", { id: control._getSubId('') });
            rootEl.addAttribute("type", 'checkbox');
            if (control._value) rootEl.addAttribute('checked', "checked");

            var label = DOM.Label({ id: control._getSubId('label'), parent: rootEl, target: control._getSubId('') }).addElem(settings.text);

            return rootEl.toString();
        };

        /**
         * Attaches the html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            control._getSub$El('').click(control._onClicked);
            control._checkCheckedClass();
            control._updateEnabledState();
        };

        /**
         * Detach the html event handlers
         */
        control.detachEventHandlers = function () {
            control._getSub$El('').unbind('click');
        };

        /**
         * Handles the on click event
         * @param ev
         * @private
         */
        control._onClicked = function (ev) {
            control._value = control._getSub$El('').is(':checked');
            control._checkCheckedClass();
            control.performNotify();
        };

        /**
         * Updates the html reflecting the enabled state
         * @private
         */
        control._updateEnabledState = function () {
            if (control._enabled) {
                control._getSub$El('').prop('disabled', false);
                control._getSub$El('label').removeClass('AXMDisabledText');
            } else {
                control._getSub$El('').prop('disabled', true);
                control._getSub$El('label').addClass('AXMDisabledText');
            }
        };

        /**
         * Modifies the enabled state of the control
         * @param {boolean} newStatus - new state
         */
        control.setEnabled = function (newStatus) {
            control._enabled = newStatus;
            control._updateEnabledState();
        };

        /**
         * Returns the current checked state of the control
         * @returns {boolean}
         */
        control.getValue = function () {
            if (control._getSub$El('').length > 0) control._value = control._getSub$El('').is(':checked');
            return control._value;
        };

        /**
         * Modifies the checked state of the control
         * @param {boolean} newVal - new checked state
         * @param {boolean} preventNotify - if true, no notification will be invoked for this change
         */
        control.setValue = function (newVal, preventNotify) {
            if (newVal == control.getValue()) return false;
            control._value = newVal;
            if (control._value) control._getSub$El('').prop('checked', 'checked');else control._getSub$El('').removeProp('checked');
            if (!preventNotify) control.performNotify();
            control._checkCheckedClass();
            return true;
        };

        /**
         * Modifies the css checked class
         * @private
         */
        control._checkCheckedClass = function () {
            if (!control._checkedClass) return;
            if (control.getValue()) control._getSub$El('label').addClass(control._checkedClass);else control._getSub$El('label').removeClass(control._checkedClass);
        };

        return control;
    };

    /**
     * Implements a drop-down list control. changing the selected state invokes a notification
     * @param {{}} settings - control settings
     * @param {int} settings.width - width of the box
     * @param {int} settings.height - height of the box
     * @param {int} settings.value - initial state id
     * @param {boolean} settings.disabled - if true, the control is disabled
     * @returns {Object} - control instance
     * @constructor
     */
    Module.DropList = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 120;
        control._height = settings.height || 45;
        control._states = [];
        control._value = settings.value || '';
        control._disabled = settings.disabled || false;
        control._title = settings.title || '';

        /**
         * Removes all the states from the list
         */
        control.clearStates = function () {
            control._states = [];
            control._getSub$El('').html(control._buildSelectContent());
        };

        /**
         * Add a new state to the list
         * @param {string} id - state id
         * @param {string} name - state display name
         * @param {string} group - (optional) group name the state should belong to
         */
        control.addState = function (id, name, group) {
            if (!group) group = '';
            control._states.push({ id: id, name: name, group: group });
            control._getSub$El('').html(control._buildSelectContent());
        };

        /**
         * Returns the current active state
         * @returns {boolean}
         */
        control.getValue = function () {
            var item = control._getSub$El('').find(":selected");
            if (item.length > 0) control._value = item.attr('value');
            return control._value;
        };

        /**
         * Returns the html implementing this control
         * @returns {string}
         */
        control.createHtml = function () {
            var wrapper = DOM.Div();
            wrapper.addStyle('display', 'inline-block');
            if (control._title) wrapper.addAttribute('title', control._title);
            var cmb = DOM.Create('select', { id: control._getSubId(''), parent: wrapper });
            if (control._width) cmb.addStyle('width', control._width + 'px');
            if (control._disabled) cmb.addAttribute('disabled', "disabled");
            cmb.addElem(control._buildSelectContent());
            return wrapper.toString();
        };

        /**
         * Helper function building the content of the select control
         * @returns {string}
         * @private
         */
        control._buildSelectContent = function () {
            var st = '';
            var lastGroupName = '';
            $.each(control._states, function (idx, state) {
                var groupName = state.group || '';
                if (groupName != lastGroupName) {
                    if (lastGroupName) st += '</optgroup>';
                    lastGroupName = groupName;
                    if (groupName) st += '<optgroup label="{name}">'.AXMInterpolate({ name: groupName });
                }
                st += '<option value="{id}" {selected}>{name}</option>'.AXMInterpolate({
                    id: state.id,
                    name: state.name,
                    selected: state.id == control._value ? 'selected="selected"' : ''
                });
            });
            if (lastGroupName) st += '</optgroup>';
            return st;
        };

        /**
         * Attached the html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            var target = 'change.controlevent';
            control._getSub$El('').unbind(target).bind(target, control._onChange);
            //control._getSub$El('').click(control._onClicked);
            if (control._hasDefaultFocus) control._getSub$El('').focus();
        };

        /**
         * Detach the html event handlers
         */
        control.detachEventHandlers = function () {
            var target = 'change.controlevent';
            control._getSub$El('').unbind(target);
        };

        /**
         * Html handler implementing the state change event
         * @private
         */
        control._onChange = function (ev) {
            var oldVal = control._value;
            var newVal = control.getValue();
            if (newVal != oldVal) control.performNotify();
        };

        /**
         * Sets a new active state
         * @param {string} newVal - new state id
         * @param {boolean} preventNotify - if true, no notification is issued about the state change
         */
        control.setValue = function (newVal, preventNotify) {
            if (newVal == control.getValue()) return false;
            control._value = newVal;
            control._getSub$El('').html(control._buildSelectContent());
            if (!preventNotify) control.performNotify();
            return true;
        };

        return control;
    };

    /**
     * Implements a radiobutton group control. changing the selected radiobutton invokes a notification
     * @param {{}} settings - control settings
     * @param {int} settings.width - width of the group
     * @param {int} settings.height - height of the group
     * @param {int} settings.value - initial state id
     * @param {boolean} settings.disabled - if true, the control is disabled
     * @returns {Object} - control instance
     * @constructor
     */
    Module.RadioGroup = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || null;
        control._height = settings.height || 45;
        control._states = [];
        control._value = settings.value || '';
        control._disabled = settings.disabled || false;

        /**
         * Removes all the states from the list
         */
        control.clearStates = function () {
            control._states = [];
            control._getSub$El('').html(control._buildButtonContent());
        };

        /**
         * Add a new state to the list
         * @param {string} id - state id
         * @param {string} name - state display name
         * @param {string} group - (optional) group name the state should belong to
         */
        control.addState = function (id, name, group) {
            if (!group) group = '';
            control._states.push({ id: id, name: name, group: group });
            control._getSub$El('').html(control._buildButtonContent());
        };

        /**
         * Returns the current active state
         * @returns {boolean}
         */
        control.getValue = function () {
            var item = control._getSub$El('').find(":checked");
            if (item.length > 0) control._value = item.attr('value');
            return control._value;
        };

        /**
         * Returns the html implementing this control
         * @returns {string}
         */
        control.createHtml = function () {
            var wrapper = DOM.Div();
            wrapper.addStyle('display', 'inline-block');
            var div = DOM.Create('div', { id: control._getSubId(''), parent: wrapper });
            if (control._width) div.addStyle('width', control._width + 'px');

            div.addElem(control._buildButtonContent());
            return wrapper.toString();
        };

        /**
         * Helper function building the content of the radiogroup control
         * @returns {string}
         * @private
         */
        control._buildButtonContent = function () {
            var st = '';
            var lastGroupName = '';
            $.each(control._states, function (idx, state) {
                //var groupName = state.group || ''; //todo: what whith groups?
                //if (groupName != lastGroupName) {
                //    if (lastGroupName)
                //        st += '</radiogroup>';
                //    lastGroupName = groupName;
                //    if (groupName)
                //        st += '<radiogroup = label="{name}">'.AXMInterpolate({name: groupName});
                //}

                var item_id = control._getSubId('_id_' + state.id);
                st += '<div class="RadioButtonItem"><input type="radio" id="{item_id}" name="{control_id}" value="{id}" {selected}></input><label for="{item_id}">{name}</label></div>'.AXMInterpolate({
                    control_id: control._getSubId(''),
                    id: state.id,
                    item_id: item_id,
                    name: state.name,
                    selected: state.id == control._value ? 'checked="checked"' : ''
                });
            });
            //if (lastGroupName)
            //    st += '</radiogroup>';
            return st;
        };

        /**
         * Attached the html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            var target = 'change.controlevent';
            control._getSub$El('').unbind(target).bind(target, control._onChange);
            //control._getSub$El('').click(control._onClicked);
        };

        /**
         * Detach the html event handlers
         */
        control.detachEventHandlers = function () {
            var target = 'change.controlevent';
            control._getSub$El('').unbind(target);
        };

        /**
         * Html handler implementing the state change event
         * @private
         */
        control._onChange = function (ev) {
            var oldVal = control._value;
            var newVal = control.getValue();
            if (newVal != oldVal) control.performNotify();
        };

        /**
         * Sets a new active state
         * @param {string} newVal - new state id
         * @param {boolean} preventNotify - if true, no notification is issued about the state change
         */
        control.setValue = function (newVal, preventNotify) {
            if (newVal == control.getValue()) return false;
            control._value = newVal;
            control._getSub$El('').html(control._buildButtonContent());
            if (!preventNotify) control.performNotify();
            return true;
        };

        return control;
    };

    /**
     * Implements a text edit control. a notification is sent each time the content of the edit box changes
     * @param {{}} settings - control settings
     * @param {int} settings.width - width of the edit box
     * @param {int} settings.height - height of the edit box
     * @param {string} settings.value - initial content of the edit box
     * @param {object} settings.choices - autocomplete choices (optional, keys: label, value)
     * @param {boolean} settings.passWord - if true, a password control is created
     * @param {boolean} settings.disabled - if true, the edit control is disabled
     * @param {boolean} settings.bold - if true, text in the control appears in bold
     * @param {boolean} settings.hasClearButton - if true, the control also has a button that clears the content when the user clicks it
     * @param {string} settings.nonEmptyClass - (optional) a css style class automatically attached to the box if the content is not empty
     * @param {string} settings.placeHolder - (optional) a text that appears as a place holder in the box if the content is empty
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Edit = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 120;
        control._height = settings.height || 20;
        control._value = settings.value || '';
        control._isPassWord = settings.passWord || false;
        control._disabled = settings.disabled || false;
        control._nonEmptyClass = settings.nonEmptyClass || null;
        control._choices = null;

        if (settings.hasClearButton) control._clearButton = Module.Button({
            icon: 'fa-times',
            width: 20,
            height: 19,
            buttonClass: 'AXMButtonCommandBar',
            iconSizeFraction: 0.9,
            enabled: false
        }).addNotificationHandler(function () {
            control.setValue('');
            control._clearButton.setEnabled(false);
        });

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        control.createHtml = function () {

            var elementId = control._getSubId('');
            var rootEl = DOM.Create("input", { id: elementId });
            rootEl.addCssClass('AXMEdit');

            if (settings.bold) rootEl.addStyle('font-weight', 'bold');

            if (control._disabled) rootEl.addAttribute('disabled', "disabled");

            if (control._width) rootEl.addStyle('width', control._width + 'px');
            if (control._height) rootEl.addStyle('height', control._height + 'px');
            if (!control._isPassWord) rootEl.addAttribute("type", 'text');else rootEl.addAttribute("type", 'password');
            rootEl.addAttribute("value", control._value);
            if (settings.placeHolder) rootEl.addAttribute("placeholder", settings.placeHolder);

            var str = rootEl.toString();
            if (control._clearButton) str += control._clearButton.createHtml();
            return str;
        };

        /**
         * Attaches the html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            control._getSub$El('').click(control._onClicked);
            control._getSub$El('').bind("propertychange input paste", control._onModified);
            control._getSub$El('').bind("keyup", control._onModified);
            control._checkNonEmptyClass();
            if (control._clearButton) control._clearButton.attachEventHandlers();
            if (settings.choices) {
                var input = document.getElementById(control._id);
                control._choices = new Awesomplete(input, {
                    list: settings.choices
                });
            }
            if (control._hasDefaultFocus) {
                control._getSub$El('').focus();
                control._getSub$El('').select();
            }
        };

        control.modifyChoices = function (choicesList) {
            if (!control._choices) AXMUtils.reportBug('Do not call if there are no options');
            control._choices.list = choicesList;
            // control._choices.evaluate();
        };

        /**
         * Detach the html event handlers
         */
        control.detachEventHandlers = function () {
            control._getSub$El('').unbind('click');
            control._getSub$El('').unbind("propertychange input paste");
            control._getSub$El('').unbind("keyup");
            if (control._clearButton) control._clearButton.detachEventHandlers();
        };

        /**
         * Handles the html on modified event
         * @param ev
         * @private
         */
        control._onModified = function (ev) {
            var txt = control.getValue();
            if (control._clearButton) {
                control._clearButton.setEnabled(txt.length > 0);
            }
            control._checkNonEmptyClass();
            control.performNotify();
        };

        /**
         * Updates the empty box css class
         * @private
         */
        control._checkNonEmptyClass = function () {
            if (!control._nonEmptyClass) return;
            var txt = control.getValue();
            if (txt.length > 0) control._getSub$El('').addClass(control._nonEmptyClass);else control._getSub$El('').removeClass(control._nonEmptyClass);
        };

        /**
         * Sets the focus to the edit box
         */
        control.setFocus = function () {
            control._getSub$El('').select();
        };

        /**
         * Returns the current content of the edit box
         * @returns {string}
         */
        control.getValue = function () {
            if (control._getSub$El('').length > 0) control._value = control._getSub$El('').val();
            return control._value;
        };

        /**
         * Modifies the current content of the edit box
         * @param {string} newVal - new content
         * @param {boolean} preventNotify - if true, no notification is issued about the content change
         */
        control.setValue = function (newVal, preventNotify) {
            if (newVal == control.getValue()) return false;
            control._value = newVal;
            control._getSub$El('').val(newVal);
            control._checkNonEmptyClass();
            if (control._clearButton) {
                var txt = control.getValue();
                control._clearButton.setEnabled(txt.length > 0);
            }
            if (!preventNotify) control.performNotify();
        };

        return control;
    };

    /**
     * Implements a multi-line text box control
     * @param {{}} settings - control settings
     * @param {int} settings.width - width of the edit box
     * @param {int} settings.lineCount - number of lines of the text box
     * @param {boolean} settings.fixedfont - if true, a fixed space font is used
     * @param {boolean} settings.noWrap - if true, text is not automatically wrapped over multiple lines
     * @param {boolean} settings.noResize - if true, text box cannot be resized
     * @param {string} settings.value - initial content of the control
     * @returns {Object} - control instance
     * @constructor
     */
    Module.TextArea = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 120;
        control._lineCount = settings.lineCount || 2;
        control._value = settings.value || '';
        control._fixedfont = settings.fixedfont || false;
        control._noWrap = settings._noWrap || false;
        if (settings.noWrap) control._noWrap = true;
        control._noResize = settings.noResize || false;

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        control.createHtml = function () {

            var rootEl = DOM.Create("textarea", { id: control._getSubId('') });
            rootEl.addCssClass('AXMEdit');

            rootEl.addAttribute('rows', control._lineCount);

            if (control._disabled) rootEl.addAttribute('disabled', "disabled");

            if (control._width) rootEl.addStyle('width', control._width + 'px');

            rootEl.addElem(control._value);

            rootEl.addAttribute('autocorrect', "off");
            rootEl.addAttribute('autocapitalize', "off");
            rootEl.addAttribute('autocomplete', "off");
            if (control._noResize) rootEl.addAttribute('resize', "none");
            if (control._noWrap) {
                rootEl.addStyle('overflow-x', 'scroll');
                rootEl.addStyle('white-space', 'pre');
                rootEl.addAttribute('wrap', "off");
            }
            if (control._fixedfont) {
                rootEl.addStyle('font-family', 'Courier');
            } else {
                rootEl.addStyle('font-family', 'Verdana, Arial, Helvetica, sans-serif');
            }

            var str = rootEl.toString();
            if (control._clearButton) str += control._clearButton.createHtml();
            return str;
        };

        /**
         * Attaches the html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            control._getSub$El('').click(control._onClicked);
            control._getSub$El('').bind("propertychange input paste", control._onModified);
            control._getSub$El('').bind("keyup", control._onModified);
            control._checkNonEmptyClass();
            if (control._hasDefaultFocus) control._getSub$El('').select();
            if (control._clearButton) control._clearButton.attachEventHandlers();
        };

        /**
         * Detaches the html event handlers
         */
        control.detachEventHandlers = function () {
            control._getSub$El('').unbind('click');
            control._getSub$El('').unbind("propertychange input paste");
            control._getSub$El('').unbind("keyup");
            if (control._clearButton) control._clearButton.detachEventHandlers();
        };

        /**
         * Handler the html on modified event
         * @param ev
         * @private
         */
        control._onModified = function (ev) {
            var txt = control.getValue();
            if (control._clearButton) {
                control._clearButton.setEnabled(txt.length > 0);
            }
            control._checkNonEmptyClass();
            control.performNotify();
        };

        /**
         * Currently not implemented
         * @private
         */
        control._checkNonEmptyClass = function () {};

        /**
         * Sets the focus to this control
         */
        control.setFocus = function () {
            control._getSub$El('').select();
        };

        /**
         * Returns the current content of the edit box
         * @returns {string}
         */
        control.getValue = function () {
            if (control._getSub$El('').length > 0) control._value = control._getSub$El('').val();
            return control._value;
        };

        /**
         * Modifies the content of the edit box
         * @param {string} newVal - new content
         * @param {boolean} preventNotify - if true, no change notification is sent
         */
        control.setValue = function (newVal, preventNotify) {
            if (newVal == control.getValue()) return false;
            control._value = newVal;
            control._getSub$El('').val(newVal);
            control._checkNonEmptyClass();
            if (control._clearButton) {
                var txt = control.getValue();
                control._clearButton.setEnabled(txt.length > 0);
            }
            if (!preventNotify) control.performNotify();
        };

        return control;
    };

    /**
     * Implements a multi-line code edit box control
     * @param {{}} settings - control settings
     * @param {int} settings.width - width of the edit box
     * @param {int} settings.height - height text box
     * @param {int} settings.type - code type. Currently only yaml is supported, but easily extensible
     * @param {string} settings.value - initial content of the control
     * @returns {Object} - control instance
     * @constructor
     */
    Module.CodeEditor = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 120;
        control._height = settings.height || 100;
        control._value = settings.value || '';
        if (settings.type != "yaml") throw Exception("Invalid code type");

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        control.createHtml = function () {
            var rootEl = DOM.Div({ id: control._getSubId('') });
            rootEl.addCssClass("CodeEditor");
            rootEl.addStyle("min-width", control._width + 5 + "px");
            rootEl.addStyle("min-height", control._height + 5 + "px");
            var str = rootEl.toString();
            return str;
        };

        /**
         * Attaches the html event handlers after DOM insertion
         */
        control.attachEventHandlers = function () {
            control.cm = CodeMirror(control._getSub$El('')[0], {
                value: control._value,
                mode: "yaml"
            });
            control.cm.setSize(control._width, control._height);
        };

        /**
         * Returns the current content of the edit box
         * @returns {string}
         */
        control.getValue = function () {
            if (control.cm) control._value = control.cm.getValue();
            return control._value;
        };

        return control;
    };

    /**
     * Implements a file drag & drop area
     * @param {{}} settings - control settings
     * @param {int} settings.width - width of the drop area
     * @param {int} settings.height - height of the drop area
     * @param {string} settings.text - text displayed in the drop area
     * @returns {Object} - returns the control instance
     * @constructor
     */
    Module.FileDrop = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 160;
        control._height = settings.height || 60;
        control._text = settings.text || 'Drop file(s)';
        control._files = null;

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        control.createHtml = function () {
            var div = DOM.Div({ id: control._getSubId('') }).addStyle('width', control._width + 'px').addStyle('height', control._height + 'px').addStyle('white-space', 'normal').addStyle('position', 'relative');
            div.addCssClass('AXMFileDrop');
            var txtDiv = DOM.Div({ parent: div });
            txtDiv.addElem(control._text);
            return div.toString();
        };

        /**
         * Handles the drag over html event
         */
        control.onDragOver = function () {
            control._getSub$El('').addClass('AXMFileDropDragOver');
        };

        /**
         * Handles the drag leave html event
         */
        control.onDragLeave = function () {
            control._getSub$El('').removeClass('AXMFileDropDragOver');
        };

        /**
         * Handles the drop html event
         * @param ev
         */
        control.onDrop = function (ev) {
            control._getSub$El('').removeClass('AXMFileDropDragOver');
            control._files = ev.originalEvent.dataTransfer.files;
            control.performNotify();
        };

        /**
         * Attaches the html events after DOM insertion
         */
        control.attachEventHandlers = function () {
            control._getSub$El('').on("dragover", control.onDragOver).on("dragleave", control.onDragLeave).on("drop", control.onDrop);
        };

        /**
         * Detaches the html events
         */
        control.detachEventHandlers = function () {
            control._getSub$El('').off("dragover").off("dragleave").off("drop");
        };

        /**
         * Returns the set of files currently dropped in the area
         * @returns {FileList}
         */
        control.getValue = function () {
            return control._files;
        };

        return control;
    };

    /**
     * Implements a value slider control
     * @param {{}} settings - control settings
     * @param {int} settings.width - width of the slider
     * @param {float} settings.minValue - minimum value of the slider value
     * @param {float} settings.maxValue - maximum value of the slider value
     * @param {float} settings.steps - increment of the slider value
     * @param {float} settings.value - initial slider value
     * @param {string} settings.text - displayed text
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Slider = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._width = settings.width || 160;
        control._minValue = settings.minValue || 0;
        control._maxValue = settings.maxValue || 1000;
        control._step = settings.step || 1;
        control._value = settings.value || 0;
        control._text = settings.text || '';

        control._value = Math.round(control._value / control._step) * control._step;

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        control.createHtml = function () {

            var div = DOM.Div({ id: control._getSubId('') }).addStyle('width', control._width + 'px').addStyle('height', control._height + 'px')
            //.addStyle('line-height',control._height+'px')
            .addStyle('white-space', 'normal').addStyle('position', 'relative');

            DOM.Create('Span', { parent: div }).addElem(control._text);
            DOM.Create('Span', { id: control._getSubId('value'), parent: div }).addStyle('float', 'right');

            var slider = DOM.Create("input", { id: control._getSubId('slider'), parent: div });
            slider.addAttribute('type', 'range').addAttribute('min', control._minValue).addAttribute('max', control._maxValue).addAttribute('step', control._step).addAttribute('value', control._value).addCssClass('AXMEdit').addStyle('width', control._width + 'px').addStyle('white-space', 'normal').addStyle('position', 'relative');
            return div.toString();
        };

        /**
         * Attached the html events after DOM creation
         */
        control.attachEventHandlers = function () {
            control._getSub$El('slider').change(control._onChange);
            setTimeout(function () {
                control._setNewValue();
            }, 700);
        };

        /**
         * Handles the html on change event
         * @private
         */
        control._onChange = function () {
            control._value = parseFloat(control._getSub$El('slider').val());
            control._setNewValue();
            control.performNotify();
        };

        /**
         * Sets the new displayed value
         * @private
         */
        control._setNewValue = function () {
            control._getSub$El('value').text(control._value);
        };

        /**
         * Returns the current value of the slider
         * @returns {float}
         */
        control.getValue = function () {
            if (control._getSub$El('slider').length > 0) control._value = parseFloat(control._getSub$El('slider').val());
            return control._value;
        };

        control.setValue = function (newVal, preventNotify) {
            control._getSub$El('slider').val(newVal);
            if (!preventNotify) control.performNotify();
        };

        return control;
    };

    Module.DateTimePicker = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._height = settings.height || 20;
        control._width = settings.width || 160;
        control._value = settings.value || '';
        control._text = settings.text || '';
        control._disabled = settings.disabled || '';

        control._IsInitDone = false;
        control._timepicker = settings.timepicker;
        control._inline = settings.inline;

        //control._mask=settings.mask || '9999-19-39 29:59';
        control._format = settings.format || 'Y-m-d H:i';
        control._formatDate = settings.formatDate || 'Y-m-d';
        control._formatTime = settings.formatTime || 'H:i';

        control._defaultTime = settings.defaultTime;
        control._defaultDate = settings.defaultDate;

        control._scrollMonth = settings._scrollMonth || false;
        control._scrollTime = settings._scrollTime || false;
        control._scrollInput = settings._scrollInput || false;
        //control._minDate:settings.minDate:'+1970/01/02';//disable dates in the future
        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        control.createHtml = function () {
            control._datetimepickerid = control._getSubId('datetimepicker');
            var rootEl = DOM.Create("input", { id: control._datetimepickerid });
            rootEl.addCssClass('AXMEdit');
            rootEl.addCssClass('AXMdatetimepicker');

            if (control._disabled) rootEl.addAttribute('disabled', "disabled");

            if (control._width) rootEl.addStyle('width', control._width + 'px');
            if (control._height) rootEl.addStyle('height', control._height + 'px');
            if (control._value) rootEl.value = control._value;

            return rootEl.toString();
        };

        control.attachEventHandlers = function () {
            $.datetimepicker.setLocale('en');
            $("#" + control._datetimepickerid).datetimepicker({
                value: control._value,
                defaultTime: control._defaultTime,
                defaultDate: control._defaultDate,
                timepicker: control._timepicker,
                inline: control._inline,
                //mask:control._mask
                format: control._format,
                formatDate: control._formatDate,
                formatTime: control._formatTime,
                scrollMonth: control._scrollMonth,
                scrollTime: control._scrollTime,
                scrollInput: control._scrollInput

            });
        };

        /**
         * Handles the html on change event
         * @private
         */
        control._onChange = function () {
            control._value = control._getSub$El('datetimepicker').val();
            control._setNewValue();
            control.performNotify();
        };

        /**
         * Returns the current value of the control
         * @returns {float}
         */
        control.getValue = function () {
            if (control._getSub$El('datetimepicker').length > 0) control._value = control._getSub$El('datetimepicker').val();
            return control._value;
        };

        control.setValue = function (newVal) {
            control._getSub$El('datetimepicker').val(newVal);
        };

        return control;
    };

    Module.DateRange = function (settings) {

        var pad = function pad(num, size) {
            var s = num + "";
            while (s.length < size) {
                s = "0" + s;
            }return s;
        };

        var control = Module.DropList(settings);
        control.addState('', _TRL("-- All dates --"));
        var monthNames = [_TRL('January'), _TRL('February'), _TRL('March'), _TRL('April'), _TRL('May'), _TRL('June'), _TRL('July'), _TRL('August'), _TRL('September'), _TRL('October'), _TRL('November'), _TRL('December')];
        var currentDate = new Date();
        var currentMonth = currentDate.getMonth();
        var currentYear = currentDate.getYear() + 1900;
        for (var i = 0; i < 18; i++) {
            control.addState(currentYear + '-' + (currentMonth + 1), monthNames[currentMonth] + ' ' + currentYear, ' ' + currentYear);
            currentMonth--;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            }
        }

        control.isSet = function () {
            var value = control.getValue();
            return !!value;
        };

        control.getDateRangeStart = function () {
            if (!control.isSet()) return "1900-01-01";
            var year = control.getValue().split('-')[0];
            var month = control.getValue().split('-')[1];
            return year + '-' + pad(month, 2) + "-01";
        };

        control.getDateRangeEnd = function () {
            if (!control.isSet()) return "2100-01-01";
            var year = control.getValue().split('-')[0];
            var month = control.getValue().split('-')[1];
            var date = new Date(year, month - 1, 1, 0, 0, 0);
            date.setMonth(date.getMonth() + 1);
            date.setDate(date.getDate() - 1);
            var year = date.getYear() + 1900;
            var month = date.getMonth() + 1;
            var day = date.getDate();
            return year + '-' + pad(month, 2) + '-' + pad(day, 2);
        };

        return control;
    };

    /**
     * Implements a color picker control
     * @param {{}} settings - control settings
     * @param {AXM.Color} settings.value - initial color value
     * @returns {Object} - control instance
     * @constructor
     */
    Module.ColorPickerPredefined = function (settings) {
        var control = Module.SingleControlBase(settings);
        control._value = settings.value || Color.Color(0.5, 0.5, 0.5);

        control._baseColors = [Color.Color(0.9, 0.2, 0.2), Color.Color(0.9, 0.5, 0.0), Color.Color(0.8, 0.6, 0.0), Color.Color(0.4, 0.6, 0.0), Color.Color(0.0, 0.7, 0.0), Color.Color(0.2, 0.6, 0.6), Color.Color(0.3, 0.3, 1.0), Color.Color(0.7, 0.2, 0.7), Color.Color(0.4, 0.4, 0.4)];

        control._colors = [];
        $.each(control._baseColors, function (idx, baseColor) {
            control._colors.push(baseColor.darken(0.3));
        });
        $.each(control._baseColors, function (idx, baseColor) {
            control._colors.push(baseColor.lighten(0.1).deSaturate(0.15));
        });
        $.each(control._baseColors, function (idx, baseColor) {
            control._colors.push(baseColor.lighten(0.5));
        });

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        control.createHtml = function () {

            var div = DOM.Div({ id: control._getSubId('') });
            var divCurrent = DOM.Div({ parent: div, id: control._getSubId('current') });
            divCurrent.addStyle("width", "30px").addStyle("height", "49px").addStyle("display", "inline-block").addStyle("margin-right", "7px").addStyle("margin-bottom", "2px");
            divCurrent.addStyle("background-color", control._value.toString());

            var divColors = DOM.Div({ parent: div });
            divColors.addStyle("display", "inline-block");
            $.each(control._colors, function (idx, color) {
                var divColor = DOM.Div({ parent: divColors, id: control._getSubId('color_' + idx) });
                divColor.addStyle("width", "15px").addStyle("height", "15px").addStyle("display", "inline-block").addStyle("margin-right", "2px").addStyle("margin-bottom", "2px").addStyle("cursor", "pointer");
                divColor.addStyle("background-color", color.toString());
                if ((idx + 1) % control._baseColors.length == 0) divColors.addElem('<br>');
            });

            return div.toString();
        };

        /**
         * Attached the html events after DOM creation
         */
        control.attachEventHandlers = function () {
            $.each(control._colors, function (idx, color) {
                $('#' + control._getSubId('color_' + idx)).click(function () {
                    control._value = color;
                    $('#' + control._getSubId('current')).css("background-color", color.toString());
                    control.performNotify();
                });
            });
        };

        /**
         * Returns the current value of the slider
         * @returns {AXM.Color}
         */
        control.getValue = function () {
            //if (control._getSub$El('slider').length>0)
            //    control._value = parseFloat(control._getSub$El('slider').val());
            return control._value;
        };

        return control;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils) {

    /**
     * Module encapsulation a set of classes that represent HTML elements
     * @type {{}}
     */
    var Module = {};

    /**
     * Abstact base class for a html element
     * @param {string} itype - element type
     * @param {{}} args - various possible arguments
     * @param {Module._Element} args.parent - (optional) parent element
     * @private
     */
    Module._Element = function (itype, args) {
        this.myType = itype;
        this.myAttributes = {};
        this.myClasses = [];
        this.myStyles = {};
        this.myComponents = [];

        //do the stuff with the arguments provided
        if (typeof args != 'undefined') {
            if ('id' in args) this.setID(args.id);
            if ('parent' in args) {
                if (!(args.parent instanceof Module._Element)) AXMUtils.reportBug("DocEl parent is not a DocEl");
                args.parent.addElem(this);
            }
        }
    };

    /**
     * Sets the html id
     * @param {string} iID
     */
    Module._Element.prototype.setID = function (iID) {
        this.myID = iID;
        this.addAttribute("id", iID);
    };

    /**
     * Returns the html id
     * @returns {string}
     */
    Module._Element.prototype.getID = function () {
        return this.myID;
    };

    /**
     * Adds a html attribute
     * @param {string} id - attribute id
     * @param {string} content - attribute content
     * @returns {Module._Element} - self
     */
    Module._Element.prototype.addAttribute = function (id, content) {
        this.myAttributes[id] = '' + content;
        return this;
    };

    /**
     * Adds a css style
     * @param {string} id - syle id
     * @param {string} content - style content
     * @returns {Module._Element} - self
     */
    Module._Element.prototype.addStyle = function (id, content) {
        this.myStyles[id] = '' + content.toString();
        return this;
    };

    /**
     * Adds a member element
     * @param icomp - element
     * @returns {Module._Element} - self
     */
    Module._Element.prototype.addElem = function (icomp) {
        this.myComponents.push(icomp);
        return this;
    };

    /**
     * Returns a member element
     * @param {int} nr
     * @returns {*} - element
     */
    Module._Element.prototype.getElem = function (nr) {
        return this.myComponents[nr];
    };

    /**
     * Adds a css class
     * @param {string} iclss
     * @returns {Module._Element} - self
     */
    Module._Element.prototype.addCssClass = function (iclss) {
        this.myClasses.push(iclss);
        return this;
    };

    /**
     * Converts the object to html markup string
     * @returns {string} - html string
     */
    Module._Element.prototype.toString = function () {
        var rs = '<' + this.myType;

        for (var id in this.myAttributes) {
            rs += ' ';
            rs += id + '="' + this.myAttributes[id] + '"';
            first = false;
        }

        if (this.myClasses.length > 0) {
            rs += ' class="';
            rs += this.myClasses.join(' ');
            rs += '"';
        }

        if (true) {
            rs += ' style="';
            var first = true;
            for (id in this.myStyles) {
                if (!first) rs += ';';
                rs += id + ":" + this.myStyles[id];
                first = false;
            }
            rs += '"';
        }
        rs += '>';

        rs += this.CreateInnerHtml();

        rs += '</' + this.myType + '>';
        return rs;
    };

    /**
     * Returns the html markup string for the member elements
     * @returns {string}
     */
    Module._Element.prototype.CreateInnerHtml = function () {
        var rs = '';
        for (var compnr = 0; compnr < this.myComponents.length; compnr++) {
            if (this.myComponents[compnr]) rs += this.myComponents[compnr].toString();
        }
        return rs;
    };

    /**
     * Returns an object containing a generic html element
     * @param {string} itype - element type
     * @param {{}} args - see Module._Element
     * @returns {Module._Element} - the element instance
     * @constructor
     */
    Module.Create = function (itype, args) {
        var that = new Module._Element(itype, args);
        return that;
    };

    /**
     * Returns a div element
     * @param {{}} args - see Module._Element
     * @returns {Module._Element} - the element instance
     * @constructor
     */
    Module.Div = function (args) {
        var that = Module.Create("div", args);
        return that;
    };

    /**
     * Returns a label element
     * @param {{}} args - see Module._Element
     * @param {string} args.target - target of the label
     * @returns {Module._Element} - the element instance
     * @constructor
     */
    Module.Label = function (args) {
        var that = Module.Create("label", args);
        if ('target' in args) that.addAttribute("for", args.target);
        return that;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(31), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Utils, Popupwin, TransientPopup, Controls) {

    /**
     * Module encapsulating a number of commonly used stock popup windows
     * @type {{}}
     */
    var Module = {};

    /**
     * Creates a classical message box
     * @param {string} content - content of the box
     * @param {string} title - title
     * @param {function} onProceed - called when the user clicks OK
     * @returns {{}} - the popup window instance
     * @constructor
     */
    Module.MessageBox = function (content, title, onProceed) {
        if (!title) title = _TRL("Message");

        var win = Popupwin.create({
            title: title,
            blocking: true,
            autoCenter: true,
            preventClose: true
        });

        win.doClose = function () {
            win.close();
            if (onProceed) onProceed();
        };

        var grp = Controls.Compound.GroupVert({});
        grp.add(Controls.Static({ text: content + '<p/>' }));

        var btOK = Controls.Button({
            text: _TRL('OK'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.doClose();
        });
        grp.add(btOK);

        win.setHandler_OnPressedEnter(win.doClose);
        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    /**
     * Creates a confirmation popup box
     * @param {string} content
     * @param {string} title
     * @param {{}} settings
     * @param {string} settings.textOK - txt on the OK button
     * @param {string} settings.iconOK - icon of the OK button
     * @param {string} settings.textCancel - txt on the Cancel button
     * @param {string} settings.iconCancel - icon of the Cancel button
     * @param {function} onOK - called when the user clicks the OK button
     * @param {function} onCancel - called when te user clicks the Cancel button
     * @constructor
     * @returns {{}} - the popup window instance
     */
    Module.ConfirmationBox = function (content, title, settings, onOK, onCancel) {
        if (!title) title = _TRL("Confirmation");
        if (!settings) settings = {};

        var win = Popupwin.create({
            title: title,
            blocking: true,
            autoCenter: true
        });

        var grp = Controls.Compound.GroupVert({});
        grp.add(Controls.Static({ text: content + '<p/>' }));

        var btOK = Controls.Button({
            text: settings.textOK || _TRL('OK'),
            icon: settings.iconOK || 'fa-check'
        }).addNotificationHandler(function () {
            win.close();
            if (onOK) onOK();
        });

        var btCancel = Controls.Button({
            text: settings.textCancel || _TRL('Cancel'),
            icon: settings.iconCancel || 'fa-times'
        }).addNotificationHandler(function () {
            win.close();
            if (onCancel) onCancel();
        });

        grp.add(Controls.Compound.GroupHor({}, [btOK, btCancel]));

        win.setHandler_OnPressedEnter(win.close);
        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    /**
     * Creates a popup with options "Yes", "No", "Cancel"
     * @param {string} content - popup content
     * @param {string} title - popup title
     * @param {{}} settings
     * @param {string} settings.textYes - txt on the Yes button
     * @param {string} settings.iconYes - icon of the Yes button
     * @param {string} settings.textNo - txt on the No button
     * @param {string} settings.iconNo - icon of the No button
     * @param {function} onYes - called when the user clicks Yes
     * @param {function} onNo - called when the user clicks No
     * @param {function} onCancel - called when the user clicks Cancel
     * @constructor
     * @returns {{}} - the popup window instance
     */
    Module.YesNoCancelBox = function (content, title, settings, onYes, onNo, onCancel) {
        if (!title) title = _TRL("Confirmation");
        if (!settings) settings = {};

        var win = Popupwin.create({
            title: title,
            blocking: true,
            headerIcon: settings.headerIcon || null,
            autoCenter: true
        });

        var grp = Controls.Compound.GroupVert({});
        grp.add(Controls.Static({ text: content + '<p/>' }));

        var btYes = Controls.Button({
            text: settings.textYes || _TRL('Yes'),
            icon: settings.iconYes || 'fa-check'
        }).addNotificationHandler(function () {
            win.close();
            if (onYes) onYes();
        });

        var btNo = Controls.Button({
            text: settings.textNo || _TRL('No'),
            icon: settings.iconNo || 'fa-times'
        }).addNotificationHandler(function () {
            win.close();
            if (onNo) onNo();
        });

        var btCancel = Controls.Button({
            text: _TRL('Cancel')
        }).addNotificationHandler(function () {
            win.close();
            if (onCancel) onCancel();
        });

        grp.add(Controls.Compound.GroupHor({}, [btYes, btNo, btCancel]));

        win.setHandler_OnPressedEnter(win.close);
        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    /**
     * Creates a popup presenting a number of choices as buttons
     * @param {string} title
     * @param {string} intro - intro text above the acion buttons
     * @param {[{name, icon, action}]} actions - list of actions (action = handler function). Optional buttonClass key
     * @param {{}} settings
     * @constructor
     * @returns {{}} - the popup window instance
     */
    Module.ActionChoiceBox = function (title, intro, actions, settings) {
        if (!title) title = _TRL("Action");
        if (!intro) intro = "";
        if (!settings) settings = {};

        var win = Popupwin.create({
            title: title,
            blocking: true,
            autoCenter: true
        });

        var grp = Controls.Compound.GroupVert({});
        grp.add(Controls.Static({ text: intro + '<p/>' }));

        var buttons = [];
        $.each(actions, function (idx, action) {
            var bt = Controls.Button({
                text: action.name,
                icon: action.icon || null,
                width: 140,
                height: 65,
                iconSizeFraction: 1.4
            }).addNotificationHandler(function () {
                win.close();
                action.action();
            });
            if (action.buttonClass) {
                bt.addClass(action.buttonClass);
            }
            buttons.push(bt);
        });

        grp.add(Controls.Compound.GroupHor({}, buttons));

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    /**
     * Creates a popup with a text edit box
     * @param {string} value - initial content of the edit box
     * @param {string} header - text displayed above the edit box
     * @param {string} title - title of the popup
     * @param {{}} settings
     * @param {function} onOK - called when the user clicks OK (new content provided as argument)
     * @param {function} onCancel - called when the user clicks Cancel
     * @constructor
     * @returns {{}} - the popup instance
     */
    Module.TextEditBox = function (value, header, title, settings, onOK, onCancel) {

        var win = Popupwin.create({
            title: title,
            blocking: true,
            autoCenter: true
        });

        var grp = Controls.Compound.GroupVert({ separator: 12 });
        grp.add(Controls.Static({ text: header }));

        var btOK = Controls.Button({
            text: _TRL('OK'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.onOK();
        });

        var btCancel = Controls.Button({
            text: _TRL('Cancel'),
            icon: 'fa-times'
        }).addNotificationHandler(function () {
            win.close();
            if (onCancel) onCancel();
        });

        win.ctrlEdit = Controls.Edit({ width: 230, value: value }).setHasDefaultFocus();
        grp.add(win.ctrlEdit);

        grp.add(Controls.Compound.GroupHor({}, [btOK, btCancel]));

        win.onOK = function () {
            var newValue = win.ctrlEdit.getValue();
            win.close();
            if (onOK) onOK(newValue);
        };

        win.setHandler_OnPressedEnter(win.onOK);
        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    /**
     * Creates a popup presenting a drop-down list with a number of choices
     * @param {string} value - initial value of chocie ID
     * @param {[{}]} choices - list of choices (see AXM.Controls.DropList for details)
     * @param {string} header - text above the drop down
     * @param {string} title - popup title
     * @param {{}} settings
     * @param {boolean} settings.canBeEmpty - allow to select nothing
     * @param {function} onOK - called when the user clicks OK (active choice id provided as an argument)
     * @param {function} onCancel - called when the user clicks Cancel
     * @constructor
     */
    Module.MultipleChoiceBox = function (value, choices, header, title, settings, onOK, onCancel) {

        if (!settings.useTransientPopup) {
            var win = Popupwin.create({
                title: title,
                headerIcon: settings.headerIcon || null,
                blocking: true,
                autoCenter: true
            });
        } else {
            var win = TransientPopup.create({
                DOM$Elem: settings.DOM$Elem
            });
        }

        var grp = Controls.Compound.GroupVert({ separator: 5 });

        if (settings.useTransientPopup && !header && title) grp.add(title);

        if (settings.helpId) grp.add(Controls.Compound.GroupHor({ verticalAlignCenter: true }, [header, Controls.HelpButton(settings.helpId)]));else grp.add(header);

        var btOK = Controls.Button({
            text: _TRL('OK'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.onOK();
        });

        var btCancel = Controls.Button({
            text: _TRL('Cancel'),
            icon: 'fa-times'
        }).addNotificationHandler(function () {
            win.close();
            if (onCancel) onCancel();
        });

        if (settings.controlType == 'dropdown') {
            win.ctrlChoices = Controls.DropList({ value: value, width: settings.controlWidth });
        } else {
            win.ctrlChoices = Controls.RadioGroup({ value: value });
        }

        $.each(choices, function (idx, choice) {
            win.ctrlChoices.addState(choice.id, choice.name, choice.group);
        });
        grp.add(win.ctrlChoices);

        grp.add(Controls.Compound.SeparatorV(10));

        grp.add(Controls.Compound.GroupHor({}, [btOK, btCancel]));

        win.onOK = function () {
            var newValue = win.ctrlChoices.getValue();
            if (!newValue && !settings.canBeEmpty) {
                Module.ErrorBox(_TRL("Please select an option from the list."));
            } else {
                win.close();
                if (onOK) onOK(newValue);
            }
        };

        if (win.setHandler_OnPressedEnter) win.setHandler_OnPressedEnter(win.onOK);
        if (!settings.useTransientPopup) grp = Controls.Compound.StandardMargin(grp);
        win.setRootControl(grp);
        win.start();
    };

    /**
     * Creates a popup window containing an error message
     * @param {string} content - content of the error box
     * @param {string} title
     * @param {function} onProceed - called when the user closes the error box
     * @constructor
     * @returns {{}} - popup instance
     */
    Module.ErrorBox = function (content, title, onProceed) {
        if (!title) title = _TRL("Error");

        var win = Popupwin.create({
            title: title,
            blocking: true,
            autoCenter: true,
            preventClose: true
        });

        var grp1 = Controls.Compound.GroupHor({}).setSeparator(20);
        grp1.add(Controls.Static({ text: '<div style="font-size: 44px;padding:15px;display: inline-block;color:rgb(200,0,0)"><i class="fa fa-exclamation-triangle"></i></div>' }));

        var grp2 = Controls.Compound.GroupVert({});
        grp1.add(grp2);
        grp2.add(Controls.Static({ text: content + '<p/>' }));

        var btOK = Controls.Button({
            text: _TRL('Close')
            //                icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.close();
            if (onProceed) onProceed();
        });
        grp2.add(btOK);

        win.setHandler_OnPressedEnter(win.close);
        win.setRootControl(Controls.Compound.StandardMargin(grp1));
        win.start();
    };

    Module.blockingBusy_list = [];

    Module.busyWin = null;

    /**
     * Displays a busy message that blocks the entire app UI
     * @param {string} msg - message content
     * @returns {string} -  id if the busy message
     */
    Module.setBlockingBusy = function (msg) {
        var id = Utils.getUniqueID();
        Module.blockingBusy_list.push({ id: id, msg: msg });
        //console.log(JSON.stringify(Module.blockingBusy_list));
        Module.updateBusyWin();
        return id;
    };

    /**
     * Removes a blocking busy message
     * @param {string} id - id of the busy message as returned by setBlockingBusy
     */
    Module.stopBlockingBusy = function (id) {
        var idx = -1;
        $.each(Module.blockingBusy_list, function (i, data) {
            if (data.id == id) idx = i;
        });
        if (idx >= 0) {
            Module.blockingBusy_list.splice(idx, 1);
            Module.updateBusyWin();
        }
    };

    /**
     * Updates the status of the blocking busy popup(s). Internal usage only
     */
    Module.updateBusyWin = function () {
        if (!Module.busyWin && Module.blockingBusy_list.length > 0) Module.createBusyWin(Module.blockingBusy_list[0]);
        if (Module.busyWin) {
            if (Module.blockingBusy_list.length == 0) {
                Module.busyWin.close();
                Module.busyWin = null;
            } else {
                var idx = -1;
                $.each(Module.blockingBusy_list, function (i, data) {
                    if (Module.busyWin.busyId == data.id) idx = i;
                });
                if (idx < 0) {
                    Module.busyWin.close();
                    Module.createBusyWin(Module.blockingBusy_list[0]);
                }
            }
        }
    };

    /**
     * Creates a new busy popup (internal only)
     * @param data
     */
    Module.createBusyWin = function (data) {
        var win = Popupwin.create({
            blocking: true,
            blockingTransparent: true,
            autoCenterTop: true,
            preventClose: true
        });
        win.busyId = data.id;
        Module.busyWin = win;

        var grp = Controls.Compound.GroupHor({});
        var txt = '';
        txt += '<div style="padding:5px;display:inline-block;vertical-align: middle"><i class="fa fa-spinner fa-spin fa-2x"></i></div>';
        txt += '<div style="padding:5px;display:inline-block;vertical-align: middle">' + data.msg + '</div>';
        grp.add(Controls.Static({ text: txt }));

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win._fadeTime = 50;
        win.start();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(7), __webpack_require__(4), __webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Msg, DOM, Icon) {

    /**
     * Module encapsulating a class that creates a popup window in the web application's client area
     * @type {{}}
     */
    var Module = {};

    /**
     * Size of the resizing grip
     * @type {number}
     */
    Module.gripSize = 6;

    /**
     * Overlap between the sizing grip and the popup border
     * @type {number}
     */
    Module.gripOverlap = 2;

    /**
     * Length of the resizing corner grips
     * @type {number}
     */
    Module.gripCornerLength = 35;

    /**
     * Heigth of the popup header
     * @type {number}
     */
    Module.headerHeight = 36;

    /**
     * A list of all currently active windows
     * @type {Array}
     * @private
     */
    Module._activeWindows = [];

    /**
     * Returns a list of all active windows
     * @returns {Array}
     */
    Module.getActiveWindowList = function () {
        return Module._activeWindows;
    };

    Msg.listen('', 'MsgBrowserResized', function (ev) {
        $.each(Module._activeWindows, function (idx, window) {
            window.autoCorrectAfterSize(ev);
        });
    });

    /**
     * Closes all active popups
     */
    Module.closeAll = function () {
        var activeWindows = [];
        $.each(Module._activeWindows, function (idx, win) {
            activeWindows.push(win);
        });
        for (var i = activeWindows.length - 1; i >= 0; i--) {
            activeWindows[i].close();
        }
    };

    Module.docker = null;

    /**
     * Creates a new popup window
     * @param {Object} settings - Object containing the settings defining the properties of the popup
     * @param {string} settings.title - title of the popup
     * @param {string} settings.headerIcon - icon name displayed in the header
     * @param {int} settings.sizeX - default X size of the popup
     * @param {int} settings.sizeY - default Y size of the popup
     * @param {string} settings.helpID - doc id of the help text
     * @param {boolean} settings.closeOnEscape - if true, pressing the escape button closes the popup
     * @param {boolean} settings.blocking - if true, the popup blocks the content behind (= becomes inaccessible to the user, default using a semi-transparent overlay as visual hint)
     * @param {boolean} settings.blockingTransparent - if true, the blocking does not result in any visual indication
     * @param {boolean} settings.blockingOpaque - if true, the blocking renders the background completely invisible
     * @param {boolean} settings.autoCenter - if true, popup is automatically centered on the browser client area
     * @param {boolean} settings.autoCenterTop - if true, the popup is automatically horizontally centered on the browser client area, and appears on the top edge
     * @param {boolean} settings.preventClose - if true, the user cannot close the popup
     * @param {boolean} settings.minSizeX - minimum X popup size
     * @param {boolean} settings.minSizeY - minimum Y popup size
     * @param {Object} settings.labels - map with labels to be displayed
     * @returns {PopupWindow} - popup window class instance
     */
    Module.create = function (settings) {
        var window = { _id: AXMUtils.getUniqueID() };
        window.zIndex = AXMUtils.getNextZIndex();
        window._title = settings.title || '';
        window._headerIcon = settings.headerIcon || null;
        window._minSizeX = settings.minSizeX || 150;
        window._minSizeY = settings.minSizeY || 100;
        window._defaultSizeX = settings.sizeX || 500;
        window._defaultSizeY = settings.sizeY || 300;
        window._rootFrame = null; // by default, does not have a frame
        window._rootControl = null;
        window.resizable = false;
        window._blocking = settings.blocking || false;
        window._closeOnEscape = settings.closeOnEscape || false;
        window._transpBlocking = settings.blockingTransparent || false;
        window._opaqueBlocking = settings.blockingOpaque || false;
        window._autoCenter = settings.autoCenter || false;
        window._autoCenterTop = settings.autoCenterTop || false;
        window._autoCenterBottom = settings.autoCenterBottom || false;
        window._canClose = !settings.preventClose;
        window._helpID = settings.helpID;
        window._canDock = settings.canDock || false;
        window._fadeTime = 250;
        window._isLogin = settings.isLogin || false;
        window.overflowAllowed = settings.overflowAllowed || false;
        window._listeners = [];
        window._labels = settings.labels || {};

        window.setHeaderInfo = function (headerInfo) {
            window._headerInfo = headerInfo;
            window._title = headerInfo.getSingleTitle();
            window._headerIcon = headerInfo.getIcon().clone();
            window._headerIcon.setSize(1.5);
        };

        window.getHeaderInfo = function () {
            if (window._headerInfo) return window._headerInfo;else return Icon.createHeaderInfo(Icon.createEmpty(), window._title, "");
        };

        /**
         * Returns the title of the popup
         * @returns {string}
         */
        window.getTitle = function () {
            return window._title;
        };

        /**
         * Modifies the title of the popup (can be called when the popup is rendered)
         * @param {string} newTitle
         */
        window.modifyTitle = function (newTitle) {
            window._title = newTitle;
            window._$ElContainer.find('.PopupHeaderTitleText').html(newTitle);
        };

        window.modifyLabels = function (labels) {
            window._labels = labels;
            window._$ElContainer.find('.AXMPopupLabelsPlaceholder').html(window.labels.join(""));
        };

        /**
         * Defines the root frame to be displayed in the popup (popup will be window style, containing frames and will be resizeable)
         * @param {AXM.Frame} iFrame
         */
        window.setRootFrame = function (iFrame) {
            window._rootFrame = iFrame;
            iFrame.__parentWindow = window;
            window.resizable = true;
        };

        /**
         * Returns the root frame of the popup (throws an error if not present)
         * @returns {AXM.Frame}
         */
        window.getRootFrame = function () {
            if (!window._rootFrame) AXMUtils.reportBug('Popup does not have a root frame');
            return window._rootFrame;
        };

        /**
         * Defines the root control to be displayed in the popup (popup will be dialog style, containing controls and will not be resizeable)
         * @param iControl
         */
        window.setRootControl = function (iControl) {
            window._rootControl = iControl;
        };

        /**
         * Defines a handler function called when the user pressed enter in the popup
         * @param {function} hnd
         */
        window.setHandler_OnPressedEnter = function (hnd) {
            window._onPressedEnter = hnd;
        };

        /**
         * Starts the popup, making it visible in the application
         */
        window.start = function () {

            if (window._blocking) {
                var blockerid = 'blocker_' + window._id;
                var background = DOM.Div({ id: blockerid });
                background.addCssClass('AXMBlockingBackGround');
                if (window._transpBlocking) background.addCssClass('AXMBlockingBackGroundTransp');
                if (window._opaqueBlocking) background.addCssClass('AXMBlockingBackGroundOpaque');
                background.addStyle('z-index', window.zIndex - 1);
                $('.AXMContainer').append(background.toString());
                var blockerEl = $('#' + blockerid);
                blockerEl.mousedown(function (ev) {
                    if (true /*ev.target.id == 'BlockingBackGround'*/) {
                            var blockCol = blockerEl.css('background-color');
                            blockerEl.css('background-color', 'rgba(100,100,100,0.6)');
                            setTimeout(function () {
                                blockerEl.css('background-color', blockCol);
                                setTimeout(function () {
                                    blockerEl.css('background-color', 'rgba(100,100,100,0.6)');
                                    setTimeout(function () {
                                        blockerEl.css('background-color', blockCol);
                                    }, 150);
                                }, 150);
                            }, 150);
                        }
                });
            }

            if (window._blocking || window._closeOnEscape) {
                AXMUtils.addKeyDownHandler(window._onKeyDown);
            }

            var rootDiv = DOM.Div({ id: window._id });
            rootDiv.addStyle('z-index', window.zIndex);
            rootDiv.addCssClass('AXMPopupWindowContainer');
            rootDiv.addStyle('opacity', 0);
            if (window.overflowAllowed) {
                rootDiv.addStyle('overflow', 'visible');
            }

            var browserSize = AXMUtils.getBrowserSize();

            if (window.resizable) rootDiv.addStyle('width', Math.min(browserSize.sizeX, window._defaultSizeX) + 'px').addStyle('height', Math.min(browserSize.sizeY, window._defaultSizeY) + 'px');

            if (window._title) {
                var headerDiv = DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowHeader');
                if (window._headerIcon) {
                    if (AXMUtils.isObjectType(window._headerIcon, 'icon')) {
                        var iconDiv = DOM.Div({ parent: headerDiv });
                        iconDiv.addCssClass("AXMPopupHeaderIcon");
                        iconDiv.addElem(window._headerIcon.renderHtml());
                    } else {
                        var str = '<div style="display: inline-block; padding-top:4px;padding-right:16px;vertical-align: top"><i class="AXMPopupHeaderIcon fa {icon}" style=""></i></div>'.AXMInterpolate({ icon: window._headerIcon });
                        headerDiv.addElem(str);
                    }
                }

                var titleText = DOM.Div({ parent: headerDiv });
                titleText.addCssClass("PopupHeaderTitleText").addStyle("display", "inline-block").addStyle("margin-right", "20px").addStyle("overflow-x", "hidden").addStyle("text-overflow", "ellipsis").addStyle("vertical-align", "middle").addElem(window._title);

                var labelsContainer = DOM.Create("span");
                labelsContainer.addCssClass("AXMPopupLabelsPlaceholder");
                // Add labels to popup header as "badges"
                window.labels.forEach(function addBadge(badge) {
                    labelsContainer.addElem(badge);
                });
                headerDiv.addElem(labelsContainer);
            }

            var transfer$Elem = null;
            var divClient = DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowClient');
            if (window._rootFrame) {
                if (window._rootFrame.getRoot$El().length > 0) {
                    // frame already present and rendered - we move it
                    transfer$Elem = window._rootFrame.getRoot$El();
                } else divClient.addElem(window._rootFrame.createHtml());
            }
            if (window._rootControl) divClient.addElem(window._rootControl.createHtml());

            if (window.resizable) {
                divClient.addStyle('position', 'absolute');

                DOM.Div({ parent: rootDiv, id: 'GripN' }).addCssClass('AXMPopupWindowGripN');
                DOM.Div({ parent: rootDiv, id: 'GripE' }).addCssClass('AXMPopupWindowGripE');
                DOM.Div({ parent: rootDiv, id: 'GripS' }).addCssClass('AXMPopupWindowGripS');
                DOM.Div({ parent: rootDiv, id: 'GripW' }).addCssClass('AXMPopupWindowGripW');

                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripNW GripNW1');
                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripNW GripNW2');

                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripNE GripNE1');
                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripNE GripNE2');

                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripSE GripSE1');
                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripSE GripSE2');

                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripSW GripSW1');
                DOM.Div({ parent: rootDiv }).addCssClass('AXMPopupWindowGripSW GripSW2');
            }

            if (window._helpID) rootDiv.addElem('<div class="SWXPopupWindowHelpBox"><i class="fa fa-question"></i></div>');

            if (window._canClose) rootDiv.addElem('<span class="SWXPopupWindowCloseBox"><i class="fa fa-times-circle"></i></span>');

            if (Module.docker && window._canDock) rootDiv.addElem('<span class="SWXPopupWindowDockBox"><i class="fa fa-arrow-circle-left"></i></span>');

            $('.AXMContainer').append(rootDiv.toString());
            window._$ElContainer = $('#' + window._id);

            if (transfer$Elem) {
                window._$ElContainer.children('.AXMPopupWindowClient').append(transfer$Elem.detach());
            }

            if (window._autoCenter || window._autoCenterTop || window._autoCenterbottom) {
                var windowSizeX = window._$ElContainer.width();
                window._$ElContainer.css('top', 4).css('left', Math.max(0, (browserSize.sizeX - windowSizeX) / 2));
            }

            if (window._autoCenterbottom) window._$ElContainer.css('bottom', 4);

            if (window._autoCenter) {
                var windowSizeY = window._$ElContainer.height();
                window._$ElContainer.css('top', Math.max(0, (browserSize.sizeY - windowSizeY) / 2));
            }

            if (window._isLogin) {
                window._$ElContainer.css('top', 50 + '%').css('left', 50 + '%').css('margin-right', -50 + '%').css('transform', 'translate(-50%, -50%)');
            }

            if (window._rootFrame) {
                if (!transfer$Elem) window._rootFrame.attachEventHandlers();
            }
            if (window._rootControl) window._rootControl.attachEventHandlers();

            if (window.resizable) {
                window.onResize({
                    resizing: false
                });
                window.autoCorrectAfterSize();
            }

            if (window._helpID) window._$ElContainer.find('.SWXPopupWindowHelpBox').click(function () {
                __webpack_require__(23).create(window._helpID);
            });

            if (window._canClose) window._$ElContainer.find('.SWXPopupWindowCloseBox').click(function () {
                window.close();
            });

            window._$ElContainer.find('.SWXPopupWindowDockBox').click(function () {
                Module.docker(window);
            });

            window._installMoveHandler();
            window._installResizeHandlers();
            Module._activeWindows.push(window);

            window._$ElContainer.fadeTo(window._fadeTime, 1);

            if (window._blocking && !window._transpBlocking && !window._opaqueBlocking) $('#blocker_' + window._id).fadeTo(window._fadeTime, 0.5);
        };

        window.get$El = function () {
            if (!window._$ElContainer) AXMUtils.reportBug("Popup is not yet started");
            return window._$ElContainer;
        };

        Object.defineProperty(window, 'labels', {
            get: function getLabels() {
                return Object.keys(window._labels).map(function (k) {
                    var label = window._labels[k];
                    return DOM.Create("span").addCssClass(label.cssClass).addCssClass("AXMBadge").addElem(label.text);
                });
            }
        });

        /**
         * Handles the html on key down event
         * @param ev
         * @private
         */
        window._onKeyDown = function (ev) {
            if (ev.isEscape && window._canClose) window.close();
            if (ev.isEnter && window._onPressedEnter) window._onPressedEnter();
        };

        /**
         * Helper function registering handlers for moving
         * @private
         */
        window._installMoveHandler = function () {
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowHeader'), function () {
                // initialise
                window.bringToTop();
                window._tmpBrowserSize = AXMUtils.getBrowserSize();
                window._moveX0 = window._$ElContainer.position().left;
                window._moveY0 = window._$ElContainer.position().top;
                window._tmpWindowSize = {
                    sizeX: window._$ElContainer.width(),
                    sizeY: window._$ElContainer.height()
                };
            }, function (data) {
                // move
                var newPosX = window._moveX0 + data.diffTotalX;
                var newPosY = window._moveY0 + data.diffTotalY;
                newPosX = Math.min(newPosX, window._tmpBrowserSize.sizeX - window._tmpWindowSize.sizeX - 3);
                newPosY = Math.min(newPosY, window._tmpBrowserSize.sizeY - 40 /*window._tmpWindowSize.sizeY-3*/);
                newPosX = Math.max(0, newPosX);
                newPosY = Math.max(0, newPosY);
                window._$ElContainer.css('left', newPosX).css('top', newPosY);
            }, function () {// finalise

            });
        };

        /**
         * Helper function registering handlers for resizing
         * @private
         */
        window._installResizeHandlers = function () {

            var initialiseResize = function initialiseResize() {
                window.bringToTop();
                window._tmpBrowserSize = AXMUtils.getBrowserSize();
                window._resizeX0 = window._$ElContainer.position().left;
                window._resizeY0 = window._$ElContainer.position().top;
                window._resizeW0 = window._$ElContainer.width();
                window._resizeH0 = window._$ElContainer.height();
                window._oldBoxShadow = window._$ElContainer.css('box-shadow');
                window._$ElContainer.css('box-shadow', 'none');
            };

            var executeResize = function executeResize(resizeLeftX, resizeTopY, diffSizeX, diffSizeY) {

                var correctDifference = function correctDifference(diffSize, origSize, minSize, offset, maxTotSize, resizeLeft) {
                    if (!resizeLeft) diffSize = Math.min(diffSize, maxTotSize - offset - origSize - 3);else diffSize = Math.min(diffSize, offset);
                    diffSize = Math.max(diffSize, minSize - origSize);
                    return diffSize;
                };

                diffSizeX = correctDifference(diffSizeX, window._resizeW0, window._minSizeX, window._resizeX0, window._tmpBrowserSize.sizeX, resizeLeftX);
                if (resizeLeftX) window._$ElContainer.css('left', window._resizeX0 - diffSizeX);
                window._$ElContainer.width(window._resizeW0 + diffSizeX);

                diffSizeY = correctDifference(diffSizeY, window._resizeH0, window._minSizeY, window._resizeY0, window._tmpBrowserSize.sizeY, resizeTopY);
                if (resizeTopY) window._$ElContainer.css('top', window._resizeY0 - diffSizeY);
                window._$ElContainer.height(window._resizeH0 + diffSizeY);
                window.onResize({
                    resizing: true
                });
            };

            var finaliseResize = function finaliseResize(newSizeX, newSizeY) {
                window._$ElContainer.css('box-shadow', window._oldBoxShadow);
                window.onResize({
                    resizing: false
                });
            };

            //------N-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripN'), initialiseResize, function (data) {
                executeResize(false, true, 0, -data.diffTotalY);
            }, finaliseResize);

            //------E-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripE'), initialiseResize, function (data) {
                executeResize(false, false, data.diffTotalX, 0);
            }, finaliseResize);

            //------S-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripS'), initialiseResize, function (data) {
                executeResize(false, false, 0, data.diffTotalY);
            }, finaliseResize);

            //------W-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripW'), initialiseResize, function (data) {
                executeResize(true, false, -data.diffTotalX, 0);
            }, finaliseResize);

            //------NW-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripNW'), initialiseResize, function (data) {
                executeResize(true, true, -data.diffTotalX, -data.diffTotalY);
            }, finaliseResize);

            //------NE-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripNE'), initialiseResize, function (data) {
                executeResize(false, true, data.diffTotalX, -data.diffTotalY);
            }, finaliseResize);

            //------SE-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripSE'), initialiseResize, function (data) {
                executeResize(false, false, data.diffTotalX, data.diffTotalY);
            }, finaliseResize);

            //------SW-------
            AXMUtils.create$ElDragHandler(window._$ElContainer.find('.AXMPopupWindowGripSW'), initialiseResize, function (data) {
                executeResize(true, false, -data.diffTotalX, data.diffTotalY);
            }, finaliseResize);
        };

        window.bubbleMessage = function (msgId, msgContent) {
            if (msgId == "Activated") window.bringToTop();
        };

        /**
         * Registers a message listening callback handler that lives as long as the popup lives
         * @param msgId
         * @param callbackFunction
         */
        window.listen = function (msgId, callbackFunction) {
            var eventid = AXMUtils.getUniqueID();
            window._listeners.push(eventid);
            Msg.listen(eventid, msgId, callbackFunction);
        };

        window._verifyCanClose = function () {
            return true;
        };

        /**
         * Sets a callback that is executed if the popup is about to close. if the callback returns false, the popup is not closed
         * @param {function} handler
         */
        window.setVerifyCanClose = function (handler) {
            window._verifyCanClose = handler;
        };

        /**
         * Closes the popup
         */
        window.close = function (doNotRemoveFrame) {
            if (!doNotRemoveFrame) {
                if (!window._verifyCanClose()) return;

                if (window._rootFrame) {
                    var closePreventReason = window._rootFrame._getAnyClosePreventReason();
                    if (closePreventReason) {
                        alert('Cannot close: ' + closePreventReason);
                        return;
                    }
                    window._rootFrame.detachEventHandlers();
                    window._rootFrame.informWillClose();
                }

                if (window._rootControl) window._rootControl.detachEventHandlers();
            }

            $.each(window._listeners, function (idx, eventid) {
                Msg.delListener(eventid);
            });
            window._listeners = [];

            if (window._blocking) {
                if (!window._transpBlocking && !window._opaqueBlocking) $('#blocker_' + window._id).fadeTo(window._fadeTime, 0.0, function () {
                    $('#blocker_' + window._id).remove();
                });else $('#blocker_' + window._id).remove();
            }

            AXMUtils.removeKeyDownHandler(window._onKeyDown);

            window._$ElContainer.fadeTo(window._fadeTime, 0, function () {
                window._$ElContainer.remove();
                var winNr = -1;
                $.each(Module._activeWindows, function (idx, win) {
                    if (window._id == win._id) winNr = idx;
                });
                if (winNr >= 0) Module._activeWindows.splice(winNr, 1);
            });
        };

        /**
         * Brings the popup to the top of the z-order of elements
         */
        window.bringToTop = function () {
            var isOnTop = true;
            $.each(Module._activeWindows, function (idx, win) {
                if (window._id != win._id && window.zIndex <= win.zIndex) isOnTop = false;
            });
            window.zIndex = AXMUtils.getNextZIndex();
            window._$ElContainer.css('z-index', window.zIndex);
        };

        /**
         * Handles popup resizing events
         * @param params
         */
        window.onResize = function (params) {
            var sizeX = window._$ElContainer.width();
            var sizeY = window._$ElContainer.height();
            var clientSizeX = sizeX;
            var clientSizeY = sizeY - Module.headerHeight;

            window._$ElContainer.find('.AXMPopupWindowClient').css({
                width: clientSizeX + 'px',
                height: clientSizeY + 'px',
                top: Module.headerHeight + 'px'
            });

            if (window._rootFrame) {
                window._rootFrame.setPosition(0, 0, clientSizeX, clientSizeY, params);
            }

            //--------N resize grip----------
            window._$ElContainer.find('#GripN').css({
                left: 0,
                top: -Module.gripSize + Module.gripOverlap,
                width: sizeX,
                height: Module.gripSize
            });

            //--------E resize grip----------
            window._$ElContainer.find('#GripE').css({
                left: sizeX - Module.gripOverlap,
                top: 0,
                width: Module.gripSize,
                height: sizeY
            });

            //--------S resize grip----------
            window._$ElContainer.find('#GripS').css({
                left: 0,
                top: sizeY - Module.gripOverlap,
                width: sizeX,
                height: Module.gripSize
            });

            //--------W resize grip----------
            window._$ElContainer.find('#GripW').css({
                left: -Module.gripSize + Module.gripOverlap,
                top: 0,
                width: Module.gripSize,
                height: sizeY
            });

            //--------NW resize grip----------
            window._$ElContainer.find('.GripNW1').css({
                left: -Module.gripSize + Module.gripOverlap,
                top: -Module.gripSize + Module.gripOverlap,
                width: Module.gripSize,
                height: Module.gripCornerLength
            });
            window._$ElContainer.find('.GripNW2').css({
                left: -Module.gripSize + Module.gripOverlap,
                top: -Module.gripSize + Module.gripOverlap,
                width: Module.gripCornerLength,
                height: Module.gripSize
            });

            //--------NE resize grip----------
            window._$ElContainer.find('.GripNE1').css({
                left: sizeX - Module.gripOverlap,
                top: -Module.gripSize + Module.gripOverlap,
                width: Module.gripSize,
                height: Module.gripCornerLength
            });

            window._$ElContainer.find('.GripNE2').css({
                left: sizeX - Module.gripCornerLength + Module.gripSize - Module.gripOverlap,
                top: -Module.gripSize + Module.gripOverlap,
                width: Module.gripCornerLength,
                height: Module.gripSize
            });

            //--------SE resize grip----------
            window._$ElContainer.find('.GripSE1').css({
                left: sizeX - Module.gripOverlap,
                top: sizeY - Module.gripCornerLength + Module.gripSize - Module.gripOverlap,
                width: Module.gripSize,
                height: Module.gripCornerLength
            });

            window._$ElContainer.find('.GripSE2').css({
                left: sizeX - Module.gripCornerLength + Module.gripSize - Module.gripOverlap,
                top: sizeY - Module.gripOverlap,
                width: Module.gripCornerLength,
                height: Module.gripSize
            });

            //--------SW resize grip----------
            window._$ElContainer.find('.GripSW1').css({
                left: -Module.gripSize + Module.gripOverlap,
                top: sizeY - Module.gripCornerLength + Module.gripSize - Module.gripOverlap,
                width: Module.gripSize,
                height: Module.gripCornerLength
            });

            window._$ElContainer.find('.GripSW2').css({
                left: -Module.gripSize + Module.gripOverlap,
                top: sizeY - Module.gripOverlap,
                width: Module.gripCornerLength,
                height: Module.gripSize
            });
        };

        /**
         * Automatically corrects html elements after resizing
         */
        window.autoCorrectAfterSize = function () {
            if (!window.resizable) return;

            var browserSize = AXMUtils.getBrowserSize();

            var correctSize = function correctSize(currentSize, minSize, currentOffset, maxTotSize) {
                if (currentOffset + currentSize > maxTotSize) {
                    currentOffset = Math.max(0, maxTotSize - currentSize);
                    currentSize = Math.max(minSize, Math.min(currentSize, maxTotSize));
                }
                return {
                    size: currentSize,
                    offset: currentOffset
                };
            };

            var offsetX = window._$ElContainer.position().left;
            var offsetY = window._$ElContainer.position().top;
            var sizeX = window._$ElContainer.width();
            var sizeY = window._$ElContainer.height();
            var correctedX = correctSize(sizeX, window._minSizeX, offsetX, browserSize.sizeX);
            var correctedY = correctSize(sizeY, window._minSizeY, offsetY, 99999 /*browserSize.sizeY*/);
            window._$ElContainer.css('left', correctedX.offset).css('top', correctedY.offset);
            if (correctedX.size != sizeX || correctedY.size != sizeY) {
                window._$ElContainer.width(correctedX.size);
                window._$ElContainer.height(correctedY.size);
                window.onResize({});
            }
        };

        return window;
    };

    $(document).bind("mousedown.popups", function (ev) {
        if (ev.target) {
            var clicked$El = $(ev.target);
            if (clicked$El.length < 1) return;
            $.each(Module._activeWindows, function (idx, window) {
                if (window._$ElContainer[0] == clicked$El[0] || $.contains(window._$ElContainer[0], clicked$El[0])) {
                    window.bringToTop();
                }
            });
        }
    });

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Test) {

    /**
     * Module encapsulating functionality to send and receive messages
     * @type {{}}
     */
    var Msg = {};

    Msg._listeners = [];
    Msg._listeneridmap = {};

    /**
     * Broadcasts a message (does not put any constraints on the number of recipients receiving the message)
     * @param {string} msgId - message ID
     * @param {{}} content - message content
     * @returns {Array} - results returned by each recipient
     */
    Msg.broadcast = function (msgId, content) {
        var results = [];
        for (var lnr = 0; lnr < Msg._listeners.length; lnr++) {
            if (Msg._listeners[lnr] != null) {
                if (msgId == Msg._listeners[lnr].msgId) {
                    var result = Msg._listeners[lnr].callbackFunction(content);
                    results.push(result);
                }
            }
        }
        return results;
    };

    /**
     * Sends a message (requires the message to be received by exactly one recipient)
     * @param {string} msgId - message ID
     * @param {{}} content - message content
     * @returns {*} - result returned by recipient
     */
    Msg.send = function (msgId, content) {
        var results = Msg.broadcast(msgId, content);
        var receiverCount = results.length;
        if (receiverCount > 1) Test.reportBug("Message was processed by more than one recipient");
        if (receiverCount == 0) Test.reportBug("Message was not processed by any recipient");
        return results[0];
    };

    /**
     * Subscribes to a specific message
     * @param {string} eventid - id of this subscription (can be empty)
     * @param {string} msgId - message ID to listen to
     * @param {function} callbackFunction - called when the message was sent
     */
    Msg.listen = function (eventid, msgId, callbackFunction) {
        if (typeof eventid !== 'string' && eventid !== null) Test.reportBug('Listener event id not provided');
        if (!msgId) Test.reportBug("No event ID provided");
        if (!callbackFunction) Test.reportBug('No callback function provided for event listener');
        if (eventid != '' && eventid in Msg._listeneridmap) {
            var idx = Msg._listeneridmap[eventid];
            Msg._listeners[idx].msgId = msgId;
            Msg._listeners[idx].callbackFunction = callbackFunction;
            return;
        }
        if (eventid) Msg._listeneridmap[eventid] = Msg._listeners.length;
        Msg._listeners.push({ eventid: eventid, msgId: msgId, callbackFunction: callbackFunction });
    };

    /**
     * Removes a subscription
     * @param {string} eventid - id of the subscription
     */
    Msg.delListener = function (eventid) {
        if (eventid in Msg._listeneridmap) {
            var idx = Msg._listeneridmap[eventid];
            Msg._listeners[idx] = null;
            delete Msg._listeneridmap[eventid];
        }
    };

    return Msg;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(12), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Test, AXMUtils) {

    /**
     * Module encapsulating an RGB color class
     * @type {{}}
     */
    var Module = {};

    /**
     * Returns an rgb color class
     * @param {float} r - red value (range: 0-1)
     * @param {float} g - green value (range: 0-1)
     * @param {float} b - blue value (range: 0-1)
     * @param {float} a - opacity value (range: 0-1)
     * @returns {{}} - color class instance
     * @constructor
     */
    Module.Color = function (r, g, b, a) {
        var that = AXMUtils.object("@Color");
        that.r = typeof r == 'undefined' ? 0 : r;
        that.g = typeof g == 'undefined' ? 0 : g;
        that.b = typeof b == 'undefined' ? 0 : b;
        that.a = typeof a == 'undefined' ? 1 : a;
        that.f = 1.0;

        /**
         * Returns the red component
         * @returns {number}
         */
        that.getR = function () {
            return this.r / this.f;
        };
        /**
         * Returns the green component
         * @returns {number}
         */
        that.getG = function () {
            return this.g / this.f;
        };
        /**
         * Returns the blue component
         * @returns {number}
         */
        that.getB = function () {
            return this.b / this.f;
        };
        /**
         * Returns the opacity component
         * @returns {number}
         */
        that.getA = function () {
            return this.a / this.f;
        };

        /**
         * Returns a html string representing the color
         * @returns {string}
         */
        that.toString = function () {
            if (this.a > 0.999) return 'rgb(' + Math.round(this.getR() * 255) + ',' + Math.round(this.getG() * 255) + ',' + Math.round(this.getB() * 255) + ')';else return 'rgb(' + this.getR().toFixed(3) + ',' + this.getG().toFixed(3) + ',' + this.getB().toFixed(3) + ',' + this.getA().toFixed(3) + ')';
        };

        /**
         * Returns a html string representing the color, usable in a html5 canvas element
         * @returns {string}
         */
        that.toStringCanvas = function () {
            if (this.a > 0.999) return 'rgb(' + Math.round(this.getR() * 255) + ',' + Math.round(this.getG() * 255) + ',' + Math.round(this.getB() * 255) + ')';else return 'rgba(' + Math.round(this.getR() * 255) + ',' + Math.round(this.getG() * 255) + ',' + Math.round(this.getB() * 255) + ',' + this.getA().toFixed(3) + ')';
        };

        /**
         * Returns a color string using HEX notation
         * @returns {string}
         */
        that.toStringHEX = function () {

            function componentToHex(c) {
                var hex = c.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            }
            return "#" + componentToHex(Math.round(this.getR() * 255)) + componentToHex(Math.round(this.getG() * 255)) + componentToHex(Math.round(this.getB() * 255));
        };

        /**
         * Determines if the color is black
         * @returns {boolean}
         */
        that.isBlack = function () {
            return that.r < 1.0e-9 && that.g < 1.0e-9 && that.b < 1.0e-9;
        };

        /**
         * Returns a darkened version of the color, amount between 0 and 1
         * @param {float} amount
         * @returns {AXM.Color}
         */
        that.darken = function (amount) {
            var fc = 1.0 - amount;
            return Module.Color(fc * this.r, fc * this.g, fc * this.b, this.a);
        };

        /**
         * Returns a lightened version of the color, amount between 0 and 1
         * @param {float} amount
         * @returns {AXM.Color}
         */
        that.lighten = function (amount) {
            var fc = amount;
            return Module.Color((1 - fc) * this.r + fc, (1 - fc) * this.g + fc, (1 - fc) * this.b + fc, this.a);
        };

        that.deSaturate = function (amount) {
            var av = (this.r + this.g + this.b) / 3.0;
            var fc = amount;
            return Module.Color((1 - fc) * this.r + fc * av, (1 - fc) * this.g + fc * av, (1 - fc) * this.b + fc * av, this.a);
        };

        /**
         * Returns a version of the color with a new opacity
         * @param {float} opacity
         * @returns {AXM.Color}
         */
        that.changeOpacity = function (opacity) {
            return Module.Color(this.getR(), this.getG(), this.getB(), opacity);
        };

        return that;
    };

    /**
     * Converts HSL to a color object
     * @param {float} h - hue (range: 0-1)
     * @param {float} s - saturation (range: 0-1)
     * @param {float} l - lightness (range: 0-1)
     * @returns {AXM.Color}
     * @constructor
     */
    Module.HSL2Color = function (h, s, l) {
        var r, g, b;
        if (s == 0) {
            r = g = b = l; // achromatic
        } else {
            var hue2rgb = function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return Module.Color(r, g, b);
    };

    /**
     * converts a html color string to a Module.Color
     * @param {string} colorstring
     * @param {AXM.Color} faildefault - color to return in case conversion fails
     * @returns {AXM.Color}
     */
    Module.parseColorString = function (colorstring, faildefault) {
        try {
            var parts = colorstring.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (parts && parts.length >= 2 && parts[1].length > 0 && parts[2].length > 0 && parts[3].length > 0) return Module.Color(parseFloat(parts[1]) / 255.0, parseFloat(parts[2]) / 255.0, parseFloat(parts[3]) / 255.0);
            if (typeof faildefault != 'undefined') return faildefault;
            return Module.Color(0, 0, 0);
        } catch (err) {
            Test.reportBug('Invalid color string: ' + colorstring);
        }
    };

    /**
     * Returns an rgb color class
     * @param {string} hex - color in hexadecimal notation
     * @param {float} opacity - opacity value (range: 0-1)
     */
    Module.parseHexString = function (hex, opacity) {
        var h = hex.replace('#', '');
        opacity = typeof opacity !== 'undefined' ? opacity : 1;
        h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));

        for (var i = 0; i < h.length; i++) {
            h[i] = parseInt(h[i].length == 1 ? h[i] + h[i] : h[i], 16);
        }h.push(opacity);

        return Module.Color(h[0] / 255, h[1] / 255, h[2] / 255.0, h[3]);
    };

    /**
     * A list of commonly used standard colors
     * @type {[AXM.Color]}
     */
    Module.standardColors = [Module.Color(0.2, 0.2, 1.0), Module.Color(1.0, 0.3, 0.3), Module.Color(0.2, 0.7, 0.4), Module.Color(0.9, 0.5, 0.0), Module.Color(0.0, 0.8, 0.0), Module.Color(0.8, 0.2, 0.8), Module.Color(0, 0, 0.7), Module.Color(0.7, 0, 0), Module.Color(0, 0.5, 0), Module.Color(0.5, 0, 0.5), Module.Color(0.3, 0.4, 0.5), Module.Color(0.5, 0.5, 0.8), Module.Color(0.8, 0.5, 0.5), Module.Color(0.7, 0.6, 0.4), Module.Color(0.4, 0.7, 0.4), Module.Color(0.3, 0.3, 0.5), Module.Color(0.5, 0.3, 0.3), Module.Color(0.5, 0.4, 0.2), Module.Color(0.2, 0.4, 0.2), Module.Color(0.5, 0.3, 0.5), Module.Color(0.3, 0.5, 0.5), Module.Color(0.6, 0.6, 0.7), Module.Color(0.7, 0.6, 0.6), Module.Color(0.7, 0.7, 0.5), Module.Color(0.7, 0.5, 0.7), Module.Color(0.5, 0.7, 0.7), Module.Color(0.5, 0.6, 0.5), Module.Color(0.6, 0.6, 0.6)];

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils) {

    var Module = {};

    Module.typeGeneric = function (id) {
        var tpe = {
            id: id,
            isString: function isString() {
                return false;
            },
            isCategorical: function isCategorical() {
                return false;
            },
            parseString: function parseString(str) {
                return str;
            },
            getName: function getName() {
                return 'GenericType';
            }
        };
        tpe.getId = function () {
            return tpe.id;
        };
        return tpe;
    };

    Module.typeString = Module.typeGeneric('typeString');
    Module.typeString.includes = function (otherType) {
        return otherType.id == 'typeString';
    };
    Module.typeString.isString = function () {
        return true;
    };
    Module.typeString.isCategorical = function () {
        return true;
    };
    Module.typeString.getName = function () {
        return 'Text';
    };

    Module.typeBoolean = Module.typeGeneric('typeBoolean');
    Module.typeBoolean.includes = function (otherType) {
        return otherType.id == 'typeBoolean';
    };
    Module.typeBoolean.isCategorical = function () {
        return true;
    };
    Module.typeBoolean.parseString = function (str) {
        if (str.toLowerCase() === 'true') return true;
        if (str.toLowerCase() === 'false') return false;
        return null;
    };
    Module.typeBoolean.getName = function () {
        return 'Boolean';
    };

    Module.typeFloat = Module.typeGeneric('typeFloat');
    Module.typeFloat.includes = function (otherType) {
        return otherType.id == 'typeFloat';
    };
    Module.typeFloat.parseString = function (str) {
        if (str == null || str == '') return null;
        return parseFloat(str);
    };
    Module.typeFloat.getName = function () {
        return 'Value';
    };

    Module.typeAny = Module.typeGeneric('typeAny');
    Module.typeAny.includes = function (otherType) {
        return true;
    };

    Module.typeAnyCategorical = Module.typeGeneric('typeAnyCategorical');
    Module.typeAnyCategorical.includes = function (otherType) {
        return otherType.isCategorical();
    };

    Module.typesMap = {
        typeFloat: Module.typeFloat,
        typeString: Module.typeString,
        typeBoolean: Module.typeBoolean
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(3), __webpack_require__(22), __webpack_require__(4), __webpack_require__(7), __webpack_require__(48)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Controls, ControlsCompound, DOM, Msg, FrameToolBox) {

    /**
     * Module implementing frame classes, used to organise web application client area in smaller components
     * @type {{}}
     */
    var Module = {};

    Module.ToolBox = FrameToolBox;

    /**
     * The height of a frame title bar
     * @type {number}
     */
    Module.titleBarH = 25;

    /**
     * Index of the X dimension, used in 2D properties
     * @type {number}
     */
    Module.dimX = 0;

    /**
     * Index of the Y dimension, used in 2D properties
     * @type {number}
     */
    Module.dimY = 1;

    /**
     * Verifies that a dimension is valid. throws an exception if not
     * @param {int} dim - dimension
     */
    Module.checkValidDim = function (dim) {
        if (dim !== Module.dimX && dim !== Module.dimY) AXMUtils.reportBug("Invalid dimension ID");
    };

    /**
     * Creates a helper class object that contains information and functionality about the range of possible sizes an object can have in a single dimension
     * @returns {Object} - object instance
     * @constructor
     */
    Module.dimSizeInfo = function () {
        var sizeInfo = AXMUtils.object('@FrameDimSizeInfo');
        sizeInfo._min = 120;
        sizeInfo._max = 999999;
        sizeInfo._autoSize = false;

        /**
         * Sets the minimum size
         * @param {int} sz
         * @returns {Object} - self
         */
        sizeInfo.setMinSize = function (sz) {
            sizeInfo._min = sz;
            return sizeInfo;
        };

        /**
         * Sets the size to be fixed
         * @param {int} sz - fixed size
         * @returns {Object} - self
         */
        sizeInfo.setFixedSize = function (sz) {
            sizeInfo._min = sz;
            sizeInfo._max = sz;
            return sizeInfo;
        };

        /**
         * Defines the size as being determined automatically
         * @returns {Object} - self
         */
        sizeInfo.setAutoSize = function () {
            sizeInfo._min = 0;
            sizeInfo._autoSize = true;
            return sizeInfo;
        };

        /**
         * Determines if the size if fixed
         * @returns {boolean}
         * @private
         */
        sizeInfo._isFixedSize = function () {
            if (sizeInfo._autoSize) return true;
            return sizeInfo._max == sizeInfo._min;
        };

        /**
         * Returns the minimum size
         * @returns {int}
         * @private
         */
        sizeInfo._getMinSize = function () {
            return sizeInfo._min;
        };

        /**
         * Returns the maximum size
         * @returns {int}
         * @private
         */
        sizeInfo._getMaxSize = function () {
            return sizeInfo._max;
        };

        /**
         * Determines if the size is set to be automatic
         * @returns {boolean}
         */
        sizeInfo.isAutoSize = function () {
            return sizeInfo._autoSize;
        };

        return sizeInfo;
    };

    /**
     * Base class implementing a frame
     * @returns {Object} - frame instance
     * @constructor
     */
    Module.FrameGeneric = function () {
        var frame = AXMUtils.object("@Frame");
        frame._parentFrame = null;
        frame._id = 'FR' + AXMUtils.getUniqueID();
        frame._sizeFraction = 1;
        frame._hasTitle = false;
        frame._title = '';
        frame._sizeInfos = [Module.dimSizeInfo(), Module.dimSizeInfo()]; //allowed frame size range in X and Y dimension
        frame.splitterColor = null;
        frame._tearDownHanders = []; //List of functions that will be called when the frame isa about to be removed
        frame._listeners = [];
        frame._toolBox = null;

        /**
         * Returns the unique identifier of the frame
         * @returns {string}
         */
        frame.getId = function () {
            return frame._id;
        };

        /**
         * Returns the ID of the DIV containing the frame title
         * @returns {string}
         */
        frame.getTitleDivId = function () {
            return frame._id + '_title';
        };

        /**
         * Sets the relative size of the frame with respect to its siblings, used in case the frame is member of a parent frame that groups its members horizontally or vertically
         * @param {float} fr - relative size
         * @returns {Object} - self
         */
        frame.setSizeFraction = function (fr) {
            AXMUtils.Test.checkIsNumber(fr);
            frame._sizeFraction = fr;
            return frame;
        };

        /**
         * Returns the relative size of the frame with respect to its siblings, used in case the frame is member of a parent frame that groups its members horizontally or vertically
         * @returns {float}
         */
        frame.getSizeFraction = function () {
            return frame._sizeFraction;
        };

        /**
         * Returns the help documentation id associated with this frame (null if none). To be overridden
         * @returns {string}
         */
        frame.getHelpId = function () {
            return null;
        };

        /**
         * Sets the title of the frame
         * @param {string} iTitle
         * @returns {Object} - self
         */
        frame.setTitle = function (iTitle) {
            AXMUtils.Test.checkIsString(iTitle);
            frame._hasTitle = true;
            frame._title = iTitle;
            return frame;
        };

        /**
         * Determines if the frame has a title bar
         * @returns {boolean}
         */
        frame.hasTitleBar = function () {
            if (!frame._hasTitle) return false;
            if (frame._parentFrame && frame._parentFrame.isTabber()) return false;
            return true;
        };

        /**
         * Returns the title of the frame
         * @returns {string}
         */
        frame.getTitle = function () {
            return frame._title;
        };

        frame.setToolBox = function (toolBox) {
            if (frame._toolBox) AXMUtils.reportBug("Frame already has a toolbox");
            frame._toolBox = toolBox;
            frame._toolBox._frame = frame;
        };

        /**
         * Adds a new function that will be called when the frame is about to be removed
         * @param func
         */
        frame.addTearDownHandler = function (func) {
            frame._tearDownHanders.push(func);
        };

        /**
         * Registers a message listening callback handler that lives as long as the frame lives
         * @param msgId
         * @param callbackFunction
         */
        frame.listen = function (msgId, callbackFunction) {
            var eventid = AXMUtils.getUniqueID();
            frame._listeners.push(eventid);
            Msg.listen(eventid, msgId, callbackFunction);
        };

        /**
         * Determines if the frame is a compound frame, and groups its members as tabs (to be overriden in derived classes)
         * @returns {boolean}
         */
        frame.isTabber = function () {
            return false;
        };

        /**
         * Specifies the minimum size of the frame in a dimension
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @param {int} sze - size
         * @returns {Object} - self
         */
        frame.setMinDimSize = function (dim, sze) {
            Module.checkValidDim(dim);
            AXMUtils.Test.checkIsNumber(sze);
            frame._sizeInfos[dim].setMinSize(sze);
            return frame;
        };

        /**
         * Defines a dimension as automatically scaled
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @returns {Object} - self
         */
        frame.setAutoSize = function (dim) {
            Module.checkValidDim(dim);
            frame._sizeInfos[dim].setAutoSize();
            return frame;
        };

        /**
         * Defines a dimension as being fixed in size
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @param {int} sz - fixed size
         * @returns {Object} - self
         */
        frame.setFixedDimSize = function (dim, sz) {
            Module.checkValidDim(dim);
            AXMUtils.Test.checkIsNumber(sz);
            frame._sizeInfos[dim].setFixedSize(sz);
            return frame;
        };

        /**
         * In case the frame is scaled automatically along a dimension, returns its computed size
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @returns {int} - size
         * @private
         */
        frame._getAutoSize = function (dim) {
            Module.checkValidDim(dim);
            var sze = frame._getClientAutoSize(dim);
            return sze;
        };

        /**
         * Returns the minimum frame size along a dimension
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @returns {int} - minumum size
         * @private
         */
        frame._getMinSize = function (dim) {
            Module.checkValidDim(dim);
            if (frame._sizeInfos[dim].isAutoSize()) return frame._getAutoSize(dim);
            return Math.max(frame._sizeInfos[dim]._getMinSize(), frame._getClientMinSize(dim));
        };

        /**
         * Returns the minumum size of the client area of a frame
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @returns {number} - minimum client size
         * @private
         */
        frame._getClientMinSize = function (dim) {
            return 0;
        };

        /**
         * Returns the maximum frame size along a dimension
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @returns {Number}
         * @private
         */
        frame._getMaxSize = function (dim) {
            Module.checkValidDim(dim);
            if (frame._sizeInfos[dim].isAutoSize()) return frame._getAutoSize(dim);
            return frame._sizeInfos[dim]._getMaxSize();
        };

        frame.getRoot$El = function () {
            return $('#' + frame._id);
        };

        /**
         * Returns the html implementing thee frame
         * @returns {string}
         */
        frame.createHtml = function () {
            var frameDiv = DOM.Div({ id: frame._id });
            frameDiv.addCssClass('AXMFrame');
            if (frame.hasTitleBar()) DOM.Div({ parent: frameDiv, id: frame.getTitleDivId() }).addCssClass('AXMFrameTitle').addElem(frame._title);
            var frameClient = DOM.Div({ parent: frameDiv }).addCssClass('AXMFrameClient');
            if (frame.createHtmlClient) frameClient.addElem(frame.createHtmlClient());

            return frameDiv.toString();
        };

        frame.updateHtml = function () {
            if (frame.createHtmlClient) {
                var content = frame.createHtmlClient();
                frame.$ElContainer.children('.AXMFrameClient').html(content);
            }
        };

        /**
         * Attached the html handlers to after DOM insertion
         */
        frame.attachEventHandlers = function (params) {
            frame.$ElContainer = $('#' + frame._id);
            if (frame._toolBox) {
                frame._toolBox.start();
            }
        };

        /**
         * Detach the html handlers
         */
        frame.detachEventHandlers = function () {};

        /**
         * Automatically pdates the positioning of the frame, including the client area content
         */
        frame.updatePosition = function () {
            var _digest = function _digest(vl) {
                if (vl.indexOf('px', vl.length - 2) >= 0) return parseInt(vl.substring(0, vl.length - 2));else return parseInt(vl);
            };
            var x0 = _digest(frame.$ElContainer.css('left'));
            var y0 = _digest(frame.$ElContainer.css('top'));
            var xl = _digest(frame.$ElContainer.css('width'));
            var yl = _digest(frame.$ElContainer.css('height'));
            frame.setPosition(x0, y0, xl, yl, {});
        };

        /**
         * Changes the positioning of the frame
         * @param {int} x0 - left x position
         * @param {int} y0 - top y position
         * @param {int} xl - x width
         * @param {int} yl - y width
         */
        frame.setPosition = function (x0, y0, xl, yl, params) {
            AXMUtils.Test.checkIsNumber(x0, y0, xl, yl);
            frame.$ElContainer.css('left', x0 + 'px');
            frame.$ElContainer.css('top', y0 + 'px');
            frame.$ElContainer.css('width', xl + 'px');
            frame.$ElContainer.css('height', yl + 'px');
            frame._clientVOffset = 0;
            if (frame.hasTitleBar()) {
                $('#' + frame.getTitleDivId()).outerWidth(xl).outerHeight(Module.titleBarH);
                frame._clientVOffset += Module.titleBarH;
            }
            frame.$ElContainer.children('.AXMFrameClient').css({
                left: '0px',
                top: frame._clientVOffset + 'px',
                width: xl + 'px',
                height: yl - frame._clientVOffset + 'px'
            });
            if (frame.setPositionClient) {
                frame.setPositionClient(xl, yl - frame._clientVOffset, params);
                //setTimeout(function() {
                //    frame.setPositionClient(xl, yl-frame._clientVOffset, params);
                //}, 10);
            }
        };

        frame.bubbleMessage = function (msgId, msgContent) {
            if (frame._parentFrame) frame._parentFrame.bubbleMessage(msgId, msgContent);else {
                if (frame.__parentWindow) frame.__parentWindow.bubbleMessage(msgId, msgContent);
            }
        };

        /**
         * Activates a specific panel in the hierarchical frame structure (used for tabbed containers). to be implemented in derived classes
         * @param panelTypeId
         * @returns {boolean}
         */
        frame.activatePanelTypeId = function (panelTypeId) {
            //in general: do nothing
            return false;
        };

        /**
         * If a frame cannot be closed, returns a reason why not. This calls getClosePreventReason for the current frame and any of its members
         * @param msg
         * @returns {string}
         * @private
         */
        frame._getAnyClosePreventReason = function (msg) {
            return frame.getClosePreventReason(msg);
        };

        /**
         * If a frame cannot be closed, returns a reason why not. override in derived classes
         * @param msg
         * @returns {string}
         */
        frame.getClosePreventReason = function (msg) {
            return null;
        };

        frame._executeTearDownHandlers = function () {
            $.each(frame._listeners, function (idx, eventid) {
                Msg.delListener(eventid);
            });
            frame._listeners = [];
            $.each(frame._tearDownHanders, function (idx, handler) {
                handler();
            });
            frame._tearDownHanders = [];
        };

        /**
         * Call this function to inform the frame or any of its members that it will close
         * @param msg
         */
        frame.informWillClose = function (msg) {
            frame._executeTearDownHandlers();
            frame.willClose();
        };

        /**
         * Called when the frame is about to close. override in derived classes
         * @param msg
         */
        frame.willClose = function (msg) {};

        return frame;
    };

    /**
     * Base class implementing the behaviour of a compound frame (i.e. a frame grouping member frames)
     * @returns {Object} - object instance
     * @constructor
     */
    Module.FrameCompound = function () {
        var frame = Module.FrameGeneric();
        frame._memberFrames = [];

        /**
         * Adds a new member frame
         * @param {Module.Frame} memberFrame
         * @returns {Module.Frame} - member frame
         */
        frame.addMember = function (memberFrame) {
            AXMUtils.Test.checkIsType(memberFrame, '@Frame');
            frame._memberFrames.push(memberFrame);
            memberFrame._parentFrame = frame;
            return memberFrame;
        };

        /**
         * Returns the number of member frames
         * @returns {int}
         */
        frame.getmemberFrameCount = function () {
            return frame._memberFrames.length;
        };

        var _super_attachEventHandlers = frame.attachEventHandlers;
        /**
         * Attached the html event handlers after DOM insertion
         */
        frame.attachEventHandlers = function (params) {
            _super_attachEventHandlers(params); // calls the implementation of the parent class
            $.each(frame._memberFrames, function (idx, memberFrame) {
                memberFrame.attachEventHandlers(params);
            });
        };

        var _super_detachEventHandlers = frame.detachEventHandlers;
        /**
         * Detach the html event handlers
         */
        frame.detachEventHandlers = function () {
            _super_detachEventHandlers(); // calls the implementation of the parent class
            $.each(frame._memberFrames, function (idx, memberFrame) {
                memberFrame.detachEventHandlers();
            });
        };

        /**
         * Activates an individual panel inside the hierarchical frame structure
         * @param {string} panelTypeId - ID of the panel
         * @returns {boolean} - determines whether or not the panel was found
         */
        frame.activatePanelTypeId = function (panelTypeId) {
            var found = false;
            $.each(frame._memberFrames, function (idx, memberFrame) {
                if (memberFrame.activatePanelTypeId(panelTypeId)) found = true;
            });
            return found;
        };

        frame._getAnyClosePreventReason = function (msg) {
            var rs = frame.getClosePreventReason(msg);
            if (rs) return rs;
            $.each(frame._memberFrames, function (idx, memberFrame) {
                rs = memberFrame._getAnyClosePreventReason(msg);
                if (rs) return rs;
            });
            return null;
        };

        frame.informWillClose = function (msg) {
            frame._executeTearDownHandlers();
            if (frame._toolBox) frame._toolBox.close();
            frame.willClose();
            $.each(frame._memberFrames, function (idx, memberFrame) {
                memberFrame.informWillClose(msg);
            });
        };

        return frame;
    };

    /**
     * Implements a compound frame that organises member frame by aligning them horizontally or vertically, with splitters between them
     * @param {int} dim - splitter dimenion (can be Module.dimX or Module.dimY)
     * @returns {Object} - object instance
     * @constructor
     */
    Module.FrameSplitter = function (dim) {
        var frame = Module.FrameCompound();
        Module.checkValidDim(dim);
        frame._dim = dim;
        frame._hSplitterSize = 2;

        /**
         * Defines half the size of the splitters between the member frames
         * @param {int} hSize
         * @returns {Object} - self
         */
        frame.setHalfSplitterSize = function (hSize) {
            AXMUtils.Test.checkIsNumber(hSize);
            frame._hSplitterSize = hSize;
            return frame;
        };

        /**
         * Determines if the frame is a horizontal splitter
         * @returns {boolean}
         */
        frame.isHorSplitter = function () {
            return frame._dim == Module.dimX;
        };

        /**
         * Determines if the frame is a vertical splitter
         * @returns {boolean}
         */
        frame.isVertSplitter = function () {
            return frame._dim == Module.dimY;
        };

        /**
         * Returns the automatic size calculation of the client area in a dimension
         * @param {int} dim - dimension (can be Module.dimX or Module.dimY)
         * @returns {number} - computed automatic client size
         * @private
         */
        frame._getClientAutoSize = function (dim) {
            Module.checkValidDim(dim);
            if (dim == frame._dim) {
                var sze = 0;
                $.each(frame._memberFrames, function (idx, memberFrame) {
                    sze += memberFrame._getClientAutoSize(dim);
                });
                return sze;
            } else {
                var sze = 0;
                $.each(frame._memberFrames, function (idx, memberFrame) {
                    sze = Math.max(sze, memberFrame._getClientAutoSize(dim));
                });
                return sze;
            }
        };

        /**
         * Returns the minimum size calculation of the client area in a dimension
         * @param {int} dim - dimension (can be Module.dimX or Module.dimY)
         * @returns {number} - computed minumum client size
         * @private
         */
        frame._getClientMinSize = function (dim) {
            Module.checkValidDim(dim);
            if (dim == frame._dim) {
                var sze = 0;
                $.each(frame._memberFrames, function (idx, memberFrame) {
                    sze += memberFrame._getMinSize(dim);
                });
                return sze;
            } else {
                var sze = 0;
                $.each(frame._memberFrames, function (idx, memberFrame) {
                    sze = Math.max(sze, memberFrame._getMinSize(dim));
                });
                return sze;
            }
        };

        /**
         * Returns the ID of a splitter DIV
         * @param {int} sepnr - splitter index number
         * @returns {string} - ID
         */
        frame.getSplitterDivId = function (sepnr) {
            if (sepnr < 1 || sepnr >= frame._memberFrames.length) AXMUtils.reportBug('Invalid separator number');
            return 'FSP_' + frame._id + '_' + sepnr;
        };

        /**
         * Determines if a splitter is fixed or moveable by the user
         * @param {int} splitterNr - splitter index number
         * @returns {boolean}
         * @private
         */
        frame._isFixedSplitter = function (splitterNr) {
            if (splitterNr < 1 || splitterNr >= frame._memberFrames.length) AXMUtils.reportBug('Invalid separator number');
            if (frame._memberFrames[splitterNr - 1]._sizeInfos[frame._dim]._isFixedSize()) return true;
            if (frame._memberFrames[splitterNr]._sizeInfos[frame._dim]._isFixedSize()) return true;
            return false;
        };

        /**
         * Returns the html of the client area
         * @returns {string}
         */
        frame.createHtmlClient = function () {
            frame._normaliseSizeFractions();
            var html = '';
            for (var fnr = 1; fnr < frame._memberFrames.length; fnr++) {
                var splitdiv = DOM.Div({ id: frame.getSplitterDivId(fnr) });
                splitdiv.addCssClass('AXMSplitter');
                if (!frame._isFixedSplitter(fnr)) {
                    if (frame.isHorSplitter()) splitdiv.addCssClass('AXMSplitterH');
                    if (frame.isVertSplitter()) splitdiv.addCssClass('AXMSplitterV');
                }
                if (frame.splitterColor) splitdiv.addStyle('background-color', frame.splitterColor);
                html += splitdiv.toString();
            }
            $.each(frame._memberFrames, function (idx, memberFrame) {
                html += memberFrame.createHtml();
            });
            return html;
        };

        /**
         * Normalises the member frame relative sizes
         * @private
         */
        frame._normaliseSizeFractions = function () {
            var totalFraction = 0;
            $.each(frame._memberFrames, function (idx, memberFrame) {
                totalFraction += memberFrame.getSizeFraction();
            });
            if (totalFraction <= 0) AXMUtils.reportBug('Invalid splitter fractions');
            $.each(frame._memberFrames, function (idx, memberFrame) {
                memberFrame._sizeFraction /= totalFraction;
            });
        };

        /**
         * Calculates the positions of the member frame splitters, given a total available length
         * @param {int}length
         * @returns {[int]} - positions
         */
        frame.calcSplitterPositions = function (length) {
            AXMUtils.Test.checkIsNumber(length);
            if (frame._memberFrames.length == 1) return [];
            frame._normaliseSizeFractions();
            var position = 0;
            frame.splitterPositions = [0];
            $.each(frame._memberFrames, function (idx, memberFrame) {
                if (idx > 0) frame.splitterPositions.push(position);
                position += Math.round(memberFrame.getSizeFraction() * length);
            });
            frame.splitterPositions.push(length);
        };

        var _super_attachEventHandlers = frame.attachEventHandlers;
        /**
         * Attaches the html event handlers after DOM insertion
         */
        frame.attachEventHandlers = function (params) {
            _super_attachEventHandlers(params);
            frame._attachEventHandlers_Splitters(params);
        };

        var _super_detachEventHandlers = frame.detachEventHandlers;
        /**
         * Detaches the html event handlers
         */
        frame.detachEventHandlers = function () {
            _super_detachEventHandlers();
            frame._detachEventHandlers_Splitters();
        };

        /**
         * Attaches the html event handlers for ths splitters after DOM insertion
         */
        frame._attachEventHandlers_Splitters = function (params) {
            var initialiseMoveSplitter = function initialiseMoveSplitter(splitterNr, splitter$El) {
                frame._temp_dragSplitter_splitterNr = splitterNr;
                frame._temp_dragSplitter_splitter$El = splitter$El;
                frame._temp_dragSplitter_origPosit = frame.splitterPositions[splitterNr];
            };
            var doMoveSplitter = function doMoveSplitter(params) {
                var shift = frame.isHorSplitter() ? params.diffTotalX : params.diffTotalY;
                var $ElClient = frame.$ElContainer.children('.AXMFrameClient');
                var totsize = frame.isHorSplitter() ? $ElClient.width() : $ElClient.height();
                frame._calculateNewFrameSizeFractions(frame._temp_dragSplitter_splitterNr, frame._temp_dragSplitter_origPosit + shift, totsize);
                frame._setPositionSubframes({ resizing: true });
            };
            var finaliseMoveSplitter = function finaliseMoveSplitter() {
                frame._setPositionSubframes({ resizing: false });
            };

            $.each(frame._memberFrames, function (fnr, memberFrame) {
                if (fnr > 0 && !frame._isFixedSplitter(fnr)) {
                    var splitter$El = $('#' + frame.getSplitterDivId(fnr));
                    AXMUtils.create$ElDragHandler(splitter$El, function () {
                        initialiseMoveSplitter(fnr, splitter$El);
                    }, doMoveSplitter, finaliseMoveSplitter);
                }
            });
        };

        /**
         * Detaches the html event handlers
         */
        frame._detachEventHandlers_Splitters = function () {
            $.each(frame._memberFrames, function (fnr, memberFrame) {
                if (fnr > 0 && !frame._isFixedSplitter(fnr)) {
                    var splitter$El = $('#' + frame.getSplitterDivId(fnr));
                    AXMUtils.remove$ElDragHandler(splitter$El);
                }
            });
        };

        /**
         * Calculates the new member frame relative sizes after a splitter position was moved by the user
         * @param {int} splitterNr - moved splitter index
         * @param {int} newPos - new position of the splitter
         * @param {int} totSize - total available size
         * @private
         */
        frame._calculateNewFrameSizeFractions = function (splitterNr, newPos, totSize) {
            var posits = [0];
            var ps = 0;
            $.each(frame._memberFrames, function (fnr, memberFrame) {
                ps += memberFrame._sizeFraction * totSize;
                posits.push(ps);
            });
            posits.push(totSize);
            posits[splitterNr] = Math.min(posits[splitterNr + 1] - 1, Math.max(posits[splitterNr - 1] + 1, newPos));
            var prevposit = 0;
            $.each(frame._memberFrames, function (fnr, memberFrame) {
                memberFrame._sizeFraction = Math.max(1.0e-9, (posits[fnr + 1] - prevposit) / totSize);
                prevposit = posits[fnr + 1];
            });
            frame._adjustFrameSizeFractions(totSize);
        };

        /**
         * Adjusts the relative sizes of the member frames according to a new total available size
         * @param {int} totSize - available size
         * @private
         */
        frame._adjustFrameSizeFractions = function (totSize) {
            var widths = [];
            var widths_min = [];
            var widths_max = [];
            $.each(frame._memberFrames, function (fnr, memberFrame) {
                widths.push(memberFrame._sizeFraction * totSize);
                widths_min.push(memberFrame._getMinSize(frame._dim));
                widths_max.push(memberFrame._getMaxSize(frame._dim));
            });

            var modif = true;
            for (var iter = 0; iter < 5 && modif; iter++) {
                modif = false;
                $.each(frame._memberFrames, function (fnr1, memberFrame1) {
                    if (widths[fnr1] < widths_min[fnr1]) {
                        var extra = widths_min[fnr1] - widths[fnr1];
                        widths[fnr1] += extra;
                        $.each(frame._memberFrames, function (fnr2, memberFrame2) {
                            if (fnr2 != fnr1) widths[fnr2] -= extra / (frame._memberFrames.length - 1);
                        });
                        modif = true;
                    }
                    if (widths[fnr1] > widths_max[fnr1]) {
                        var extra = widths_max[fnr1] - widths[fnr1];
                        widths[fnr1] += extra;
                        $.each(frame._memberFrames, function (fnr2, memberFrame2) {
                            if (fnr2 != fnr1) widths[fnr2] -= extra / (frame._memberFrames.length - 1);
                        });
                        modif = true;
                    }
                });
            }

            $.each(frame._memberFrames, function (fnr, memberFrame) {
                memberFrame._sizeFraction = Math.max(1.0e-9, widths[fnr] / totSize);
            });
            frame._normaliseSizeFractions();
        };

        /**
         * Positions the member frames inside the available client area of the frame
         * @private
         */
        frame._setPositionSubframes = function (params) {
            var xl = frame.$ElContainer.children('.AXMFrameClient').width();
            var yl = frame.$ElContainer.children('.AXMFrameClient').height();
            frame.setPositionClient(xl, yl, params);
        };

        return frame;
    };

    /**
     * Implements a compound frame that organises member frame by aligning them horizontally, with splitters between them
     * @returns {Object} - object instance
     * @constructor
     */
    Module.FrameSplitterHor = function () {
        var frame = Module.FrameSplitter(0);

        /**
         * Positions the member frame with respect to the client area of the frame
         * @param {int} xl - client area width
         * @param {int} yl - client area height
         * @param {{}} params
         */
        frame.setPositionClient = function (xl, yl, params) {
            AXMUtils.Test.checkIsNumber(xl, yl);
            frame._adjustFrameSizeFractions(xl);
            frame.calcSplitterPositions(xl);
            $.each(frame._memberFrames, function (idx, memberFrame) {
                var memberLeft = frame.splitterPositions[idx];
                var memberRight = frame.splitterPositions[idx + 1];
                if (idx > 0) {
                    memberLeft += frame._hSplitterSize;
                    $('#' + frame.getSplitterDivId(idx)).css('width', 2 * frame._hSplitterSize).css('height', yl).css('left', frame.splitterPositions[idx] - frame._hSplitterSize).css('top', 0);
                }
                if (idx < frame._memberFrames.length - 1) {
                    memberRight -= frame._hSplitterSize;
                }
                memberFrame.setPosition(memberLeft, 0, memberRight - memberLeft + 1, yl, params);
            });
        };

        return frame;
    };

    /**
     * Implements a compound frame that organises member frame by aligning them horizontally, with splitters between them
     * @returns {Object} - object instance
     * @constructor
     */
    Module.FrameSplitterVert = function () {
        var frame = Module.FrameSplitter(1);

        /**
         * Positions the member frame with respect to the client area of the frame
         * @param {int} xl - client area width
         * @param {int} yl - client area height
         * @param {{}} params
         */
        frame.setPositionClient = function (xl, yl, params) {
            AXMUtils.Test.checkIsNumber(xl, yl);
            frame._adjustFrameSizeFractions(yl);
            frame.calcSplitterPositions(yl);
            if (!frame.splitterPositions) AXMUtils.Test.reportBug("Splitter does not seem to have more than one element");
            $.each(frame._memberFrames, function (idx, memberFrame) {
                var memberTop = frame.splitterPositions[idx];
                var memberBottom = frame.splitterPositions[idx + 1];
                if (idx > 0) {
                    memberTop += frame._hSplitterSize;
                    $('#' + frame.getSplitterDivId(idx)).css('height', 2 * frame._hSplitterSize).css('width', xl).css('top', frame.splitterPositions[idx] - frame._hSplitterSize).css('left', 0);
                }
                if (idx < frame._memberFrames.length - 1) {
                    memberBottom -= frame._hSplitterSize;
                }
                memberFrame.setPosition(0, memberTop, xl, memberBottom - memberTop + 1, params);
            });
        };

        return frame;
    };

    /**
     * Base class implementing a compound frame that organises member frame by stacking them in the client area, with only one member frame visible at any time
     * @returns {Object} - object instance
     * @constructor
     */
    Module.FrameStacker = function () {
        var frame = Module.FrameCompound();
        frame._activeMemberNr = 0;
        frame._stackHeaderOffset = 0;

        /**
         * Returns the html for the client area
         * @returns {string}
         */
        frame.createHtmlClient = function () {
            var html = '';

            $.each(frame._memberFrames, function (idx, memberFrame) {
                html += memberFrame.createHtml();
            });
            return html;
        };

        /**
         * Positions the member frames in the client area
         * @param {int} xl - client area width
         * @param {int} yl - client area height
         * @param {{}} params
         */
        frame.setPositionClient = function (xl, yl, params) {
            AXMUtils.Test.checkIsNumber(xl, yl);
            $.each(frame._memberFrames, function (idx, memberFrame) {
                memberFrame.setPosition(0, frame._stackHeaderOffset, xl, yl - frame._stackHeaderOffset, params);
            });
            frame._updateMemberVisibility();
        };

        /**
         * Positions the member frames inside the available client area of the frame
         * @private
         */
        frame._setPositionSubframes = function (params) {
            var xl = frame.$ElContainer.children('.AXMFrameClient').width();
            var yl = frame.$ElContainer.children('.AXMFrameClient').height();
            frame.setPositionClient(xl, yl, params);
        };

        /**
         * Repositions the member frames inside the client area of the frame
         */
        frame.repositionSubFrames = function () {
            frame._setPositionSubframes({ resizing: false });
        };

        /**
         * Dynamically adds a member frame when the stacker is live displayed
         * @param {{}} theFrame - new member frame to be added
         */
        frame.dynAddMember = function (theFrame) {
            frame.addMember(theFrame);
            //frame._activeMemberNr = frame._memberFrames.length-1;
            var $elClient = frame.$ElContainer.children('.AXMFrameClient');
            if (theFrame.getRoot$El().length > 0) {
                theFrame.getRoot$El().css('display', 'none');
                $elClient.append(theFrame.getRoot$El().detach());
            } else {
                $elClient.append(theFrame.createHtml());
                theFrame.getRoot$El().css('display', 'none');
                theFrame.attachEventHandlers();
            }
            frame._setPositionSubframes({ resizing: false });
        };

        /**
         * Dynamically removes a member from the stacker while live displayed
         * Note that the corresponding html is not removed
         * @param {{}} stackNr - index of the member to be removed
         */
        frame.dynDelMember = function (stackNr) {
            if (stackNr < 0 || frame._memberFrames >= frame._memberFrames) AXMUtils.reportBug('Invalid stack number');
            frame._memberFrames.splice(stackNr, 1);
            if (frame._activeMemberNr > stackNr) frame._activeMemberNr--;
        };

        frame._firstVisibilityUpdate = true;
        /**
         * Updates the visibility of the member frames
         * @private
         */
        frame._updateMemberVisibility = function () {
            if (frame._firstVisibilityUpdate) {
                $.each(frame._memberFrames, function (idx, memberFrame) {
                    memberFrame.$ElContainer.css('display', idx == frame._activeMemberNr ? '' : 'none');
                });
                frame._firstVisibilityUpdate = false; //!!!
            } else {
                var currentVisible = null;
                var newVisible = null;
                $.each(frame._memberFrames, function (idx, memberFrame) {
                    if (memberFrame.$ElContainer.css('display') != 'none') currentVisible = memberFrame;
                    if (idx == frame._activeMemberNr) newVisible = memberFrame;
                });
                if (currentVisible != newVisible) {
                    if (currentVisible) {
                        currentVisible.$ElContainer.fadeTo(200, 0, function () {
                            currentVisible.$ElContainer.css('display', 'none');
                            if (newVisible) {
                                newVisible.$ElContainer.css('display', '');
                                frame.repositionSubFrames(); //done here because elements in an initially invisible tab may not be measured correctly for positioning
                                newVisible.$ElContainer.fadeTo(200, 1);
                            }
                        });
                    } else {
                        if (newVisible) {
                            newVisible.$ElContainer.css('opacity', '0');
                            newVisible.$ElContainer.css('display', '');
                            frame.repositionSubFrames(); //done here because elements in an initially invisible tab may not be measured correctly for positioning
                            newVisible.$ElContainer.fadeTo(200, 1);
                        }
                    }
                }
            }
        };

        frame.getActiveMemberFrame = function () {
            return frame._memberFrames[frame._activeMemberNr];
        };

        /**
         * Activates an individual member frame
         * @param {int} fnr - member frame number
         */
        frame.activateStackNr = function (fnr) {
            if (fnr < 0 || fnr >= frame._memberFrames.length) AXMUtils.reportBug('Invalid TAB nr');
            frame._activeMemberNr = fnr;
            frame._updateMemberVisibility();
        };

        /**
         * Activates (= makes visible) a member frame containing a panel with a specific ID
         * @param {string} panelTypeId - panel ID of the frame to be activated
         */
        frame.activatePanelTypeId = function (panelTypeId) {
            var actFrameNr = -1;
            $.each(frame._memberFrames, function (idx, memberFrame) {
                if (memberFrame.activatePanelTypeId(panelTypeId)) actFrameNr = idx;
            });
            if (actFrameNr != -1) {
                if (frame.activateStackNr) frame.activateStackNr(actFrameNr);
                return true;
            } else return false;
        };

        return frame;
    };

    /**
     * Implements a compound frame that organises member frame by stacking them in the client area, with only one member frame visible at any time, and a tabber control allowing the user to select the visible member frame
     * @returns {Object} - object instance
     * @constructor
     */
    Module.FrameTabber = function () {
        var frame = Module.FrameStacker();
        frame._stackHeaderOffset = 34 + 7;

        frame.isTabber = function () {
            return true;
        };

        /**
         * Returns a unique html element ID for each tab in the tabber
         * @param tabNr
         * @returns {string}
         * @private
         */
        frame._getTabId = function (tabNr) {
            return 'frametab_' + frame._id + '_' + tabNr;
        };

        frame._getTabsHtml = function () {
            var st = '';
            $.each(frame._memberFrames, function (idx, memberFrame) {
                var tablElDiv = DOM.Div({ id: frame._getTabId(idx) }).addCssClass('AXMFrameTabElement');
                if (memberFrame.__stacker_disabled) tablElDiv.addCssClass('AXMFrameTabDisabled');
                tablElDiv.addElem(memberFrame.getTitle());
                st += tablElDiv.toString();
            });
            return st;
        };

        var _super_createHtmlClient = frame.createHtmlClient;
        /**
         * Returns the html implementing the client area
         * @returns {string}
         */
        frame.createHtmlClient = function () {
            var html = '';

            var tabDiv = DOM.Div({}).addCssClass('AXMFrameTabContainer');
            var tabDivInner = DOM.Div({ parent: tabDiv }).addCssClass('AXMFrameTabContainerInner');
            tabDivInner.addElem(frame._getTabsHtml());
            html += tabDiv.toString();
            html += _super_createHtmlClient();
            return html;
        };

        frame._attachTabClickHandlers = function () {
            $.each(frame._memberFrames, function (fnr, memberFrame) {
                $('#' + frame._getTabId(fnr)).click(function () {
                    if (fnr != frame._activeMemberNr && !memberFrame.__stacker_disabled) frame.activateStackNr(fnr);
                });
            });
        };

        var _super_attachEventHandlers = frame.attachEventHandlers;
        /**
         * Attaches the html event handlers after DOM insertion
         * @param params
         */
        frame.attachEventHandlers = function (params) {
            _super_attachEventHandlers(params);
            frame._attachTabClickHandlers();
            frame.activateStackNr(0);
        };

        var _super_detachEventHandlers = frame.detachEventHandlers;
        /**
         * Detaches the html event handlers
         */
        frame.detachEventHandlers = function () {
            _super_detachEventHandlers();
            $.each(frame._memberFrames, function (fnr, memberFrame) {
                $('#' + frame._getTabId(fnr)).unbind('click');
            });
        };

        frame._getTabContainer = function () {
            var $El = frame.$ElContainer.children('.AXMFrameClient').children('.AXMFrameTabContainer');
            if ($El.length != 1) if ($El.length != 1) AXMUtils.Test.reportBug('Tab container bug');
            return $El;
        };

        /**
         * disables or enables a member frame of the tabber
         * @param {string} frameId - id of the affected member frame
         * @param {boolean} disabled - new state
         */
        frame.disableMember_ById = function (frameId, disabled) {
            var frameNr = -1;
            $.each(frame._memberFrames, function (idx, memberFrame) {
                if (memberFrame.getId() == frameId) frameNr = idx;
            });
            if (frameNr < 0) AXMUtils.reportBug("member frame id in stacker not found");
            frame._memberFrames[frameNr].__stacker_disabled = disabled;
            if (disabled) $('#' + frame._getTabId(frameNr)).addClass('AXMFrameTabDisabled');else $('#' + frame._getTabId(frameNr)).removeClass('AXMFrameTabDisabled');
        };

        /**
         * Activates an individual member frame
         * @param {int} fnr - member frame number
         */
        frame.activateStackNr = function (fnr) {
            if (fnr < 0 || fnr >= frame._memberFrames.length) AXMUtils.reportBug('Invalid TAB nr');
            frame._activeMemberNr = fnr;
            frame._updateMemberVisibility();
            frame._getTabContainer().children('.AXMFrameTabContainerInner').children('.AXMFrameTabElement').removeClass('AXMFrameTabElementActive').addClass('AXMFrameTabElementInActive');
            $('#' + frame._getTabId(fnr)).removeClass('AXMFrameTabElementInActive').addClass('AXMFrameTabElementActive');
        };

        var _super_setPositionClient = frame.setPositionClient;
        /**
         * Positions the member frames inside the available client space
         * @param {int} xl - client space width
         * @param {int} yl - client space height
         * @param params
         */
        frame.setPositionClient = function (xl, yl, params) {
            AXMUtils.Test.checkIsNumber(xl, yl);
            frame._getTabContainer().outerWidth(xl).outerHeight(frame._stackHeaderOffset);

            var availableWidth = frame._getTabContainer().width();

            var longestTitleLength = 0;
            $.each(frame._memberFrames, function (idx, memberFrame) {
                longestTitleLength = Math.max(longestTitleLength, memberFrame.getTitle().length);
            });

            var maxTitleLength = longestTitleLength;

            do {
                $.each(frame._memberFrames, function (fnr, memberFrame) {
                    var shortTitle = memberFrame.getTitle();
                    if (maxTitleLength < shortTitle.length) shortTitle = shortTitle.substring(0, maxTitleLength) + '&hellip;';
                    $('#' + frame._getTabId(fnr)).html(shortTitle);
                });
                var consumedWidth = frame._getTabContainer().children('.AXMFrameTabContainerInner').width();
                maxTitleLength--;
            } while (consumedWidth > availableWidth && maxTitleLength > 1);

            _super_setPositionClient(xl, yl, params);
        };

        var _super_dynAddMember = frame.dynAddMember;
        /**
         * Dynamically adds a member frame when the stacker is live displayed
         * @param {{}} theFrame - new member frame to be added
         */
        frame.dynAddMember = function (theFrame) {
            _super_dynAddMember(theFrame);
            var tabsHtml = frame._getTabsHtml();
            frame._getTabContainer().children('.AXMFrameTabContainerInner').html(tabsHtml);
            frame._attachTabClickHandlers();
            frame.activateStackNr(frame._activeMemberNr);
        };

        return frame;
    };

    /**
     * Implements a frame containing a panel
     * @param {AXM.Panels.PanelBase} iPanel - panel to be contained in the frame
     * @returns {Object} - frame instance
     * @constructor
     */
    Module.FrameFinal = function (iPanel) {
        AXMUtils.Test.checkIsType(iPanel, "@Panel");
        var frame = Module.FrameGeneric();
        frame._panel = iPanel;
        iPanel._setFrame(frame);

        /**
         * Adds a css class to the fame content
         * @param className
         */
        frame.setCssClass = function (className) {
            frame._cssClass = className;
            return frame;
        };

        /**
         * Returns the html implementing the client area
         * @returns {string}
         */
        frame.createHtmlClient = function () {
            var div = DOM.Div({ id: frame._id + '_finalclient' });
            div.addCssClass('AXMFrameFinalClientArea');
            if (frame._cssClass) div.addCssClass(frame._cssClass);
            div.addElem(frame._panel.createHtml());

            return div.toString();
        };

        /**
         * Returns the automatically computed client size in a given dimension
         * @param {int} dim - dimension index (Module.dimX or Module.dimY)
         * @returns {int}
         * @private
         */
        frame._getClientAutoSize = function (dim) {
            var $ElClient = frame.$ElContainer.children('.AXMFrameClient').children('.AXMFrameFinalClientArea');
            if ($ElClient.length != 1) AXMUtils.Test.reportBug('Bug in getclientautosize');
            var ht = $ElClient.html();
            if (dim == Module.dimX) return $ElClient.outerWidth();else return $ElClient.outerHeight();
        };

        var _super_attachEventHandlers = frame.attachEventHandlers;
        /**
         * Attached the html event handlers after DOM insertion
         * @param params
         */
        frame.attachEventHandlers = function (params) {
            _super_attachEventHandlers(params);
            frame._panel.attachEventHandlers(params);
        };

        var _super_detachEventHandlers = frame.detachEventHandlers;
        /**
         * Detach the html event handlers
         */
        frame.detachEventHandlers = function () {
            _super_detachEventHandlers();
            frame._panel.detachEventHandlers();
        };

        /**
         * Positions the panel in the client area
         * @param {int} xl - client area width
         * @param {int} yl - client area height
         * @param params
         */
        frame.setPositionClient = function (xl, yl, params) {
            if (!params) debugger;
            var $ElClient = frame.$ElContainer.children('.AXMFrameClient').children(".AXMFrameFinalClientArea");
            if ($ElClient.length != 1) AXMUtils.Test.reportBug('Bug in setPositionClient');
            if (!frame._sizeInfos[Module.dimY].isAutoSize()) $ElClient.css('height', yl);
            if (!frame._sizeInfos[Module.dimX].isAutoSize()) $ElClient.css('width', xl);
            frame._panel.resize(xl, yl, params);
        };

        /**
         * Returns the panel contained by this frame
         * @returns {AXM.Panels.PanelBase}
         */
        frame.getPanel = function () {
            return frame._panel;
        };

        /**
         * Activates a frame containing a specific panel ID (this function only needs to return the presence of this panel)
         * @param {int} panelTypeId - panel ID
         * @returns {boolean} - presence of this panel
         */
        frame.activatePanelTypeId = function (panelTypeId) {
            return frame._panel.getTypeId() == panelTypeId;
        };

        /**
         * Called when the frame is about to close.
         * @param msg
         */
        frame.willClose = function (msg) {
            frame._panel._tearDown();
        };

        return frame;
    };

    /**
     * Implements a frame containing a panel, with a button command bar on top
     * @param {AXM.Panels.PanelBase} iPanel - panel to be contained in the frame
     * @returns {Object} - frame instance
     * @constructor
     */
    Module.FrameFinalCommands = function (iPanel) {
        var controlsH = 40;
        var frame = Module.FrameSplitterVert();
        frame.setHalfSplitterSize(1);
        frame.splitterColor = "rgb(220,220,220)";
        frame._panelControls = __webpack_require__(16).create(iPanel.getId() + '_commands');
        frame._frameCommands = frame.addMember(Module.FrameFinal(frame._panelControls)).setFixedDimSize(Module.dimY, controlsH);
        frame._frameFinal = frame.addMember(Module.FrameFinal(iPanel));

        frame._controlGroup = ControlsCompound.GroupHor({ verticalAlignCenter: true });
        frame._panelControls.setRootControl(ControlsCompound.WrapperStyled(frame._controlGroup, 'AXMCommandBar'));

        frame._commandButtonsList = [];

        frame.addCommandSpacer = function (space) {
            frame._controlGroup.add(ControlsCompound.SeparatorH(space));
        };

        /**
         * Adds a command to the command bar
         * @param {{}} settings - same settings as for a AXM.Controls.Button
         * @param {function} action - called when the command is invoked by the user
         * @returns {Object}
         */
        frame.addCommand = function (settings, action) {
            settings.height = controlsH - 1;
            if (!settings.width) settings.width = 40;
            if (!settings.buttonClass) settings.buttonClass = 'AXMButtonCommandBar';
            var bt = Controls.Button(settings);
            bt.addNotificationHandler(action);
            frame._commandButtonsList.push(bt);
            frame._controlGroup.add(bt);
            return bt;
        };

        /**
         * Adds a general control to the top command bar
         * @param {Object} ctrl
         */
        frame.addControl = function (ctrl) {
            frame._controlGroup.add(ctrl);
        };

        /**
         * Adds a horizontal separator to the top command bar
         */
        frame.addSeparator = function () {
            frame._controlGroup.add(ControlsCompound.DividerH());
        };

        return frame;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, PanelBase) {

    /**
     * Module encapsulating a panel that contains raw html code
     * @type {{}}
     */
    var Module = {};

    /**
     * Implements a panel that contains raw html code
     * @param {string} id - panel id
     * @returns {id}
     */
    Module.create = function (id) {
        var panel = PanelBase.create(id);
        panel._content = '';
        panel._scrollEventHandler = null;

        /**
         * Enables a vertical scroll bar for the panel
         * @returns {Object} - self
         */
        panel.enableVScrollBar = function () {
            panel._scrollbarV = true;
            return panel;
        };

        /**
         * Enables a vertical scrolling without scrollbar
         * @returns {Object} - self
         */
        panel.enableVScrollingNoBar = function () {
            panel._scrollVNoBar = true;
            return panel;
        };

        /**
         * Enables a horizontal scroll bar for the panel
         * @returns {Object} - self
         */
        panel.enableHScrollBar = function () {
            panel._scrollbarH = true;
            return panel;
        };

        panel.setScrollEventHandler = function (handler) {
            panel._scrollEventHandler = handler;
        };

        /**
         * Sets the html content of the panel
         * @param {string} content - html content
         */
        panel.setContent = function (content) {
            panel._content = content;
            panel.get$El().html(content);
        };

        /**
         * Appends html content to the panel
         * @param {string} content - html content
         */
        panel.appendContent = function (content) {
            panel._content = content;
            panel.get$El().append(content);
        };

        /**
         * Returns the jquery element of the html content
         * @returns {jQuery}
         */
        panel.get$El = function () {
            return $('#' + panel.getId() + '_content');
        };

        /**
         * Returns the ID of the element with the content
         * @returns {string}
         */
        panel.getContentElementId = function () {
            return panel.getId() + '_content';
        };

        /**
         * Returns the html implementing the panel
         * @returns {string}
         */
        panel.createHtml = function () {
            var rootDiv = DOM.Div({ id: panel.getId() + '_content' });
            rootDiv.addCssClass('AXMHtmlPanelBody');
            rootDiv.addStyle('width', '100%');
            rootDiv.addStyle('height', '100%');
            rootDiv.addStyle('overflow', 'hidden');
            if (panel._scrollbarV) rootDiv.addStyle('overflow-y', 'scroll');
            if (panel._scrollbarH) rootDiv.addStyle('overflow-x', 'scroll');
            rootDiv.addElem(panel._content);
            return rootDiv.toString();
        };

        /**
         * Scrolls to the bottom of the content
         */
        panel.scrollToBottom = function () {
            var el = panel.get$El();
            el.animate({ scrollTop: el.height() }, 250);
        };

        /**
         * Attaches the html event handlers after DOM insertion
         */
        panel.attachEventHandlers = function () {
            //if (panel._rootControl)
            //    return panel._rootControl.attachEventHandlers();

            if (panel._scrollVNoBar) {
                var el = panel.get$El();
                AXMUtils.create$ElScrollHandler(el, function (data) {
                    //el.animate({ scrollTop: el.scrollTop()+data.deltaY*16}, 25);
                    panel.get$El().scrollTop(panel.get$El().scrollTop() + data.deltaY * 16);
                });
            }

            if (panel._scrollEventHandler) panel.get$El().scroll(function (ev) {
                var data = {};
                panel._scrollEventHandler(data);
            });
        };

        /**
         * Detaches the html event handlers
         */
        panel.detachEventHandlers = function () {
            if (panel._scrollVNoBar) {
                var el = panel.get$El();
                AXMUtils.remove$ElScrollHandler(el);
            }
        };

        panel.resize = function (xl, yl) {};

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _) {

    var Module = {};

    Module.reportBug = function (error) {
        //throw(msg);
        //alert(error);
        //debugger;
    };

    Module.checkDefined = function (obj, error) {
        if (!obj) Module.reportBug(error);
    };

    Module.checkIsString = function () {
        $.each(arguments, function (idx, obj) {
            if (!(typeof obj === 'string')) Module.reportBug('Variable is not a string');
        });
    };

    Module.checkIsNumber = function () {
        $.each(arguments, function (idx, obj) {
            if (!(typeof obj === 'number')) Module.reportBug('Variable is not a number');
        });
    };

    Module.checkIsType = function (obj, typeStr) {
        Module.checkDefined(obj, 'Undefined object of type ' + typeStr);
        if (!obj.__typeStrings) Module.reportBug('Variable is not an object. (expected ' + typeStr + ')');
        if (obj.__typeStrings.indexOf(typeStr) < 0) Module.reportBug('Object is not of type ' + typeStr);
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, Msg) {

    /**
     * Module encapsulating a base class for a panel. a panel is a client area containing a specific type of content (e.g. a table view)
     * @type {{}}
     */
    var Module = {};

    /**
     * Implements a base class for a panel. a panel is a client area containing a specific type of content (e.g. a table view)
     * @param {string} typeId - identifier of the type of panel
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.create = function (typeId) {
        var panel = AXMUtils.object('@Panel');
        panel._id = AXMUtils.getUniqueID();
        panel._typeId = typeId;
        panel._tearDownHanders = []; //List of functions that will be called when the panel is about to be removed
        panel._listeners = [];

        /**
         * Defines the parent frame containing this panel
         * @param {Object} iFrame - parent frame
         * @private
         */
        panel._setFrame = function (iFrame) {
            AXMUtils.Test.checkIsType(iFrame, '@Frame');
            panel._frame = iFrame;
        };

        panel.setTypeId = function (id) {
            return panel._typeId = id;
        };

        /**
         * Returns the unique identifier of this panel
         * @returns {string}
         */
        panel.getId = function () {
            return panel._id;
        };

        /**
         * Returns the identifier of the panel type
         * @returns {string}
         */
        panel.getTypeId = function () {
            return panel._typeId;
        };

        panel.bubbleMessage = function (msgId, msgContent) {
            if (panel._frame) panel._frame.bubbleMessage(msgId, msgContent);
        };

        /**
         * Adds a new function that will be called when the frame is about to be removed
         * @param func
         */
        panel.addTearDownHandler = function (func) {
            panel._tearDownHanders.push(func);
        };

        /**
         * Registers a message listening callback handler that lives as long as the panel lives
         * @param msgId
         * @param callbackFunction
         */
        panel.listen = function (msgId, callbackFunction) {
            var eventid = AXMUtils.getUniqueID();
            panel._listeners.push(eventid);
            Msg.listen(eventid, msgId, callbackFunction);
        };

        /**
         * Returns the html implementing the panel (implemented in derived classes)
         * @returns {string}
         */
        panel.createHtml = function () {
            return '';
        };

        /**
         * Resizes the panel (implemented in derived classes)
         * @param {int} xl - new x dimension
         * @param {int} yl - new y dimension
         */
        panel.resize = function (xl, yl) {};

        panel._tearDown = function () {
            $.each(panel._listeners, function (idx, eventid) {
                Msg.delListener(eventid);
            });
            panel._listeners = [];
            $.each(panel._tearDownHanders, function (idx, handler) {
                handler();
            });
            panel._tearDownHanders = [];
        };

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils) {

    var Module = {};

    Module.createEmpty = function () {
        return Module.createFA("");
    };

    Module.createFA = function (name, baseSizeFactor) {
        var icon = AXMUtils.object('icon');
        icon._name = name;
        icon._baseSize = 20;
        icon._opacity = 1;
        if (baseSizeFactor) icon._baseSize *= baseSizeFactor;
        icon._sizeFactor = 1;
        icon._decorators = [];

        icon.addDecorator = function (name, xPos, offsetX, yPos, offsetY, size, opacity, color) {
            if (opacity === undefined) opacity = 1;
            if (['left', 'right'].indexOf(xPos) < 0) AXMUtils.Test.reportBug("Decorator x position should be 'left' or 'right'");
            if (['top', 'bottom'].indexOf(yPos) < 0) AXMUtils.Test.reportBug("Decorator y position should be 'top' or 'bottom'");
            icon._decorators.push({
                name: name,
                xPos: xPos,
                yPos: yPos,
                offsetX: offsetX,
                offsetY: offsetY,
                size: size,
                opacity: opacity,
                color: color
            });
            return icon;
        };

        icon.setOpacity = function (opac) {
            icon._opacity = opac;
            return icon;
        };

        icon.clone = function () {
            var dupl = Module.createFA(icon._name);
            dupl._opacity = icon._opacity;
            dupl._baseSize = icon._baseSize;
            dupl._sizeFactor = icon._sizeFactor;
            dupl._decorators = JSON.parse(JSON.stringify(icon._decorators));
            return dupl;
        };

        icon.setSize = function (newSize) {
            icon._sizeFactor = newSize;
            return icon;
        };

        icon.changeSize = function (sizeFactor) {
            icon._sizeFactor *= sizeFactor;
            return icon;
        };

        icon.renderHtml = function () {
            var str = '<div style="position:relative;display:inline-block;overflow:visible">';
            str += '<i style="font-size:{size}px;opacity:{opac}" class="fa {name}"/>'.AXMInterpolate({
                name: icon._name,
                opac: icon._opacity,
                size: Math.round(icon._sizeFactor * icon._baseSize)
            });

            $.each(icon._decorators, function (idx, decor) {
                var substr = '<div style="position:absolute;{xpos}:{left}px;{ypos}:{top}px;opacity:{opacity};color:{color};overflow:visible"><i style="font-size:{size}px" class="fa {name}"/></div>'.AXMInterpolate({
                    name: decor.name,
                    xpos: decor.xPos,
                    ypos: decor.yPos,
                    left: Math.round(decor.offsetX * icon._sizeFactor),
                    top: Math.round(decor.offsetY * icon._sizeFactor),
                    size: Math.round(icon._sizeFactor * icon._baseSize * decor.size),
                    opacity: decor.opacity,
                    color: decor.color
                });
                str += substr;
            });
            str += "</div>";

            return str;
        };

        icon.getSize = function () {
            return icon._size;
        };

        return icon;
    };

    Module.createBitmap = function (name, baseSizeFactor) {
        var icon = AXMUtils.object('icon');
        icon._name = name;
        icon._baseSize = 20;
        if (baseSizeFactor) icon._baseSize *= baseSizeFactor;
        icon._sizeFactor = 1;

        icon.clone = function () {
            var dupl = Module.createBitmap(icon._name);
            dupl._baseSize = icon._baseSize;
            dupl._sizeFactor = icon._sizeFactor;
            return dupl;
        };

        icon.setSize = function (newSize) {
            icon._sizeFactor = newSize;
            return icon;
        };

        icon.changeSize = function (sizeFactor) {
            icon._sizeFactor *= sizeFactor;
            return icon;
        };

        icon.renderHtml = function () {
            var str = '<div style="position:relative">';
            str += '<img src="{file}" alt=""/>'.AXMInterpolate({
                file: icon._name
            });
            str += "</div>";

            return str;
        };

        icon.getSize = function () {
            return icon._size;
        };

        return icon;
    };

    Module.createHeaderInfo = function (icon, title1, title2, settings) {
        AXMUtils.Test.checkIsType(icon, 'icon');
        var headerInfo = AXMUtils.object('headerinfo');
        headerInfo.icon = icon;
        headerInfo.title1 = title1;
        headerInfo.title2 = title2;
        if (!settings) settings = {};
        headerInfo.showTitle = settings.showTitle !== false;
        headerInfo.labels = settings.labels || {};

        headerInfo.getSingleTitle = function () {
            return headerInfo.title1 + ' ' + headerInfo.title2;
        };

        headerInfo.getIcon = function () {
            return headerInfo.icon;
        };

        return headerInfo;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(5), __webpack_require__(10), __webpack_require__(16), __webpack_require__(11), __webpack_require__(3), __webpack_require__(9), __webpack_require__(36)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, SimplePopups, Frame, PanelForm, PanelHtml, Controls, DataTypes, FrameQuery) {

    var Module = {};

    Module.plotAspect = function (aspectId, aspectName, dataType, isRequired) {
        return {
            getId: function getId() {
                return aspectId;
            },
            getName: function getName() {
                return aspectName;
            },
            getDataType: function getDataType() {
                return dataType;
            },
            getRequired: function getRequired() {
                return isRequired;
            }
        };
    };

    Module.createPlotType = function (id, name, icon) {
        var plotType = {
            _plotTypeId: id,
            _plotTypeName: name,
            _plotTypeIcon: icon,
            _aspects: [],
            _aspectsMap: {}
        };

        plotType.getPlotTypeId = function () {
            return plotType._plotTypeId;
        };

        plotType.getPlotTypeName = function () {
            return plotType._plotTypeName;
        };

        plotType.getPlotTypeIcon = function () {
            return plotType._plotTypeIcon;
        };

        plotType.addPlotAspect = function (aspectId, aspectName, dataType, isRequired) {
            var aspect = Module.plotAspect(aspectId, aspectName, dataType, isRequired);
            plotType._aspects.push(aspect);
            plotType._aspectsMap[aspectId] = aspect;
        };

        plotType.getPlotAspects = function () {
            return plotType._aspects;
        };

        plotType.hasAspect = function (aspectId) {
            return !!plotType._aspectsMap[aspectId];
        };

        //##############  Create in instance of a plot window ##########################
        plotType.createGeneric = function (dataFrame, aspectMap) {
            var win = PopupWindow.create({
                title: _TRL('{name} ({plotname})').AXMInterpolate({ name: dataFrame.getName(), plotname: plotType.getPlotTypeName() }),
                blocking: false,
                autoCenter: true,
                sizeX: 800,
                sizeY: 500,
                canDock: true
            });

            win.dataFrame = dataFrame;

            win._aspectPropertyIdMap = aspectMap;

            win.hasAspectProperty = function (aspectId) {
                if (!plotType.hasAspect(aspectId)) AXMUtils.Test.reportBug(_TRL('Invalid plot aspect: ') + aspectId);
                var propId = win._aspectPropertyIdMap[aspectId];
                return !!propId;
            };

            win.getAspectProperty = function (aspectId) {
                if (!plotType.hasAspect(aspectId)) AXMUtils.Test.reportBug(_TRL('Invalid plot aspect: ') + aspectId);
                var propId = win._aspectPropertyIdMap[aspectId];
                if (!propId) return null;
                return win.dataFrame.getProperty(propId);
            };

            win.getPrimKeyProperty = function () {
                return win.dataFrame.getPrimKeyProperty();
            };

            win.setAspectProperty = function (aspectId, propId) {
                win._aspectPropertyIdMap[aspectId] = propId;
                win.updateAspect(aspectId);
            };

            win._createAspectControls = function (grp) {
                $.each(plotType.getPlotAspects(), function (idx, aspect) {
                    var picker = dataFrame.createPropertySelector(aspect.getDataType(), !aspect.getRequired());
                    //var picker = Controls.DropList({width: 160});
                    //if (!aspect.getRequired())
                    //    picker.addState('', _TRL("-- None --"));
                    //$.each(dataFrame.getProperties(), function(idx, prop) {
                    //    if (aspect.getDataType().includes(prop.getDataType()))
                    //        picker.addState(prop.getId(), prop.getDispName());
                    //});
                    var aspectProp = win.getAspectProperty(aspect.getId());
                    if (aspectProp) picker.setValue(aspectProp.getId());
                    picker.addNotificationHandler(function () {
                        win.setAspectProperty(aspect.getId(), picker.getValue());
                    });
                    grp.add(Controls.Compound.GroupVert({}, [aspect.getName() + ':', picker]));
                });
            };

            win._createSelectionControls = function (grp) {
                win._ctrlSelectionCount = Controls.Static({ text: _TRL('0 points selected') });
                grp.add(win._ctrlSelectionCount);

                var btSelectAll = Controls.Button({
                    text: _TRL('Select all'),
                    icon: 'fa-square-o'
                }).addNotificationHandler(win.selectAll);

                var btSelectNone = Controls.Button({
                    text: _TRL('Select none'),
                    icon: 'fa-ban'
                }).addNotificationHandler(win.selectNone);

                var btQuery = Controls.Button({
                    text: _TRL('Query...'),
                    icon: 'fa-filter'
                }).addNotificationHandler(win.doQuery);

                var btSelPlot = Controls.Button({
                    text: _TRL('Create new view'),
                    icon: 'fa-eye'
                }).addNotificationHandler(function () {
                    var subDataFrame = win.dataFrame.createSelectedRowsDataFrame();
                    if (subDataFrame.getRowCount() == 0) {
                        SimplePopups.ErrorBox(_TRL('No points are selected'));
                        return;
                    }
                    subDataFrame.promptPlot();
                });

                var btRestrict = Controls.Button({
                    text: _TRL('Restrict current view'),
                    icon: 'fa-sign-in'
                }).addNotificationHandler(function () {
                    var subDataFrame = win.dataFrame.createSelectedRowsDataFrame();
                    if (subDataFrame.getRowCount() == 0) {
                        SimplePopups.ErrorBox(_TRL('No points are selected'));
                        return;
                    }
                    win.dataFrame = subDataFrame;
                    win.updateAspect();
                });

                grp.add(Controls.Compound.GroupHor({}, [btSelectAll, btSelectNone, btQuery, btSelPlot, btRestrict]));
            };

            // Called when the user selected a set of rows in the dataframe
            win.performRowSelected = function (selList, dispText) {
                var objectType = win.dataFrame.objectType;
                var actions = [{
                    name: _TRL('Add to selection'),
                    action: function action() {
                        $.each(selList, function (idx, rowId) {
                            objectType.rowSelSet(rowId, true);
                        });
                        objectType.rowSelNotifyChanged();
                    }
                }, {
                    name: _TRL('Replace selection'),
                    action: function action() {
                        objectType.rowSelClear();
                        $.each(selList, function (idx, rowId) {
                            objectType.rowSelSet(rowId, true);
                        });
                        objectType.rowSelNotifyChanged();
                    }
                }, {
                    name: _TRL('Restrict selection'),
                    action: function action() {
                        var currentSelectedList = objectType.rowSelGetList();
                        var currentSelectedMap = {};
                        $.each(currentSelectedList, function (idx, id) {
                            currentSelectedMap[id] = true;
                        });
                        objectType.rowSelClear();
                        $.each(selList, function (idx, rowId) {
                            if (currentSelectedMap[rowId]) objectType.rowSelSet(rowId, true);
                        });
                        objectType.rowSelNotifyChanged();
                    }
                }, {
                    name: _TRL('Exclude from selection'),
                    action: function action() {
                        $.each(selList, function (idx, rowId) {
                            objectType.rowSelSet(rowId, false);
                        });
                        objectType.rowSelNotifyChanged();
                    }
                }];
                var introText = _TRL('{disptext}<br><b>{count} points</b>').AXMInterpolate({
                    disptext: dispText || '',
                    count: selList.length
                });
                SimplePopups.ActionChoiceBox(_TRL('Highlighted points'), introText, actions);
            };

            win.updateRowSelection = function () {
                var selCount = 0;

                var dataPrimKey = win.getPrimKeyProperty().data;
                var rowSelGet = win.dataFrame.objectType.rowSelGet;
                for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                    if (rowSelGet(dataPrimKey[rowNr])) selCount += 1;
                }

                win._ctrlSelectionCount.modifyText(_TRL('{cnt} points selected').AXMInterpolate({ cnt: selCount }));
                win.plot.render();
            };

            win.addPlotCommand = function (icon, name, action) {
                var bt = win.plotFrame.addCommand({
                    icon: icon,
                    hint: name
                }, action);
                return bt;
            };

            win.setInfoText = function (content) {
                win._formInfoText.setContent(content);
                win._rightGroup.updatePosition();
            };

            win.selectAll = function () {
                var selList = [];
                var dataPrimKey = win.dataFrame.getPrimKeyProperty().data;
                for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                    selList.push(dataPrimKey[rowNr]);
                }
                $.each(selList, function (idx, rowId) {
                    win.dataFrame.objectType.rowSelSet(rowId, true);
                });
                win.dataFrame.objectType.rowSelNotifyChanged();
            };

            win.selectNone = function () {
                win.dataFrame.objectType.rowSelClear();
                //$.each(selList, function(idx, rowId) {
                //    win.dataFrame.objectType.rowSelSet(rowId, false);
                //});
                win.dataFrame.objectType.rowSelNotifyChanged();
            };

            win.doQuery = function () {
                FrameQuery.create(win.dataFrame, '', function (selList, expr) {
                    win.performRowSelected(selList, expr);
                });
            };

            win.openImage = function () {
                win.plot.save();
            };

            win.init = function () {

                var rootFrame = Frame.FrameSplitterHor();

                var formHeader = PanelForm.create('intro', { scrollY: true });
                rootFrame.addMember(Frame.FrameFinal(formHeader)).setFixedDimSize(Frame.dimX, 290);

                var headerGroup = Controls.Compound.GroupVert({}).setSeparator(12);
                formHeader.setRootControl(headerGroup);

                var aspectGroup = Controls.Compound.GroupVert({}).setSeparator(12);
                headerGroup.add(Controls.Compound.Section(Controls.Compound.StandardMargin(aspectGroup), _TRL("Plot aspects")));
                win._createAspectControls(aspectGroup);

                if (win._createDisplayControls) {
                    var dispGroup = Controls.Compound.GroupVert({}).setSeparator(12);
                    headerGroup.add(Controls.Compound.Section(Controls.Compound.StandardMargin(dispGroup), _TRL("Display")));
                    win._createDisplayControls(dispGroup);
                }

                var selGroup = Controls.Compound.GroupVert({}).setSeparator(12);
                headerGroup.add(Controls.Compound.Section(Controls.Compound.StandardMargin(selGroup), _TRL("Selection")));
                win._createSelectionControls(selGroup);
                if (win._appendSelectionControls) {
                    win._appendSelectionControls(selGroup);
                }

                var rightGroup = Frame.FrameSplitterVert().setHalfSplitterSize(0);
                win._rightGroup = rightGroup;
                rootFrame.addMember(rightGroup);

                if (win.plot) {
                    win.plotFrame = Frame.FrameFinalCommands(win.plot);
                    rightGroup.addMember(win.plotFrame);
                }

                win._formInfoText = PanelHtml.create('', {});
                rightGroup.addMember(Frame.FrameFinal(win._formInfoText).setAutoSize(Frame.dimY));

                if (win.plot) win.addPlotCommand('fa-external-link', _TRL('Open plot'), win.openImage);

                if (win.setPlotCommands) win.setPlotCommands();

                win.setRootFrame(rootFrame);
                if (win.initPlot) win.initPlot();
                win.start();

                win.listen('DataFrameRowSelChanged', function (objectTypeId) {
                    if (objectTypeId == win.dataFrame.objectType.typeId) win.updateRowSelection();
                });
            };

            return win;
        };

        //###################################################################################


        return plotType;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, PanelBase) {

    /**
     * Module encapsulating a panel that contains a form, containing a (set of) control(s)
    * @type {{}}
     */
    var Module = {};

    /**
     * Implements a panel that contains a form, containing a (set of) control(s)
     * @param {string} id - panel type id
     * @param {{}} settings - panel settings
     * @param {boolean} settings.scrollX - form has a horizontal scroll bar
     * @param {boolean} settings.scrollY - form has a vertical scroll bar
     * @param {boolean} settings.autoScrollY - form has an automatic vertical scroll bar
     * @param {boolean} settings.alignVerticalCenter - form components are vertically aligned
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.create = function (id, settings) {
        var panel = PanelBase.create(id);
        panel._rootControl = null;
        panel._scrollY = false;
        panel._scrollX = false;
        panel._alignVerticalCenter = false;
        if (settings) {
            panel._autoScrollX = settings.autoScrollX;
            panel._autoScrollY = settings.autoScrollY;
            panel._scrollY = settings.scrollY;
            panel._scrollX = settings.scrollX;
            panel._alignVerticalCenter = settings.alignVerticalCenter;
        }

        /**
         * Sets the single root control that appears on the form (note: this may be a compound control)
         * @param {{}} ctrl - root control
         */
        panel.setRootControl = function (ctrl) {
            AXMUtils.Test.checkIsType(ctrl, '@Control');
            panel._rootControl = ctrl;
        };

        /**
         * Returns the html implementing this panel
         * @returns {string}
         */
        panel.createHtml = function () {
            var rootDiv = DOM.Div({ id: 'frm' + panel._id });
            rootDiv.addStyle('width', '100%');
            rootDiv.addStyle('height', '100%');
            rootDiv.addStyle('overflow-y', panel._scrollY ? 'scroll' : 'hidden');
            rootDiv.addStyle('overflow-x', panel._scrollX ? 'scroll' : 'hidden');
            if (panel._autoScrollX) rootDiv.addStyle('overflow-x', 'auto');
            if (panel._autoScrollY) rootDiv.addStyle('overflow-y', 'auto');
            if (panel._rootControl) rootDiv.addElem(panel._rootControl.createHtml());
            if (panel._alignVerticalCenter) {
                rootDiv.addStyle('display', 'flex');
                rootDiv.addStyle('align-items', 'center');
            }
            return rootDiv.toString();
        };

        /**
         * Attaches the html event handlers after DOM insertion
         */
        panel.attachEventHandlers = function () {
            if (panel._rootControl) return panel._rootControl.attachEventHandlers();
        };

        /**
         * Detaches the html event handlers
         */
        panel.detachEventHandlers = function () {
            if (panel._rootControl) return panel._rootControl.detachEventHandlers();
        };

        /**
         * Re-creates the html to reflect a change in the control(s)
         */
        panel.reCreate = function () {
            if (panel._rootControl) $('#frm' + panel._id).html(panel._rootControl.createHtml());
            panel.attachEventHandlers();
        };

        panel.resize = function (xl, yl) {};

        panel.addTearDownHandler(function () {
            if (panel._rootControl) panel._rootControl.tearDown();
        });

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 18 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* Blob.js
 * A Blob implementation.
 * 2014-05-31
 * 
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
 plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
    "use strict";

    view.URL = view.URL || view.webkitURL;

    if (view.Blob && view.URL) {
        try {
            new Blob();
            return;
        } catch (e) {}
    }

    // Internally we use a BlobBuilder implementation to base Blob off of
    // in order to support older browsers that only have BlobBuilder
    var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || function (view) {
        var get_class = function get_class(object) {
            return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
        },
            FakeBlobBuilder = function BlobBuilder() {
            this.data = [];
        },
            FakeBlob = function Blob(data, type, encoding) {
            this.data = data;
            this.size = data.length;
            this.type = type;
            this.encoding = encoding;
        },
            FBB_proto = FakeBlobBuilder.prototype,
            FB_proto = FakeBlob.prototype,
            FileReaderSync = view.FileReaderSync,
            FileException = function FileException(type) {
            this.code = this[this.name = type];
        },
            file_ex_codes = ("NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR " + "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR").split(" "),
            file_ex_code = file_ex_codes.length,
            real_URL = view.URL || view.webkitURL || view,
            real_create_object_URL = real_URL.createObjectURL,
            real_revoke_object_URL = real_URL.revokeObjectURL,
            URL = real_URL,
            btoa = view.btoa,
            atob = view.atob,
            ArrayBuffer = view.ArrayBuffer,
            Uint8Array = view.Uint8Array;
        FakeBlob.fake = FB_proto.fake = true;
        while (file_ex_code--) {
            FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
        }
        if (!real_URL.createObjectURL) {
            URL = view.URL = {};
        }
        URL.createObjectURL = function (blob) {
            var type = blob.type,
                data_URI_header;
            if (type === null) {
                type = "application/octet-stream";
            }
            if (blob instanceof FakeBlob) {
                data_URI_header = "data:" + type;
                if (blob.encoding === "base64") {
                    return data_URI_header + ";base64," + blob.data;
                } else if (blob.encoding === "URI") {
                    return data_URI_header + "," + decodeURIComponent(blob.data);
                }if (btoa) {
                    return data_URI_header + ";base64," + btoa(blob.data);
                } else {
                    return data_URI_header + "," + encodeURIComponent(blob.data);
                }
            } else if (real_create_object_URL) {
                return real_create_object_URL.call(real_URL, blob);
            }
        };
        URL.revokeObjectURL = function (object_URL) {
            if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
                real_revoke_object_URL.call(real_URL, object_URL);
            }
        };
        FBB_proto.append = function (data /*, endings*/) {
            var bb = this.data;
            // decode data to a binary string
            if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                var str = "",
                    buf = new Uint8Array(data),
                    i = 0,
                    buf_len = buf.length;
                for (; i < buf_len; i++) {
                    str += String.fromCharCode(buf[i]);
                }
                bb.push(str);
            } else if (get_class(data) === "Blob" || get_class(data) === "File") {
                if (FileReaderSync) {
                    var fr = new FileReaderSync();
                    bb.push(fr.readAsBinaryString(data));
                } else {
                    // async FileReader won't work as BlobBuilder is sync
                    throw new FileException("NOT_READABLE_ERR");
                }
            } else if (data instanceof FakeBlob) {
                if (data.encoding === "base64" && atob) {
                    bb.push(atob(data.data));
                } else if (data.encoding === "URI") {
                    bb.push(decodeURIComponent(data.data));
                } else if (data.encoding === "raw") {
                    bb.push(data.data);
                }
            } else {
                if (typeof data !== "string") {
                    data += ""; // convert unsupported types to strings
                }
                // decode UTF-16 to binary string
                bb.push(unescape(encodeURIComponent(data)));
            }
        };
        FBB_proto.getBlob = function (type) {
            if (!arguments.length) {
                type = null;
            }
            return new FakeBlob(this.data.join(""), type, "raw");
        };
        FBB_proto.toString = function () {
            return "[object BlobBuilder]";
        };
        FB_proto.slice = function (start, end, type) {
            var args = arguments.length;
            if (args < 3) {
                type = null;
            }
            return new FakeBlob(this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding);
        };
        FB_proto.toString = function () {
            return "[object Blob]";
        };
        FB_proto.close = function () {
            this.size = 0;
            delete this.data;
        };
        return FakeBlobBuilder;
    }(view);

    view.Blob = function Blob(blobParts, options) {
        var type = options ? options.type || "" : "";
        var builder = new BlobBuilder();
        if (blobParts) {
            for (var i = 0, len = blobParts.length; i < len; i++) {
                builder.append(blobParts[i]);
            }
        }
        return builder.getBlob(type);
    };
})(typeof self !== "undefined" && self || typeof window !== "undefined" && window || undefined.content || undefined);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2015-01-04
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
// IE 10+ (native saveAs)
|| typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator)
// Everyone else
|| function (view) {
    "use strict";
    // IE <10 is explicitly unsupported

    if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var doc = view.document
    // only get URL when necessary in case Blob.js hasn't overridden it yet
    ,
        get_URL = function get_URL() {
        return view.URL || view.webkitURL || view;
    },
        save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
        can_use_save_link = "download" in save_link,
        click = function click(node) {
        var event = doc.createEvent("MouseEvents");
        event.initMouseEvent("click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        node.dispatchEvent(event);
    },
        webkit_req_fs = view.webkitRequestFileSystem,
        req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
        throw_outside = function throw_outside(ex) {
        (view.setImmediate || view.setTimeout)(function () {
            throw ex;
        }, 0);
    },
        force_saveable_type = "application/octet-stream",
        fs_min_size = 0
    // See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
    // https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
    // for the reasoning behind the timeout and revocation flow
    ,
        arbitrary_revoke_timeout = 500 // in ms
    ,
        revoke = function revoke(file) {
        var revoker = function revoker() {
            if (typeof file === "string") {
                // file is an object URL
                get_URL().revokeObjectURL(file);
            } else {
                // file is a File
                file.remove();
            }
        };
        if (view.chrome) {
            revoker();
        } else {
            setTimeout(revoker, arbitrary_revoke_timeout);
        }
    },
        dispatch = function dispatch(filesaver, event_types, event) {
        event_types = [].concat(event_types);
        var i = event_types.length;
        while (i--) {
            var listener = filesaver["on" + event_types[i]];
            if (typeof listener === "function") {
                try {
                    listener.call(filesaver, event || filesaver);
                } catch (ex) {
                    throw_outside(ex);
                }
            }
        }
    },
        FileSaver = function FileSaver(blob, name) {
        // First try a.download, then web filesystem, then object URLs
        var filesaver = this,
            type = blob.type,
            blob_changed = false,
            object_url,
            target_view,
            dispatch_all = function dispatch_all() {
            dispatch(filesaver, "writestart progress write writeend".split(" "));
        }
        // on any filesys errors revert to saving with object URLs
        ,
            fs_error = function fs_error() {
            // don't create more object URLs than needed
            if (blob_changed || !object_url) {
                object_url = get_URL().createObjectURL(blob);
            }
            if (target_view) {
                target_view.location.href = object_url;
            } else {
                var new_tab = view.open(object_url, "_blank");
                if (new_tab == undefined && typeof safari !== "undefined") {
                    //Apple do not allow window.open, see http://bit.ly/1kZffRI
                    view.location.href = object_url;
                }
            }
            filesaver.readyState = filesaver.DONE;
            dispatch_all();
            revoke(object_url);
        },
            abortable = function abortable(func) {
            return function () {
                if (filesaver.readyState !== filesaver.DONE) {
                    return func.apply(this, arguments);
                }
            };
        },
            create_if_not_found = { create: true, exclusive: false },
            slice;
        filesaver.readyState = filesaver.INIT;
        if (!name) {
            name = "download";
        }
        if (can_use_save_link) {
            object_url = get_URL().createObjectURL(blob);
            save_link.href = object_url;
            save_link.download = name;
            click(save_link);
            filesaver.readyState = filesaver.DONE;
            dispatch_all();
            revoke(object_url);
            return;
        }
        // Object and web filesystem URLs have a problem saving in Google Chrome when
        // viewed in a tab, so I force save with application/octet-stream
        // http://code.google.com/p/chromium/issues/detail?id=91158
        // Update: Google errantly closed 91158, I submitted it again:
        // https://code.google.com/p/chromium/issues/detail?id=389642
        if (view.chrome && type && type !== force_saveable_type) {
            slice = blob.slice || blob.webkitSlice;
            blob = slice.call(blob, 0, blob.size, force_saveable_type);
            blob_changed = true;
        }
        // Since I can't be sure that the guessed media type will trigger a download
        // in WebKit, I append .download to the filename.
        // https://bugs.webkit.org/show_bug.cgi?id=65440
        if (webkit_req_fs && name !== "download") {
            name += ".download";
        }
        if (type === force_saveable_type || webkit_req_fs) {
            target_view = view;
        }
        if (!req_fs) {
            fs_error();
            return;
        }
        fs_min_size += blob.size;
        req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
            fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
                var save = function save() {
                    dir.getFile(name, create_if_not_found, abortable(function (file) {
                        file.createWriter(abortable(function (writer) {
                            writer.onwriteend = function (event) {
                                target_view.location.href = file.toURL();
                                filesaver.readyState = filesaver.DONE;
                                dispatch(filesaver, "writeend", event);
                                revoke(file);
                            };
                            writer.onerror = function () {
                                var error = writer.error;
                                if (error.code !== error.ABORT_ERR) {
                                    fs_error();
                                }
                            };
                            "writestart progress write abort".split(" ").forEach(function (event) {
                                writer["on" + event] = filesaver["on" + event];
                            });
                            writer.write(blob);
                            filesaver.abort = function () {
                                writer.abort();
                                filesaver.readyState = filesaver.DONE;
                            };
                            filesaver.readyState = filesaver.WRITING;
                        }), fs_error);
                    }), fs_error);
                };
                dir.getFile(name, { create: false }, abortable(function (file) {
                    // delete file if it already exists
                    file.remove();
                    save();
                }), abortable(function (ex) {
                    if (ex.code === ex.NOT_FOUND_ERR) {
                        save();
                    } else {
                        fs_error();
                    }
                }));
            }), fs_error);
        }), fs_error);
    },
        FS_proto = FileSaver.prototype,
        saveAs = function saveAs(blob, name) {
        return new FileSaver(blob, name);
    };
    FS_proto.abort = function () {
        var filesaver = this;
        filesaver.readyState = filesaver.DONE;
        dispatch(filesaver, "abort");
    };
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;

    FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;

    return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || undefined.content);
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
    module.exports.saveAs = saveAs;
} else if ("function" !== "undefined" && __webpack_require__(42) !== null && __webpack_require__(18) != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
        return saveAs;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Test) {

    /**
     * Module encapsulatinh some tools assisting drawing
     * @type {{Test: *}}
     */
    var Module = {
        Test: Test
    };

    /**
     * Produces a minor/major scale tick set that matches the desired minor jump distance as close as possible
     * @param {float} DesiredJump1 - desired minor tick jump distance
     * @returns {{Jump1 {float} - minor tick jump distance, JumpReduc {int} - number of grouped jumps for a major tick}}
     */
    Module.getScaleJump = function (DesiredJump1) {
        var JumpPrototypes = [{ Jump1: 1, JumpReduc: 5 }, { Jump1: 2, JumpReduc: 5 }, { Jump1: 5, JumpReduc: 4 }];
        var mindist = 1.0e99;
        var bestjump;
        for (var JumpPrototypeNr in JumpPrototypes) {
            var q = Math.floor(Math.log(DesiredJump1 / JumpPrototypes[JumpPrototypeNr].Jump1) / Math.log(10));
            var TryJump1A = Math.pow(10, q) * JumpPrototypes[JumpPrototypeNr].Jump1;
            var TryJump1B = Math.pow(10, q + 1) * JumpPrototypes[JumpPrototypeNr].Jump1;
            if (Math.abs(TryJump1A - DesiredJump1) < mindist) {
                mindist = Math.abs(TryJump1A - DesiredJump1);
                bestjump = { Jump1: TryJump1A, JumpReduc: JumpPrototypes[JumpPrototypeNr].JumpReduc };
            }
            if (Math.abs(TryJump1B - DesiredJump1) < mindist) {
                mindist = Math.abs(TryJump1B - DesiredJump1);
                bestjump = { Jump1: TryJump1B, JumpReduc: JumpPrototypes[JumpPrototypeNr].JumpReduc };
            }
        }
        if (!bestjump) return -1;

        var frcdigits = -(Math.log(bestjump.Jump1 * bestjump.JumpReduc) / Math.log(10.0));
        bestjump.textDecimalCount = Math.max(0, Math.ceil(frcdigits));

        bestjump.value2String = function (val) {
            if (Math.abs(val) >= 100000) {
                return val.toExponential();
            } else return val.toFixed(this.textDecimalCount);
        };

        return bestjump;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM) {

    /**
     * Module encapsulating a set of classes that represent HTML controls that group other controls
     * @type {{}}
     */
    var Module = {};

    /**
     * Automatically converts a string to a static control. if the input was not a strung (e.g. a control), it is returned
     * @param {string} ctrl - string to be converted
     * @returns {AXM.Controls.Controls.Static}
     * @private
     */
    Module._autoDecorateString = function (ctrl) {
        if (typeof ctrl != 'string') return ctrl;else {
            return __webpack_require__(3).Static({ text: ctrl });
        }
    };

    /**
     * Base class for all compound controls
     * @returns {Object}
     * @constructor
     */
    Module.CompoundControlBase = function () {
        var compound = AXMUtils.object('@Control');
        compound._id = 'CT' + AXMUtils.getUniqueID();
        compound._members = [];

        /**
         * Sets the list of controls that are member of this compound control
         * @param [] ctrlSet - list of member controls
         * @returns {Object} - self
         */
        compound.set = function (ctrlSet) {
            compound._members = [];
            $.each(ctrlSet, function (idx, ctrl) {
                ctrl = Module._autoDecorateString(ctrl);
                AXMUtils.Test.checkIsType(ctrl, '@Control');
                compound.add(ctrl);
            });
            return compound;
        };

        /**
         * Removes all controls from the list of member controls
         */
        compound.clear = function () {
            compound._members = [];
        };

        /**
         * Adds a control to the list of member controls
         * @param {{}} ctrl - controll to add
         * @returns {Object} - added control
         */
        compound.add = function (ctrl) {
            ctrl = Module._autoDecorateString(ctrl);
            AXMUtils.Test.checkIsType(ctrl, '@Control');
            compound._members.push(ctrl);
            return ctrl;
        };

        /**
         * Attaches member controls html event handlers after DOM insertion
         */
        compound.attachEventHandlers = function () {
            $.each(compound._members, function (idx, member) {
                member.attachEventHandlers();
            });
        };

        /**
         * Detaches member controls html event handlers
         */
        compound.detachEventHandlers = function () {
            $.each(compound._members, function (idx, member) {
                member.detachEventHandlers();
            });
        };

        /**
         * Called by the framework when a control needs to be teared down.
         */
        compound.tearDown = function () {
            $.each(compound._members, function (idx, member) {
                member.tearDown();
            });
        };

        return compound;
    };

    /**
     * Implements a compound control grouping members controls vertically
     * @param {{}} settings - control settings
     * @param {int} settings.separator - size of the vertical separation between members
     * @param [Object] members - list of member controls
     * @returns {Object} - compound control instance
     * @constructor
     */
    Module.GroupVert = function (settings, members) {
        var compound = Module.CompoundControlBase();
        if (!settings) settings = {};
        compound._separator = settings.separator || 0;
        if (members) compound.set(members);

        /**
         * Specifies the vertical separation size between the members
         * @param {int} sep - separations size
         * @returns {Object} - self
         */
        compound.setSeparator = function (sep) {
            compound._separator = sep;
            return compound;
        };

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        compound.createHtml = function () {
            var div = DOM.Div({ id: compound._id + '_wrapper' });
            $.each(compound._members, function (idx, member) {
                var elemDiv = DOM.Div({ parent: div });
                if (idx > 0) {
                    if (compound._separator) elemDiv.addElem('<div style="height:{h}px"/>'.AXMInterpolate({ h: compound._separator }));
                }
                elemDiv.addElem(member.createHtml());
            });
            return div.toString();
        };

        compound.liveUpdate = function () {
            var $El = $('#' + compound._id + '_wrapper');
            $El.html(compound.createHtml());
            compound.attachEventHandlers();
        };

        return compound;
    };

    /**
     * Implements a compound control grouping members controls horizontally
     * @param {{}} settings - control settings
     * @param {int} settings.separator - size of the horizontal separation between members
     * @param [Object] members - list of member controls
     * @returns {Object} - compound control instance
     * @constructor
     */
    Module.GroupHor = function (settings, members) {
        var compound = Module.CompoundControlBase();
        if (!settings) settings = {};
        compound._separator = settings.separator || 0;
        compound._noWrap = settings.noWrap || false;
        if (members) compound.set(members);

        /**
         * Specifies the horizontal separation size between the members
         * @param {int} sep - separations size
         * @returns {Object} - self
         */
        compound.setSeparator = function (sep) {
            compound._separator = sep;
            return compound;
        };

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        compound.createHtml = function () {
            var div = DOM.Div();
            if (compound._noWrap) div.addStyle('white-space', 'nowrap');
            var maxElem = compound._members.length - 1;
            $.each(compound._members, function (idx, member) {
                var elemDiv = DOM.Div({ parent: div });
                elemDiv.addStyle('display', 'inline-block');
                //                    elemDiv.addStyle('position', 'relative');
                var alignStr = settings.verticalAlignCenter ? 'center' : 'top';
                if (settings.verticalAlignBaseline) alignStr = 'baseline';
                elemDiv.addStyle('vertical-align', alignStr);
                elemDiv.addStyle('white-space', 'normal');
                if (idx < maxElem) elemDiv.addStyle('margin-right', compound._separator + 'px');
                elemDiv.addElem(member.createHtml());
            });
            return div.toString();
        };

        return compound;
    };

    /**
     * Implements a compound control grouping member controls in a grid way
     * @param {{}} settings - control settings
     * @param {int} settings.sepH - horizontal separation size between columns
     * @param {int} settings.sepV - vertical separation size between rows
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Grid = function (settings) {
        var grid = Module.CompoundControlBase();

        if (!settings) settings = {};

        grid._rows = [];
        grid.sepH = settings.sepH || 12;
        grid.sepV = settings.sepV || 7;
        grid.alternatingLines = settings.alternatingLines;
        grid.className = settings.className;

        grid.set = null; //not applicable here
        grid._parentAdd = grid.add;
        grid.add = null; //not applicable here


        /**
         * Sets the member control for an individual cell
         * @param {int} rowNr - row number
         * @param {int} colNr - column number
         * @param {Object} ctrl - member control to set
         * @returns {AXM.Controls.Controls.Static|*}
         */
        grid.setItem = function (rowNr, colNr, ctrl) {
            ctrl = Module._autoDecorateString(ctrl);
            grid._parentAdd(ctrl);
            while (grid._rows.length <= rowNr) {
                grid._rows.push([]);
            }while (grid._rows[rowNr].length <= colNr) {
                grid._rows[rowNr].push(null);
            }grid._rows[rowNr][colNr] = ctrl;
            return ctrl;
        };

        grid.clearData = function () {
            grid._rows = [];
        };

        /**
         * Returns the number of rows
         * @returns {Number}
         */
        grid.getRowCount = function () {
            return grid._rows.length;
        };

        /**
         * Returns the html implementing the control
         * @returns {String|string|*}
         */
        grid.createHtml = function () {
            var div = DOM.Div({ id: grid._id + '_wrapper' });
            div.addStyle('display', 'inline-block');

            var className = "";
            if (grid.alternatingLines) className = "AlternatingLineGrid";
            if (grid.className) className = grid.className;
            var st = '<table class="{clss}">'.AXMInterpolate({ clss: className });
            $.each(grid._rows, function (rowNr, row) {
                st += '<tr>';
                $.each(row, function (colNr, item) {
                    var token = 'td';
                    if (settings.hasHeader && rowNr == 0) token = 'th';
                    st += '<{token} style="padding-right:{sepH}px;padding-bottom:{sepV}px;">'.AXMInterpolate({
                        token: token,
                        sepH: grid.sepH, sepV: grid.sepV
                    });
                    if (item != null) st += item.createHtml();
                    st += '</{token}>'.AXMInterpolate({ token: token });
                });
                st += '</tr>';
            });
            st += '</table>';
            div.addElem(st);

            return div.toString();
        };

        grid.liveUpdate = function () {
            var $El = $('#' + grid._id + '_wrapper');
            $El.html(grid.createHtml());
            grid.attachEventHandlers();
        };

        return grid;
    };

    ///////////////////////////////////////////////////////////////////////////////////


    /**
     * Base class for a control that wraps a single other control
     * @param {Object} ctrl - control to be wrapped
     * @returns {*|Object}
     * @constructor
     */
    Module.WrapperControlBase = function (ctrl) {
        var wrapper = AXMUtils.object('@Control');
        if (ctrl !== null) AXMUtils.Test.checkIsType(ctrl, '@Control');
        wrapper._id = 'CT' + AXMUtils.getUniqueID();
        wrapper._member = ctrl;

        /**
         * Attaches the wrapped control html event handlers after DOM insertion
         */
        wrapper.attachEventHandlers = function () {
            if (wrapper._member) wrapper._member.attachEventHandlers();
        };

        /**
         * Detaches the wrapped control html event handlers
         */
        wrapper.detachEventHandlers = function () {
            if (wrapper._member) wrapper._member.detachEventHandlers();
        };

        /**
         * Gets the jQuery element of the wrapper control
         * @returns {jQuery}
         */
        wrapper.get$El = function () {
            return $('#' + wrapper._id);
        };

        wrapper.getMember = function () {
            return wrapper._member;
        };

        /**
         * Called by the framework when a control needs to be teared down.
         */
        wrapper.tearDown = function () {
            if (wrapper._member) wrapper._member.tearDown();
        };

        return wrapper;
    };

    Module.Transferrer = function (ctrl) {
        var wrapper = Module.WrapperControlBase(ctrl);
        wrapper.extend('@ControlTransferrer');

        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            if (wrapper._member) {
                wrapper._memDivId = AXMUtils.getUniqueID();
                var memdiv = DOM.Div({ id: wrapper._memDivId, parent: div });
                memdiv.addElem(wrapper._member.createHtml());
            }
            return div.toString();
        };

        wrapper.transferFrom = function (src) {
            AXMUtils.Test.checkIsType(src, '@ControlTransferrer');
            if (wrapper._member) AXMUtils.reportBug("Non-empty dest transferrer");
            var ctrl = src.getMember();
            if (!src) AXMUtils.reportBug("Empty source transferrer");
            wrapper._member = ctrl;
            src._member = null;
            $("#" + src._memDivId).detach().appendTo('#' + wrapper._id);
            wrapper._memDivId = src._memDivId;
            src._memDivId = null;
        };

        return wrapper;
    };

    /**
     * Wraps a control in a styled DIV
     * @param {Object} ctrl - control to be wrapped
     * @param {string} styleClass - css class name
     * @returns {Object} - control instance
     * @constructor
     */
    Module.WrapperStyled = function (ctrl, styleClass) {
        var wrapper = Module.WrapperControlBase(ctrl);

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            div.addCssClass(styleClass);
            div.addElem(wrapper._member.createHtml());
            return div.toString();
        };

        return wrapper;
    };

    /**
     * Wraps a margin around a control
     * @param {Object} ctrl - control to be wrapped
     * @param {int} marginLeft - margin size
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Margin = function (ctrl, marginLeft, marginRight, marginTop, marginBottom) {
        var wrapper = Module.WrapperControlBase(ctrl);

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            if (marginRight == undefined) {
                marginRight = marginLeft;
                marginTop = marginLeft;
                marginBottom = marginLeft;
            }
            div.addStyle('margin-left', marginLeft + 'px');
            div.addStyle('margin-right', marginRight + 'px');
            div.addStyle('margin-top', marginTop + 'px');
            div.addStyle('margin-bottom', marginBottom + 'px');
            //div.addStyle('display', 'inline-block');
            div.addElem(wrapper._member.createHtml());
            return div.toString();
        };

        return wrapper;
    };

    /**
     * Wraps a fixed width box around a control
     * @param {Object} ctrl - control to be wrapped
     * @param {int} width - width
     * @returns {Object} - control instance
     * @constructor
     */
    Module.FixedWidth = function (ctrl, width, isMinimum, isMaximum) {
        var wrapper = Module.WrapperControlBase(ctrl);

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            if (isMinimum) div.addStyle('min-width', width + 'px');else if (isMaximum) div.addStyle('max-width', width + 'px');else div.addStyle('width', width + 'px');
            div.addElem(wrapper._member.createHtml());
            return div.toString();
        };

        return wrapper;
    };

    /**
     * Wraps a standard sized margin around a control
     * @param {Object} ctrl - control to be wrapped
     * @returns {Object} - control instance
     * @constructor
     */
    Module.StandardMargin = function (ctrl) {
        var wrapper = Module.WrapperControlBase(ctrl);

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            div.addCssClass('AXMFormStandardMargin');
            //div.addStyle('margin-left', marginLeft+'px');
            //div.addStyle('display', 'inline-block');
            div.addElem(wrapper._member.createHtml());
            return div.toString();
        };

        return wrapper;
    };

    /**
     * Wraps a control in a right align box
     * @param {Object} ctrl - control to be wrapped
     * @returns {Object} - control instance
     * @constructor
     */
    Module.AlignRight = function (ctrl) {
        var wrapper = Module.WrapperControlBase(ctrl);

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            div.addStyle('position', 'absolute');
            div.addStyle('right', '0px');
            div.addStyle('top', '0px');
            div.addStyle('display', 'inline-block');
            div.addElem(wrapper._member.createHtml());
            return div.toString();
        };

        return wrapper;
    };

    /**
     * Wraps a control in a section with a header
     * @param {Object} ctrl - wrapped control
     * @param {string} title - section title
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Section = function (ctrl, title) {
        var wrapper = Module.WrapperControlBase(ctrl);
        wrapper._title = title;

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var divContainer = DOM.Div({ id: wrapper._id });
            var divTitle = DOM.Div({ parent: divContainer });
            divTitle.addCssClass('AXMFormSectionHeader');
            divTitle.addElem(wrapper._title);
            var divBody = DOM.Div({ parent: divContainer });
            divBody.addElem(wrapper._member.createHtml());
            return divContainer.toString();
        };

        return wrapper;
    };

    /**
     * Creates an icon in the background of a control
     * @param {Object} ctrl - wrapped control
     * @param {string} icon - icon name
     * @returns {Object} - control instance
     * @constructor
     */
    Module.BackgroundIcon = function (ctrl, icon) {
        var wrapper = Module.WrapperControlBase(ctrl);

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var divContainer = DOM.Div({ id: wrapper._id });
            divContainer.addStyle('position', 'relative');
            var str = '<div style="position:absolute;top:-15px;left:-7px;z-index:0"><i class="fa fa-history" style="font-size: 80px;color:rgb(225, 240, 253)"></i></div>';
            divContainer.addElem(str);
            var divBody = DOM.Div({ parent: divContainer });
            divBody.addStyle('position', 'relative');
            //divBody.addStyle('top', '0px');
            divBody.addStyle('z-index', '1');
            divBody.addElem(wrapper._member.createHtml());
            return divContainer.toString();
        };

        return wrapper;
    };

    /**
     * Wraps a scrollable DIV around a control
     * @param {Object} ctrl - wrapped control
     * @param {int} heigth - DIV height
     * @returns {Object} - object instance
     * @constructor
     */
    Module.VScroller = function (ctrl, heigth) {
        var wrapper = Module.WrapperControlBase(ctrl);

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            div.addCssClass('AXMFormVScroller');
            div.addStyle('height', heigth + 'px');
            div.addElem(wrapper._member.createHtml());
            return div.toString();
        };

        return wrapper;
    };

    /**
     * Wraps a DIV around a control that can be dynamically shown or hidden
     * @param {Object} ctrl - wrapped control
     * @param {boolean} hidden - default DIV visibility
     * @returns {Object} - control instance
     * @constructor
     */
    Module.Hider = function (ctrl, hidden) {
        var wrapper = Module.WrapperControlBase(ctrl);
        wrapper._show = !hidden;
        wrapper._animation = true;
        wrapper._animateOpacity = false;

        wrapper.setAnimateOpacity = function () {
            wrapper._animateOpacity = true;
            return wrapper;
        };

        wrapper.setNoAnimation = function () {
            wrapper._animation = false;
            return wrapper;
        };

        /**
         * Returns the html implementing the wrapped control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div({ id: wrapper._id });
            if (!wrapper._show) div.addStyle('display', 'none');
            div.addElem(wrapper._member.createHtml());
            return div.toString();
        };

        /**
         * Changes the visibility of the control
         * @param {boolean} status - new visibility
         */
        wrapper.show = function (status) {
            if (wrapper._show != status) {
                wrapper._show = status;
                if (!wrapper._animation) {
                    if (status) wrapper.get$El().show();else wrapper.get$El().hide();
                } else {
                    if (!wrapper._animateOpacity) {
                        if (status) wrapper.get$El().show(200);else wrapper.get$El().hide(200);
                    } else {
                        if (status) {
                            wrapper.get$El().css("opacity", 0);
                            wrapper.get$El().show();
                            wrapper.get$El().fadeTo(200, 1);
                        } else {
                            wrapper.get$El().fadeTo(200, 0, function () {
                                wrapper.get$El().hide();
                            });
                        }
                    }
                }
            }
        };

        return wrapper;
    };

    ///////////////////////////////////////////////////////////////////////////////////


    /**
     * Base class implementing a decoration element control
     * @returns {Object} - control instance
     * @constructor
     */
    Module.DecoratorBase = function () {
        var wrapper = AXMUtils.object('@Control');
        wrapper._id = 'CT' + AXMUtils.getUniqueID();

        wrapper.attachEventHandlers = function () {};

        /**
         * Detaches member controls html event handlers
         */
        wrapper.detachEventHandlers = function () {};

        /**
         * Called by the framework when a control needs to be teared down.
         */
        wrapper.tearDown = function () {};

        return wrapper;
    };

    /**
     * Implements a horizontal divider element control
     * @returns {Object} - control instance
     * @constructor
     */
    Module.DividerH = function () {
        var wrapper = Module.DecoratorBase();

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div().addStyle('display', 'inline-block').addStyle('vertical-align', 'middle').addStyle('width', '3px').addStyle('height', '25px').addStyle('background-color', 'rgb(0,0,0)').addStyle('opacity', 0.15).addStyle('margin-left', '7px').addStyle('margin-right', '7px');
            return div.toString();
        };

        return wrapper;
    };

    /**
     * Implements a horizontal separation control
     * @param {int} w - horizontal size
     * @returns {Object} - control instance
     * @constructor
     */
    Module.SeparatorH = function (w) {
        var wrapper = Module.DecoratorBase();

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div().addStyle('display', 'inline-block').addStyle('width', w + 'px').addStyle('height', '1px');
            return div.toString();
        };
        return wrapper;
    };

    /**
     * Implements a vertical separation control
     * @param {int} h - vertical size
     * @returns {Object} - control instance
     * @constructor
     */
    Module.SeparatorV = function (h) {
        var wrapper = Module.DecoratorBase();

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            var div = DOM.Div().addStyle('width', '1px').addStyle('height', h + 'px');
            return div.toString();
        };
        return wrapper;
    };

    /**
     * Implements a control displaying an icon
     * @param {string} icon - icon name
     * @returns {Object} - control instance
     * @constructor
     */
    Module.BigIcon = function (icon) {
        var wrapper = Module.DecoratorBase();

        /**
         * Returns the html implementing the control
         * @returns {string}
         */
        wrapper.createHtml = function () {
            return '<i class="AXMBigIcon fa {icon}"></i>'.AXMInterpolate({ icon: icon });
        };
        return wrapper;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(10), __webpack_require__(16), __webpack_require__(11), __webpack_require__(6), __webpack_require__(5), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Utils, Frame, PanelForm, PanelHtml, Popupwin, SimplePopups, Controls) {

    /**
     * Module encapsulating a popup window that is displaying static documentation content
     * @type {{}}
     */
    var Module = {};

    Module._docRoot = '/static/docs';

    /**
     * Sets the root folder where documentation is located
     * @param {string docRoot - documentation root
     */
    Module.setDocRoot = function (docRoot) {
        Module._docRoot = docRoot;
    };

    /**
     * Fetches a document from the server in an async way
     * @param {string} docId - document identifier
     * @param {function} onCompleted - called when the fetch was completed (content provided as argument)
     * @param {function} onFailed - called when the fetch failed
     * @param {{}} settings
     * @param {boolean} settings.blocking - if true, a blocking message is displayed for the duration of the fetching process
     */
    Module.fetchDocument = function (docId, onCompleted, onFailed, settings) {
        var url = Module._docRoot + '/{id}.html'.AXMInterpolate({ id: docId });
        if (settings.blocking) var busyid = SimplePopups.setBlockingBusy('Fetching document');
        $.get(url, {}).done(function (data) {
            if (busyid) SimplePopups.stopBlockingBusy(busyid);
            var content = $('<div/>').append(data).find('.AXMDocContent').html();
            content = _TRL(content);
            onCompleted(content);
        }).fail(function () {
            if (busyid) SimplePopups.stopBlockingBusy(busyid);
            if (onFailed) onFailed();
        });
    };

    /**
     * Creates a popup window that is displaying static documentation content
     * @param {string} docId - identifier of the documentation item to be shown
     * @returns {{}} - popup window instance
     * @constructor
     */
    Module.create = function (docId) {

        Module.topicStack = [];
        Module.topicStackPointer = -1;

        var win = Popupwin.create({
            title: 'Documentation',
            sizeX: 750,
            sizeY: 650,
            autoCenter: true,
            closeOnEscape: true,
            canDock: true
        });

        /**
         * Initialises the popup
         * @private
         */
        var _init = function _init() {
            var form1 = PanelForm.create('controls');

            win.panelContent = PanelHtml.create();
            win.panelContent.enableVScrollBar();
            var theFrame = Frame.FrameFinalCommands(win.panelContent);
            //rootFrame.addMember(theFrame);

            win.bt_previous = theFrame.addCommand({
                icon: 'fa-arrow-left'
            }, win.onPrevious);

            win.bt_next = theFrame.addCommand({
                icon: 'fa-arrow-right'
            }, win.onNext);

            win.setRootFrame(theFrame);
            win.start();
            win._updateButtons();
        };

        /**
         * Navigates to the previously accessed documentation topic
         */
        win.onPrevious = function () {
            if (Module.topicStackPointer > 0) {
                Module.topicStackPointer--;
                win._loadDocUrlSub(Module.topicStack[Module.topicStackPointer].url, Module.topicStack[Module.topicStackPointer].scrollPos);
                win._updateButtons();
            }
        };

        /**
         * When the user navigated back to the previously accessed documentation topic, nagivates forward to the topic before this back navigation
         */
        win.onNext = function () {
            if (Module.topicStackPointer < Module.topicStack.length - 1) {
                Module.topicStackPointer++;
                win._loadDocUrlSub(Module.topicStack[Module.topicStackPointer].url, Module.topicStack[Module.topicStackPointer].scrollPos);
                win._updateButtons();
            }
        };

        /**
         * Updates the enabled state of the navigation buttons
         * @private
         */
        win._updateButtons = function () {
            win.bt_previous.setEnabled(Module.topicStackPointer > 0);
            win.bt_next.setEnabled(Module.topicStackPointer < Module.topicStack.length - 1);
        };

        /**
         * Loads the content of the documentation item
         * @param {string} docId - documentation item id
         */
        win.loadDocId = function (docId) {
            win.loadDocUrl(Module._docRoot + '/{docid}.html'.AXMInterpolate({ docid: docId }));
        };

        /**
         * Loads the content of an url
         * @param {string} url - url providing the content
         */
        win.loadDocUrl = function (url) {
            if (Module.topicStackPointer >= 0) Module.topicStack[Module.topicStackPointer].scrollPos = win.panelContent.get$El().scrollTop();
            Module.topicStack = Module.topicStack.slice(0, Module.topicStackPointer + 1);
            Module.topicStack.push({ url: url, scrollPos: 0 });
            Module.topicStackPointer = Module.topicStack.length - 1;
            win._loadDocUrlSub(url);
            win._updateButtons();
        };

        /**
         * Implements loading the content of an url
         * @param {string} url
         * @param {int} scrollPos - vertical scroll position
         * @private
         */
        win._loadDocUrlSub = function (url, scrollPos) {
            var busyid = SimplePopups.setBlockingBusy('Fetching document');
            $.get(url, {}).done(function (data) {
                SimplePopups.stopBlockingBusy(busyid);
                var content = $('<div/>').append(data).find('.AXMDocContent').html();
                content = _TRL(content);
                win._loadContent('<div class="AXMDocContent">' + content + '</div>', scrollPos);
            }).fail(function () {
                SimplePopups.stopBlockingBusy(busyid);
                alert("Failed to download documentation item '" + docId + "'");
            });
            win._updateButtons();
        };

        /**
         * Sets content to the popup
         * @param {string} content - html content
         * @param {int} scrollPos
         * @private
         */
        win._loadContent = function (content, scrollPos) {
            win.panelContent.setContent(content);
            if (Utils.isSuperUser()) win.panelContent.get$El().find('.SuperUserOnly').css('display', 'inherit');
            if (scrollPos) win.panelContent.get$El().scrollTop(scrollPos);else win.panelContent.get$El().scrollTop(0);
            win.panelContent.get$El().find('.AXMDocLink').click(function (ev) {
                var href = $(this).attr('href');
                win.loadDocUrl(href);
                ev.stopPropagation();
                ev.preventDefault();
                return false;
            });
        };

        _init();

        win.loadDocId(docId);
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, Color) {

    var Module = {};

    Module.colInfo = function (id) {
        var coldef = AXMUtils.object('@ColInfo');
        coldef._id = id;
        coldef._name = id;
        coldef._dispSize = 140;
        coldef._onOpen = null;
        coldef._canSort = false;
        coldef._isVisibleInTable = true;
        coldef._categories = null;

        coldef.setName = function (iName) {
            coldef._name = iName;
            return coldef;
        };

        coldef.setDispSize = function (dispSize) {
            coldef._dispSize = dispSize;
            return coldef;
        };

        coldef.setOnOpen = function (onOpen) {
            coldef._onOpen = onOpen;
            return coldef;
        };

        coldef.disableSort = function () {
            coldef._canSort = false;
            return coldef;
        };

        coldef.enableSort = function () {
            coldef._canSort = true;
            return coldef;
        };

        coldef.setIsVisibleInTable = function (visible) {
            coldef._isVisibleInTable = visible;
        };

        coldef.getId = function () {
            return coldef._id;
        };

        coldef.getName = function () {
            return coldef._name;
        };

        coldef.canOpen = function () {
            return !!coldef._onOpen;
        };

        coldef.canSort = function () {
            return coldef._canSort;
        };

        coldef.isVisibleInTable = function () {
            return coldef._isVisibleInTable;
        };

        coldef.callOnOpen = function () {
            if (!coldef.canOpen()) AXMUtils.reportBug('No column open handler');
            coldef._onOpen();
        };

        //overridable:
        coldef.content2DisplayString = function (content) {
            if (content === null) return '';
            return String(content);
        };

        //overridable:
        coldef.content2TextString = function (content) {
            if (content === null || content === undefined) return '';
            return String(content);
        };

        //overridable (should return an AXM.Color object):
        coldef.content2BackgroundColor = function (content) {
            return null;
        };

        //overridable (should return an AXM.Color object):
        coldef.content2ForegroundColor = function (content) {
            return null;
        };

        coldef.setFieldCategories = function (catInfo) {
            AXMUtils.Test.checkIsType(catInfo, '@FieldCategoryInfo');
            coldef._categories = catInfo;
        };

        coldef.hasFieldCategories = function () {
            return coldef._categories != null;
        };

        coldef.getFieldCategories = function () {
            if (!coldef._categories) AXMUtils.Test.reportBug("Field does not have categories: " + coldef._id);
            return coldef._categories;
        };

        return coldef;
    };

    Module.tableInfo = function (tableId) {
        var tabledef = AXMUtils.object('@TableInfo');
        tabledef.tableId = tableId;
        tabledef._columns = [];
        tabledef._map_columns = {};
        tabledef._onOpenRow = null;
        tabledef._canSelect = false;

        tabledef.addColumn = function (colId) {
            AXMUtils.Test.checkIsString(colId);
            var colInfo = Module.colInfo(colId);
            tabledef._columns.push(colInfo);
            tabledef._map_columns[colId] = colInfo;
            return colInfo;
        };

        tabledef.setOnOpenRow = function (handler) {
            tabledef._onOpenRow = handler;
        };

        tabledef.makeCanSelect = function () {
            tabledef._canSelect = true;
        };

        tabledef.getColumns = function () {
            return tabledef._columns;
        };

        tabledef.delColumn = function (colId) {
            delete tabledef._map_columns[colId];
            var colIdx = -1;
            $.each(tabledef._columns, function (idx, colInfo) {
                if (colInfo.getId() == colId) colIdx = idx;
            });
            if (colIdx >= 0) tabledef._columns.splice(colIdx, 1);
        };

        tabledef.hasColumn = function (colId) {
            var colInfo = tabledef._map_columns[colId];
            return !!colInfo;
        };

        tabledef.getColumn = function (colId) {
            var colInfo = tabledef._map_columns[colId];
            if (!colInfo) AXMUtils.Test.reportBug('Invalid column {colid} for table {tableid}'.AXMInterpolate({ colid: colId, tableid: tabledef.tableId }));
            return colInfo;
        };

        tabledef.getColumn_Optional = function (colId) {
            var colInfo = tabledef._map_columns[colId];
            return colInfo;
        };

        tabledef.canOpenRow = function () {
            return !!tabledef._onOpenRow;
        };

        tabledef.canSelect = function () {
            return tabledef._canSelect;
        };

        tabledef.callOnOpenRow = function (rowNr, settings, tableData) {
            if (!tabledef.canOpenRow()) AXMUtils.reportBug('No row open handler');
            tabledef._onOpenRow(rowNr, settings, tableData);
        };

        return tabledef;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(21), __webpack_require__(4), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DrawUtils, DOM, PanelCanvasZoomPan) {

    /**
     * Module encapsulating a panel with a html5 canvas element with X-Y plotting features
     * @type {{}}
     */
    var Module = {};

    /**
     * Implements a panel that contains a html5 canvas element with X-Y plotting features
     * @param {string} id - panel type id
     * @param {{}} - settings
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.create = function (id, settings) {
        var panel = PanelCanvasZoomPan.create(id, settings);
        panel._xLabel = '';
        panel._yLabel = '';

        /**
         * Define x label
         * @param {string} txt - label
         */
        panel.setXLabel = function (txt) {
            panel._xLabel = txt;
        };

        /**
         * Define y label
         * @param {string} txt - label
         */
        panel.setYLabel = function (txt) {
            panel._yLabel = txt;
        };

        /**
         * Draw the X scale
         * @param drawInfo
         */
        panel.drawXScale = function (drawInfo) {
            var ctx = drawInfo.ctx;
            var scaleX = panel.getXScale();
            var offsetX = panel.getXOffset();
            var plotLimitXMin = panel.xScaler.getMinVisibleRange();
            var plotLimitXMax = panel.xScaler.getMaxVisibleRange();
            ctx.save();
            ctx.font = "10px Arial";
            ctx.fillStyle = "rgb(0,0,0)";
            ctx.textAlign = 'center';
            var scale = DrawUtils.getScaleJump(30 / scaleX);
            var ticks = [];
            for (var i = Math.ceil(plotLimitXMin / scale.Jump1); i <= Math.floor(plotLimitXMax / scale.Jump1); i++) {
                var tick = {};
                tick.value = i * scale.Jump1;
                if (i % scale.JumpReduc == 0) {
                    tick.label = scale.value2String(tick.value);
                }
                ticks.push(tick);
            }
            $.each(ticks, function (idx, tick) {
                if (tick.value >= plotLimitXMin && tick.value <= plotLimitXMax) {
                    var px = Math.round(tick.value * scaleX + offsetX) - 0.5;
                    if (tick.label) {
                        ctx.fillText(tick.label, px, drawInfo.sizeY - panel.scaleMarginY + 13);
                        if (tick.label2) ctx.fillText(tick.label2, px, drawInfo.sizeY - panel.scaleMarginY + 23);
                        ctx.strokeStyle = "rgba(0,0,0,0.2)";
                    } else {
                        ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    }
                    if (!drawInfo.scaleBorderOnly) {
                        ctx.beginPath();
                        ctx.moveTo(px, 0);
                        ctx.lineTo(px, drawInfo.sizeY - panel.scaleMarginY);
                        ctx.stroke();
                    }
                }
            });
            ctx.fillText(panel._xLabel, drawInfo.sizeX / 2, drawInfo.sizeY - 10);
            ctx.restore();
        };

        /**
         * Draw the y scale
         * @param drawInfo
         */
        panel.drawYScale = function (drawInfo) {
            var ctx = drawInfo.ctx;
            var scaleY = panel.getYScale();
            var offsetY = panel.getYOffset();
            var plotLimitYMin = panel.yScaler.getMinVisibleRange();
            var plotLimitYMax = panel.yScaler.getMaxVisibleRange();

            ctx.save();
            ctx.font = "10px Arial";
            ctx.fillStyle = "rgb(0,0,0)";
            ctx.textAlign = 'center';

            var scale = DrawUtils.getScaleJump(30 / Math.abs(scaleY));
            var ticks = [];
            for (var i = Math.ceil(plotLimitYMin / scale.Jump1); i <= Math.floor(plotLimitYMax / scale.Jump1); i++) {
                var tick = {};
                tick.value = i * scale.Jump1;
                if (i % scale.JumpReduc == 0) {
                    tick.label = scale.value2String(tick.value);
                }
                ticks.push(tick);
            }

            $.each(ticks, function (idx, tick) {
                if (tick.value >= plotLimitYMin && tick.value <= plotLimitYMax) {
                    var py = Math.round(tick.value * scaleY + offsetY) - 0.5;
                    if (tick.label) {
                        ctx.save();
                        ctx.translate(panel.scaleMarginX - 5, py);
                        ctx.rotate(-Math.PI / 2);
                        if (!tick.label2) ctx.fillText(tick.label, 0, 0);else {
                            ctx.fillText(tick.label, 0, -10);
                            ctx.fillText(tick.label2, 0, 0);
                        }
                        ctx.restore();
                        ctx.strokeStyle = "rgba(0,0,0,0.2)";
                    } else {
                        ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    }
                    if (!drawInfo.scaleBorderOnly) {
                        ctx.beginPath();
                        ctx.moveTo(panel.scaleMarginX, py);
                        ctx.lineTo(drawInfo.sizeX, py);
                        ctx.stroke();
                    }
                }
            });

            ctx.save();
            ctx.translate(15, drawInfo.sizeY / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(panel._yLabel, 0, 0);
            ctx.restore();

            ctx.restore();
        };

        /**
         * Converts logical x coordinate to window x coordinate
         * @param {float} vlx - logical coordinate
         * @returns {float} - window coordinate
         */
        panel.coordXLogic2Win = function (vlx) {
            return vlx * panel.scaleX + panel.offsetX;
        };

        /**
         * Converts logical y coordinate to window y coordinate
         * @param {float} vly - logical coordinate
         * @returns {float} - window coordinate
         */
        panel.coordYLogic2Win = function (vly) {
            return vly * panel.scaleY + panel.offsetY;
        };

        /**
         * Converts window x coordinate to logical x coordinate
         * @param {float} vlx - window coordinate
         * @returns {float} - logical coordinate
         */
        panel.coordXWin2Logic = function (vlx) {
            return (vlx - panel.offsetX) / panel.scaleX;
        };

        /**
         * Converts window y coordinate to logical y coordinate
         * @param {float} vly - window coordinate
         * @returns {float} - logical coordinate
         */
        panel.coordYWin2Logic = function (vly) {
            return (vly - panel.offsetY) / panel.scaleY;
        };

        /**
         * To be implemented by derived class to define the plot
         * @param drawInfo
         */
        panel.drawPlot = function (drawInfo) {};

        /**
         * Draws an individual selected point
         * @param drawInfo
         * @param {float} vlx - logical x coordinae
         * @param {float} vly - logical y coordinate
         * @param {float} size - point size
         */
        panel.drawSel = function (drawInfo, vlx, vly, size) {
            var px = vlx * drawInfo.scaleX + drawInfo.offsetX;
            var py = vly * drawInfo.scaleY + drawInfo.offsetY;
            var ctx = drawInfo.ctx;
            ctx.beginPath();
            ctx.arc(px, py, size, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.stroke();
        };

        /**
         * Draws an individual  point
         * @param drawInfo
         * @param {float} vlx - logical x coordinae
         * @param {float} vly - logical y coordinate
         * @param {float} size - point size
         */
        panel.drawPoint = function (drawInfo, vlx, vly, size, drawOutline) {
            if (size < 0) debugger;
            var px = /*Math.round*/vlx * drawInfo.scaleX + drawInfo.offsetX;
            var py = /*Math.round*/vly * drawInfo.scaleY + drawInfo.offsetY;
            var ctx = drawInfo.ctx;
            ctx.beginPath();
            ctx.arc(px, py, size, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.fill();
            if (drawOutline) ctx.stroke();
        };

        /**
         * Draws a text labe;
         * @param drawInfo
         * @param {float} vlx - logical x coordinate
         * @param {float} vly - logical y coordinate
         * @param {float} offset - offset of the label
         * @param {string} content - label text
         */
        panel.drawLabel = function (drawInfo, vlx, vly, offset, content) {
            var px = vlx * drawInfo.scaleX + drawInfo.offsetX;
            var py = vly * drawInfo.scaleY + drawInfo.offsetY;
            var ctx = drawInfo.ctx;
            ctx.fillText(content, px + offset, py + offset);
        };

        /**
         * Implements drawing the plot
         * @param drawInfo
         */
        panel.drawCenter = function (drawInfo) {
            var ctx = drawInfo.ctx;
            var scaleX = panel.getXScale();
            var offsetX = panel.getXOffset();
            var scaleY = panel.getYScale();
            var offsetY = panel.getYOffset();
            drawInfo.scaleX = scaleX;drawInfo.offsetX = offsetX;
            drawInfo.scaleY = scaleY;drawInfo.offsetY = offsetY;
            panel.scaleX = scaleX;panel.offsetX = offsetX;
            panel.scaleY = scaleY;panel.offsetY = offsetY;

            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, drawInfo.sizeX, drawInfo.sizeY);
            ctx.fillStyle = "#000000";

            panel.drawPlot(drawInfo);
        };

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(7), __webpack_require__(6), __webpack_require__(10), __webpack_require__(16), __webpack_require__(33), __webpack_require__(3), __webpack_require__(5), __webpack_require__(32), __webpack_require__(24), __webpack_require__(37), __webpack_require__(62), __webpack_require__(63), __webpack_require__(64), __webpack_require__(65)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Msg, PopupWindow, Frame, PanelForm, PanelTable, Controls, SimplePopups, TableData, TableInfo, ViewRow, CalcProperty, ExecuteCode, CopyProperty, Append) {

    var Module = {};

    Module._activeDataFrames = [];

    /**
     * remove view from the list of active views
     * @param {string} dataframeId - unique dataframe id to be removed
     */
    Module.removeActiveDataFrame = function (dataframeId) {
        for (var i = 0; i < Module._activeDataFrames.length;) {
            if (Module._activeDataFrames[i].id == dataframeId) Module._activeDataFrames.splice(i, 1);else i++;
        }
    };

    Module.create = function (dataFrame) {

        var objectType = dataFrame.getObjectType();
        var typeId = 'df_' + objectType.getTypeId();
        var primKey = objectType.getPrimKey();

        var tableData = TableData.create(typeId, primKey);

        // Init sorting
        tableData.sortIdx = [];
        for (var i = 0; i < dataFrame.getRowCount(); i++) {
            tableData.sortIdx.push(i);
        }var tableInfo = TableInfo.tableInfo(typeId);

        tableData.resetBuffer = function () {
            var sortColId = tableData.getSortColumn();
            var sortInv = tableData.getSortInverse();
            if (sortColId) {
                var sortVals = [];
                // previous Indexes used for stable sorting
                var previousIndexes = [];
                for (var i = 0; i < dataFrame.getRowCount(); i++) {
                    sortVals.push(dataFrame.getRowInfo(i)[sortColId]);
                    previousIndexes[tableData.sortIdx[i]] = i;
                }
                tableData.sortIdx.sort(function (idx1, idx2) {
                    var val1 = sortVals[idx1];
                    var val2 = sortVals[idx2];
                    var discr = val1 < val2 ? -1 : val1 > val2 ? 1 : 0;
                    if (discr === 0) discr = previousIndexes[idx1] - previousIndexes[idx2];
                    if (sortInv) discr = -discr;
                    return discr;
                });
            }
        };

        tableData.requireRowRange = function () {
            return true;
        };

        tableData.getRow = function (rowNr) {
            return dataFrame.getRowInfo(tableData.sortIdx[rowNr]);
        };

        tableData.getRowId = function (rowNr) {
            var row = tableData.getRow(rowNr);
            if (!row) return null;
            return row[primKey];
        };

        tableData.getRowCount = function () {
            return dataFrame.getRowCount();
        };

        $.each(dataFrame.getProperties(), function (idx, propInfo) {
            var colInfo = tableInfo.addColumn(propInfo.getId());
            colInfo.setName(propInfo.getDispName());
            colInfo.content2DisplayString = propInfo.content2DisplayString;
            colInfo.enableSort();
        });

        tableData.resetBuffer();

        var Compound = Controls.Compound;
        var win = PopupWindow.create({
            title: '{name} (Table)'.AXMInterpolate({ name: dataFrame.getName() }),
            blocking: false,
            autoCenter: true,
            sizeX: 700,
            sizeY: 500,
            canDock: true
        });

        win.init = function () {
            var rootFrame = Frame.FrameSplitterHor();
            //rootFrame.setHalfSplitterSize(0);

            var formHeader = PanelForm.create('intro');
            rootFrame.addMember(Frame.FrameFinal(formHeader)).setFixedDimSize(Frame.dimX, 200);

            var headerGroup = Controls.Compound.GroupVert({}).setSeparator(17);
            formHeader.setRootControl(headerGroup);
            win.createControls(headerGroup);

            win.tableData = tableData;
            win.tableInfo = tableInfo;

            win.tableInfo.setOnOpenRow(function (rowNr) {
                var primKey = dataFrame.getPrimKeyProperty().data[win.tableData.sortIdx[rowNr]];
                ViewRow.create(dataFrame, primKey, win);
            });

            //win.tableInfo.makeCanSelect();

            //obj.tableInfo.setOnOpenRow(obj.onOpenedSample);
            win.tableFrame = PanelTable.createTableViewerFrame('tb_seqruns', win.tableData, win.tableInfo);
            win.tablePanel = win.tableFrame.getTablePanel();
            win.tablePanel.setStoreLayout(false);

            rootFrame.addMember(win.tableFrame);

            // register dataframe
            Module._activeDataFrames.push(dataFrame);
            rootFrame.addTearDownHandler(function () {
                Module.removeActiveDataFrame(dataFrame.id);
            });

            win.setRootFrame(rootFrame);
            win.start();
        };

        win.createControls = function (group) {

            var btViewPlot = Controls.Button({
                width: 160,
                height: 60,
                text: _TRL('Create view'),
                icon: 'fa-eye'
            }).addNotificationHandler(function () {
                dataFrame.promptPlot();
            });

            var btCalcCol = Controls.Button({
                width: 160,
                height: 60,
                text: _TRL('Calculate new property'),
                icon: 'fa-calculator'
            }).addNotificationHandler(function () {
                CalcProperty.create(dataFrame, '', function () {
                    win.close();
                    Module.create(dataFrame);
                });
            });

            var btExec = Controls.Button({
                width: 160,
                height: 60,
                text: _TRL('Execute script for each row'),
                icon: 'fa-terminal'
            }).addNotificationHandler(function () {
                ExecuteCode.create(dataFrame, '', function () {
                    win.close();
                    Module.create(dataFrame);
                });
            });

            var btCopyCol = Controls.Button({
                width: 160,
                height: 60,
                text: _TRL('Import property from other dataframe'),
                icon: 'fa-copy'
            }).addNotificationHandler(function () {
                CopyProperty.create(dataFrame, function () {
                    win.close();
                    Module.create(dataFrame);
                });
            });

            var btAppend = Controls.Button({
                width: 160,
                height: 60,
                text: _TRL('Append other dataframe'),
                icon: 'fa-plus-square'
            }).addNotificationHandler(function () {
                Append.create(dataFrame, function () {
                    win.close();
                    Module.create(dataFrame);
                });
            });

            var btSaveLocal = Controls.Button({
                width: 160,
                height: 60,
                text: _TRL('Save to local computer'),
                icon: 'fa-cloud-download'
            }).addNotificationHandler(function () {
                dataFrame.saveLocalFile();
            });

            group.add(Controls.Compound.StandardMargin(Controls.Compound.GroupVert({}, [btViewPlot, btCalcCol, btExec, btCopyCol, btAppend, btSaveLocal])));

            win.createSelectionTools(group);
        };

        win.createSelectionTools = function (rootGrp) {
            //var Controls = AXM.Controls;
            //var Compound = Controls.Compound;
            //
            //win._selectionActionButtons = [];
            //
            //var selectionGroup = Compound.GroupVert({separator: 6});
            //rootGrp.add(Compound.Section(Compound.StandardMargin(selectionGroup), 'Selected files'));
            //win._controls.selectedItemsText = Controls.Static({text:''});
            //selectionGroup.add(win._controls.selectedItemsText);
            //
            //var button_clear = Controls.Button({
            //    icon: 'fa-times',
            //    text: "Clear selection",
            //    width: 130,
            //    height: 50,
            //    iconSizeFraction: 1.4
            //}).addNotificationHandler(function() { win.tableData.clearSelection() });
            //win._selectionActionButtons.push(button_clear);
            //
            //var button_delete = Controls.Button({
            //    icon: 'fa-trash',
            //    text: "Delete selected files",
            //    width: 130,
            //    height: 50,
            //    iconSizeFraction: 1.4
            //}).addNotificationHandler(win.deleteSelection);
            //win._selectionActionButtons.push(button_delete);
            //
            //selectionGroup.add(Compound.GroupHor({}, [button_clear, button_delete]) );

        };

        win._updateSelectedStatus = function () {
            //var count = win.tableData.getSelectedItemCount();
            //var txt = 'None selected';
            //if (count==1)
            //    txt = 'One file selected';
            //if (count>1)
            //    txt = count + ' files selected';
            //win._controls.selectedItemsText.modifyText(txt);
            //$.each(win._selectionActionButtons, function(idx, button) {
            //    button.setEnabled(count>0);
            //});
        };

        win.init();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.CodeMirror = factory();
})(undefined, function () {
  'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }
  if (presto_version && presto_version >= 15) {
    presto = false;webkit = true;
  }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;

  function classTest(cls) {
    return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
  }

  var rmClass = function rmClass(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) {
      e.className = className;
    }
    if (style) {
      e.style.cssText = style;
    }
    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i = 0; i < content.length; ++i) {
        e.appendChild(content[i]);
      }
    }
    return e;
  }

  var range;
  if (document.createRange) {
    range = function range(node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function range(node, start, end) {
      var r = document.body.createTextRange();
      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      {
        child = child.parentNode;
      }
    if (parent.contains) {
      return parent.contains(child);
    }
    do {
      if (child.nodeType == 11) {
        child = child.host;
      }
      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch (e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.root && activeElement.root.activeElement) {
      activeElement = activeElement.root.activeElement;
    }
    return activeElement;
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++) {
      if (as[i] && !classTest(as[i]).test(b)) {
        b += " " + as[i];
      }
    }
    return b;
  }

  var selectInput = function selectInput(node) {
    node.select();
  };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    {
      selectInput = function selectInput(node) {
        node.selectionStart = 0;node.selectionEnd = node.value.length;
      };
    } else if (ie) // Suppress mysterious IE10 errors
    {
      selectInput = function selectInput(node) {
        try {
          node.select();
        } catch (_e) {}
      };
    }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }

  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
        target[prop] = obj[prop];
      }
    }
    return target;
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) {
        end = string.length;
      }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i);
      }
      n += nextTab - i;
      n += tabSize - n % tabSize;
      i = nextTab + 1;
    }
  }

  function Delayed() {
    this.id = null;
  }
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i) {
      if (array[i] == elt) {
        return i;
      }
    }
    return -1;
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = { toString: function toString() {
      return "CodeMirror.Pass";
    }

    // Reused option objects for setSelection & friends
  };var sel_dontScroll = { scroll: false };
  var sel_mouse = { origin: "*mouse" };
  var sel_move = { origin: "+move"

    // The inverse of countColumn -- find the offset that corresponds to
    // a particular column.
  };function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) {
        nextTab = string.length;
      }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }
      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;
      if (col >= goal) {
        return pos;
      }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }
    return spaceStrs[n];
  }

  function lst(arr) {
    return arr[arr.length - 1];
  }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = f(array[i], i);
    }
    return out;
  }

  function insertSorted(array, value, score) {
    var pos = 0,
        priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) {
      copyObj(props, inst);
    }
    return inst;
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
    );
  }
  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;d.scroller.style.paddingRight = 0;
    }
    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }

    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) {
      throw new Error("There is no line " + (n + doc.first) + " in the document.");
    }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i],
            sz = child.chunkSize();
        if (n < sz) {
          chunk = child;break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [],
        n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) {
        text = text.slice(0, end.ch);
      }
      if (n == start.line) {
        text = text.slice(start.ch);
      }
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    }); // iter aborts when callback returns truthy value
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }
    var cur = line.parent,
        no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) {
          break;
        }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function _lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1],
            ch = child.height;
        if (h < ch) {
          chunk = child;continue outer;
        }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i],
          lh = line.height;
      if (h < lh) {
        break;
      }
      h -= lh;
    }
    return n + i;
  }

  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch) {
    if (!(this instanceof Pos)) {
      return new Pos(line, ch);
    }
    this.line = line;this.ch = ch;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }

  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }
  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function _clipPos(doc, pos) {
    if (pos.line < doc.first) {
      return Pos(doc.first, 0);
    }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) {
      return Pos(last, getLine(doc, last).text.length);
    }
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = _clipPos(doc, array[i]);
    }
    return out;
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false;
  var sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker) {
          return span;
        }
      }
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i] != span) {
        (r || (r = [])).push(spans[i]);
      }
    }
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
        }
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) {
      return null;
    }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) {
      return null;
    }

    var startCh = change.from.ch,
        endCh = change.to.ch,
        isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1,
        offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) {
          span$1.to += offset;
        }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        } else {
          span$1.from += offset;
          if (sameLine) {
            (first || (first = [])).push(span$1);
          }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) {
      first = clearEmptySpans(first);
    }
    if (last && last != first) {
      last = clearEmptySpans(last);
    }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2,
          gapMarkers;
      if (gap > 0 && first) {
        for (var i$2 = 0; i$2 < first.length; ++i$2) {
          if (first[i$2].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
          }
        }
      }
      for (var i$3 = 0; i$3 < gap; ++i$3) {
        newMarkers.push(gapMarkers);
      }
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i--, 1);
      }
    }
    if (!spans.length) {
      return null;
    }
    return spans;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });
    if (!markers) {
      return null;
    }
    var parts = [{ from: from, to: to }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i],
          m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }
        var newParts = [j, 1],
            dfrom = cmp(p.from, m.from),
            dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({ from: p.from, to: m.from });
        }
        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({ from: m.to, to: p.to });
        }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.detachLine(line);
    }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.attachLine(line);
    }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }
  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) {
      return lenDiff;
    }
    var aPos = a.find(),
        bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) {
      return -fromCmp;
    }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) {
      return toCmp;
    }
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans,
        found;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;(lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN),
        vis = visualLine(line);
    if (line == vis) {
      return lineN;
    }
    return lineNo(vis);
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) {
      return lineN;
    }
    var line = getLine(doc, lineN),
        merged;
    if (!lineIsHidden(doc, line)) {
      return lineN;
    }
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        if (sp.from == null) {
          return true;
        }
        if (sp.marker.widgetNode) {
          continue;
        }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }
    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
        return true;
      }
    }
  }

  // Find the height above the given line.
  function _heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0,
        chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }
    return h;
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }
    var len = line.text.length,
        merged,
        cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display,
        doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr");
    }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) {
      f(from, to, "ltr");
    }
  }

  function bidiLeft(part) {
    return part.level % 2 ? part.to : part.from;
  }
  function bidiRight(part) {
    return part.level % 2 ? part.from : part.to;
  }

  function lineLeft(line) {
    var order = getOrder(line);return order ? bidiLeft(order[0]) : 0;
  }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) {
      return line.text.length;
    }
    return bidiRight(lst(order));
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) {
      return true;
    }
    if (b == linedir) {
      return false;
    }
    return a < b;
  }

  var bidiOther = null;
  function getBidiPartAt(order, pos) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) {
        return i;
      }
      if (cur.from == pos || cur.to == pos) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) {
            bidiOther = found;
          }
          return i;
        } else {
          if (cur.from != cur.to) {
            bidiOther = i;
          }
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) {
      return pos + dir;
    }
    do {
      pos += dir;
    } while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) {
      return moveLogically(line, start, dir, byUnit);
    }
    var pos = getBidiPartAt(bidi, start),
        part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) {
        return target;
      }
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) {
          return target;
        }
        part = bidi[pos += dir];
        return dir > 0 == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) {
          return null;
        }
        if (dir > 0 == part.level % 2) {
          target = moveInLine(line, part.to, -1, byUnit);
        } else {
          target = moveInLine(line, part.from, 1, byUnit);
        }
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) {
      while (target > 0 && isExtendingChar(line.text.charAt(target))) {
        target += dir;
      }
    }
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = function () {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) {
        return lowTypes.charAt(code);
      } else if (0x590 <= code && code <= 0x5f4) {
        return "R";
      } else if (0x600 <= code && code <= 0x6f9) {
        return arabicTypes.charAt(code - 0x600);
      } else if (0x6ee <= code && code <= 0x8ac) {
        return "r";
      } else if (0x2000 <= code && code <= 0x200b) {
        return "w";
      } else if (code == 0x200c) {
        return "b";
      } else {
        return "L";
      }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/,
        isStrong = /[LRr]/,
        countsAsLeft = /[Lb1n]/,
        countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;this.to = to;
    }

    return function (str) {
      if (!bidiRE.test(str)) {
        return false;
      }
      var len = str.length,
          types = [];
      for (var i = 0; i < len; ++i) {
        types.push(charType(str.charCodeAt(i)));
      }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") {
          types[i$1] = prev;
        } else {
          prev = type;
        }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") {
          types[i$2] = "n";
        } else if (isStrong.test(type$1)) {
          cur = type$1;if (type$1 == "r") {
            types[i$2] = "R";
          }
        }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
          types[i$3] = "1";
        } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
          types[i$3] = prev$1;
        }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") {
          types[i$4] = "N";
        } else if (type$3 == "%") {
          var end = void 0;
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
          for (var j = i$4; j < end; ++j) {
            types[j] = replace;
          }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") {
          types[i$5] = "L";
        } else if (isStrong.test(type$4)) {
          cur$1 = type$4;
        }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = void 0;
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before || after ? "L" : "R";
          for (var j$1 = i$6; j$1 < end$1; ++j$1) {
            types[j$1] = replace$1;
          }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [],
          m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7,
              at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j$2));
              }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else {
              ++j$2;
            }
          }
          if (pos < i$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i$7));
          }
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level == 2) {
        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
      }
      if (order[0].level != lst(order).level) {
        order.push(new BidiSpan(order[0].level, len, len));
      }

      return order;
    };
  }();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) {
      order = line.order = bidiOrdering(line.text);
    }
    return order;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function on(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers;
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers,
          arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1) {
          map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) {
      handlers[i].apply(null, args);
    }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = { type: e, preventDefault: function preventDefault() {
          this.defaultPrevented = true;
        } };
    }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) {
      return;
    }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) {
      if (indexOf(set, arr[i]) == -1) {
        set.push(arr[i]);
      }
    }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };
    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {
    e_preventDefault(e);e_stopPropagation(e);
  }

  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }
    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }
    return b;
  }

  // Detect drag-and-drop
  var dragAndDrop = function () {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) {
      return false;
    }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", '\u200B');
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }
    var node = zwspSupported ? elt("span", '\u200B') : elt("span", '\xA0', null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }
    var txt = removeChildrenAndAdd(measure, document.createTextNode('A\u062EA'));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) {
      return false;
    } // Safari returns null in some cases (#2780)
    return badBidiRects = r1.right - r0.right < 3;
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0,
        result = [],
        l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) {
        nl = string.length;
      }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function (string) {
    return string.split(/\r\n?|\n/);
  };

  var hasSelection = window.getSelection ? function (te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function (te) {
    var range$$1;
    try {
      range$$1 = te.ownerDocument.selection.createRange();
    } catch (e) {}
    if (!range$$1 || range$$1.parentElement() != te) {
      return false;
    }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0;
  };

  var hasCopyEvent = function () {
    var e = elt("div");
    if ("oncopy" in e) {
      return true;
    }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // Known modes, by name and by MIME
  var modes = {};
  var mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") {
        found = { name: found };
      }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json");
    }
    if (typeof spec == "string") {
      return { name: spec };
    } else {
      return spec || { name: "null" };
    }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) {
      return getMode(options, "text/plain");
    }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) {
          continue;
        }
        if (modeObj.hasOwnProperty(prop)) {
          modeObj["_" + prop] = modeObj[prop];
        }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }
    if (spec.modeProps) {
      for (var prop$1 in spec.modeProps) {
        modeObj[prop$1] = spec.modeProps[prop$1];
      }
    }

    return modeObj;
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) {
      return state;
    }
    if (mode.copyState) {
      return mode.copyState(state);
    }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) {
        val = val.concat([]);
      }
      nstate[n] = val;
    }
    return nstate;
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) {
        break;
      }
      state = info.state;
      mode = info.mode;
    }
    return info || { mode: mode, state: state };
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function eol() {
      return this.pos >= this.string.length;
    },
    sol: function sol() {
      return this.pos == this.lineStart;
    },
    peek: function peek() {
      return this.string.charAt(this.pos) || undefined;
    },
    next: function next() {
      if (this.pos < this.string.length) {
        return this.string.charAt(this.pos++);
      }
    },
    eat: function eat(match) {
      var ch = this.string.charAt(this.pos);
      var ok;
      if (typeof match == "string") {
        ok = ch == match;
      } else {
        ok = ch && (match.test ? match.test(ch) : match(ch));
      }
      if (ok) {
        ++this.pos;return ch;
      }
    },
    eatWhile: function eatWhile(match) {
      var start = this.pos;
      while (this.eat(match)) {}
      return this.pos > start;
    },
    eatSpace: function eatSpace() {
      var this$1 = this;

      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
        ++this$1.pos;
      }
      return this.pos > start;
    },
    skipToEnd: function skipToEnd() {
      this.pos = this.string.length;
    },
    skipTo: function skipTo(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;return true;
      }
    },
    backUp: function backUp(n) {
      this.pos -= n;
    },
    column: function column() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function indentation() {
      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function match(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function cased(str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) {
            this.pos += pattern.length;
          }
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) {
          return null;
        }
        if (match && consume !== false) {
          this.pos += match[0].length;
        }
        return match;
      }
    },
    current: function current() {
      return this.string.slice(this.start, this.pos);
    },
    hideFirstChars: function hideFirstChars(n, inner) {
      this.lineStart += n;
      try {
        return inner();
      } finally {
        this.lineStart -= n;
      }
    }

    // Compute a style array (an array starting with a mode generation
    // -- for invalidation -- followed by pairs of end positions and
    // style strings), which is used to highlight the tokens on the
    // line.
  };function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen],
        lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
      return st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    var loop = function loop(o) {
      var overlay = cm.state.overlays[o],
          i = 1,
          at = 0;
      runMode(cm, line.text, overlay.mode, true, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end) {
            st.splice(i, 1, end, st[i + 1], i_end);
          }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) {
          return;
        }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) {
      loop(o);
    }return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var state = getStateBefore(cm, lineNo(line));
      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
      line.stateAfter = state;
      line.styles = result.styles;
      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }
      if (updateFrontier === cm.doc.frontier) {
        cm.doc.frontier++;
      }
    }
    return line.styles;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc,
        display = cm.display;
    if (!doc.mode.startState) {
      return true;
    }
    var pos = findStartLine(cm, n, precise),
        state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
    if (!state) {
      state = startState(doc.mode);
    } else {
      state = copyState(doc.mode, state);
    }
    doc.iter(pos, n, function (line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) {
      doc.frontier = pos;
    }
    return state;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") {
      callBlankLine(mode, state);
    }
    while (!stream.eol()) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }
    if (!mode.innerMode) {
      return;
    }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) {
        return style;
      }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var getObj = function getObj(copy) {
      return {
        start: stream.start, end: stream.pos,
        string: stream.current(),
        type: style || null,
        state: copy ? copyState(doc.mode, state) : state
      };
    };

    var doc = cm.doc,
        mode = doc.mode,
        style;
    pos = _clipPos(doc, pos);
    var line = getLine(doc, pos.line),
        state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize),
        tokens;
    if (asArray) {
      tokens = [];
    }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) {
        tokens.push(getObj(true));
      }
    }
    return asArray ? tokens : getObj();
  }

  function extractLineClasses(type, output) {
    if (type) {
      for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass) {
          break;
        }
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";
        if (output[prop] == null) {
          output[prop] = lineClass[2];
        } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
          output[prop] += " " + lineClass[2];
        }
      }
    }
    return type;
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }
    var curStart = 0,
        curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize),
        style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") {
      extractLineClasses(callBlankLine(mode, state), lineClasses);
    }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) {
          processLine(cm, text, state, stream.pos);
        }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent,
        minline,
        doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) {
        return doc.first;
      }
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) {
        return search;
      }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  function Line(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  }
  eventMixin(Line);
  Line.prototype.lineNo = function () {
    return lineNo(this);
  };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    if (line.styles) {
      line.styles = null;
    }
    if (line.order != null) {
      line.order = null;
    }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {};
  var styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) {
      return null;
    }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = { pre: elt("pre", [content], "CodeMirror-line"), content: content,
      col: 0, pos: 0, cm: cm,
      trailingSpace: false,
      splitSpaces: (ie || webkit) && cm.getOption("lineWrapping") };
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line,
          order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }
        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", '\u2022', "cm-invalidchar");
    token.title = '\\u' + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) {
      return;
    }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars,
        mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) {
        mustWrap = true;
      }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) {
          break;
        }
        pos += skipped + 1;
        var txt$1 = void 0;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize,
              tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? '\u240D' : '\u2424', "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt$1]));
          } else {
            content.appendChild(txt$1);
          }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) {
        fullStyle += startStyle;
      }
      if (endStyle) {
        fullStyle += endStyle;
      }
      var token = elt("span", [content], fullStyle, css);
      if (title) {
        token.title = title;
      }
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }
    var spaceBefore = trailingBefore,
        result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
        ch = '\xA0';
      }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos,
          end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = void 0;
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) {
            break;
          }
        }
        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, title, css);
        }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans,
        allText = line.text,
        at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
      }
      return;
    }

    var len = allText.length,
        pos = 0,
        i = 1,
        text = "",
        style,
        css;
    var nextChange = 0,
        spanStyle,
        spanEndStyle,
        spanStartStyle,
        title,
        collapsed;
    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null;nextChange = Infinity;
        var foundBookmarks = [],
            endStyles = void 0;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j],
              m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) {
              spanStyle += " " + m.className;
            }
            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }
            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }
            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            }
            if (m.title && !title) {
              title = m.title;
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) {
          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
            if (endStyles[j$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j$1];
            }
          }
        }

        if (!collapsed || collapsed.from == pos) {
          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) {
            return;
          }
          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }
      if (pos >= len) {
        break;
      }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {
            text = text.slice(upto - pos);pos = upto;break;
          }
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [],
        nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks,
        i = 0;
    do {
      for (; i < callbacks.length; i++) {
        callbacks[i].call(null);
      }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i < callbacks.length);
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) {
      return;
    }

    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2),
        list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function loop(i) {
      list.push(function () {
        return arr[i].apply(null, args);
      });
    };

    for (var i = 0; i < arr.length; ++i) {
      loop(i);
    }
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) {
      delayed[i]();
    }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") {
        updateLineText(cm, lineView);
      } else if (type == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type == "class") {
        updateLineClasses(lineView);
      } else if (type == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) {
      cls += " CodeMirror-linebackground";
    }
    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
      }
      if (markers) {
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k],
              found = markers.hasOwnProperty(id) && markers[id];
          if (found) {
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }
    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget") {
        lineView.node.removeChild(node);
      }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }
    if (built.textClass) {
      lineView.textClass = built.textClass;
    }

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) {
        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
    }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i],
          node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }
    var cm = widget.doc.cm;
    if (!cm) {
      return 0;
    }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }
      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }
    return data;
  }

  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i],
              next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return { map: lineView.measure.map, cache: lineView.measure.cache };
    }
    for (var i = 0; i < lineView.rest.length; i++) {
      if (lineView.rest[i] == line) {
        return { map: lineView.measure.maps[i], cache: lineView.measure.caches[i] };
      }
    }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
      if (lineNo(lineView.rest[i$1]) > lineN) {
        return { map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true };
      }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }
    var key = ch + (bias || ""),
        found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }
    return { left: found.left, right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom };
  }

  var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0;end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) {
          collapse = "right";
        }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }
        if (bias == "left" && start == 0) {
          while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          }
        }
        if (bias == "right" && start == mEnd - mStart) {
          while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          }
        }
        break;
      }
    }
    return { node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd };
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") {
      for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) {
          break;
        }
      }
    }
    return rect;
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node,
        start = place.start,
        end = place.end,
        collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) {
      // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) {
        // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }
        if (rect.left || rect.right || start == 0) {
          break;
        }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      // If it is a widget, simply get the box for the whole widget.
      if (start > 0) {
        collapse = bias = "right";
      }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan) {
        rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
      } else {
        rect = nullRect;
      }
    }

    var rtop = rect.top - prepared.rect.top,
        rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++) {
      if (mid < heights[i]) {
        break;
      }
    }
    var top = i ? heights[i - 1] : 0,
        bot = heights[i];
    var result = { left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top: top, bottom: bot };
    if (!rect.left && !rect.right) {
      result.bogus = true;
    }
    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;result.rbottom = rbot;
    }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return { left: rect.left * scaleX, right: rect.right * scaleX,
      top: rect.top * scaleY, bottom: rect.bottom * scaleY };
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) {
        for (var i = 0; i < lineView.rest.length; i++) {
          lineView.measure.caches[i] = {};
        }
      }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++) {
      clearLineMeasurementCacheFor(cm.display.view[i]);
    }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }
  function pageScrollY() {
    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets && lineObj.widgets) {
      for (var i = 0; i < lineObj.widgets.length; ++i) {
        if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;rect.bottom += size;
        }
      }
    }
    if (context == "line") {
      return rect;
    }
    if (!context) {
      context = "local";
    }
    var yOff = _heightAtLine(lineObj);
    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff;rect.right += xOff;
    }
    rect.top += yOff;rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }
    var left = coords.left,
        top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
  }

  function _charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos],
          right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) {
        return get(ch - 1);
      }
      return get(ch, right);
    }
    var order = getOrder(lineObj),
        ch = pos.ch;
    if (!order) {
      return get(ch);
    }
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) {
      val.other = getBidi(ch, bidiOther);
    }
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = _clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }
    var lineObj = getLine(cm.doc, pos.line);
    var top = _heightAtLine(lineObj) + paddingTop(cm.display);
    return { left: left, right: left, top: top, bottom: top + lineObj.height };
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) {
      pos.outside = true;
    }
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function _coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) {
      return PosWithInfo(doc.first, 0, true, -1);
    }
    var lineN = _lineAtHeight(doc, y),
        last = doc.first + doc.size - 1;
    if (lineN > last) {
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    }
    if (x < 0) {
      x = 0;
    }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) {
        lineN = lineNo(lineObj = mergedPos.to.line);
      } else {
        return found;
      }
    }
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    var innerOff = y - _heightAtLine(lineObj);
    var wrongLine = false,
        adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = _cursorCoords(cm, Pos(lineNo$$1, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) {
        return sp.left - adjust;
      } else if (innerOff < sp.top) {
        return sp.left + adjust;
      } else {
        wrongLine = false;
      }
      return sp.left;
    }

    var bidi = getOrder(lineObj),
        dist = lineObj.text.length;
    var from = lineLeft(lineObj),
        to = lineRight(lineObj);
    var fromX = getX(from),
        fromOutside = wrongLine,
        toX = getX(to),
        toOutside = wrongLine;

    if (x > toX) {
      return PosWithInfo(lineNo$$1, to, toOutside, 1);
    }
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var outside = ch == from ? fromOutside : toOutside;
        var xDiff = x - (ch == from ? fromX : toX);
        // This is a kludge to handle the case where the coordinates
        // are after a line-wrapped line. We should replace it with a
        // more general handling of cursor positions around line
        // breaks. (Issue #4078)
        if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 && ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
          var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right");
          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
            outside = false;
            ch++;
            xDiff = x - charSize.right;
          }
        }
        while (isExtendingChar(lineObj.text.charAt(ch))) {
          ++ch;
        }
        var pos = PosWithInfo(lineNo$$1, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2),
          middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) {
          middle = moveVisually(lineObj, middle, 1);
        }
      }
      var middleX = getX(middle);
      if (middleX > x) {
        to = middle;toX = middleX;if (toOutside = wrongLine) {
          toX += 1000;
        }dist = step;
      } else {
        from = middle;fromX = middleX;fromOutside = wrongLine;dist -= step;
      }
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) {
      display.cachedTextHeight = height;
    }
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(),
        width = (rect.right - rect.left) / 10;
    if (width > 2) {
      display.cachedCharWidth = width;
    }
    return width || 10;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display,
        left = {},
        width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return { fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth };
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display),
        wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }

      var widgetsHeight = 0;
      if (line.widgets) {
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) {
            widgetsHeight += line.widgets[i].height;
          }
        }
      }

      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc,
        est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }

    var x,
        y,
        space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try {
      x = e.clientX - space.left;y = e.clientY - space.top;
    } catch (e) {
      return null;
    }
    var coords = _coordsChar(cm, x, y),
        line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }
    n -= cm.display.viewFrom;
    if (n < 0) {
      return null;
    }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) {
        return i;
      }
    }
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function _prepareSelection(cm, primary) {
    var doc = cm.doc,
        result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) {
        continue;
      }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) {
        continue;
      }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range$$1.head, curFragment);
      }
      if (!collapsed) {
        drawSelectionRange(cm, range$$1, selFragment);
      }
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = _cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", '\xA0', "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", '\xA0', "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display,
        doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display),
        leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return _charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
        var leftPos = coords(from, "left"),
            rightPos,
            left,
            right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") {
            var tmp = leftPos;leftPos = rightPos;rightPos = tmp;
          }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) {
          left = leftSide;
        }
        if (rightPos.top - leftPos.top > 3) {
          // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) {
            add(left, leftPos.bottom, null, rightPos.top);
          }
        }
        if (toArg == null && to == lineLen) {
          right = rightSide;
        }
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) {
          start = leftPos;
        }
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) {
          end = rightPos;
        }
        if (left < leftSide + 1) {
          left = leftSide;
        }
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return { start: start, end: end };
    }

    var sFrom = range$$1.from(),
        sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line),
          toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function () {
        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) {
      cm.display.input.focus();onFocus(cm);
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
    }

    if (cm.options.readOnly == "nocursor") {
      return;
    }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) {
          setTimeout(function () {
            return cm.display.input.reset(true);
          }, 20);
        } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display,
        view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth,
        left = comp + "px";
    for (var i = 0; i < view.length; i++) {
      if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter) {
            view[i].gutter.style.left = left;
          }
          if (view[i].gutterBackground) {
            view[i].gutterBackground.style.left = left;
          }
        }
        var align = view[i].alignable;
        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }
    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }
    var doc = cm.doc,
        last = lineNumberFor(cm.options, doc.first + doc.size - 1),
        display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth,
          padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i],
          height = void 0;
      if (cur.hidden) {
        continue;
      }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) {
        height = textHeight(display);
      }
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i = 0; i < line.widgets.length; ++i) {
        line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
      }
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = _lineAtHeight(doc, top),
        to = _lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line,
          ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return { from: from, to: Math.max(to, from + 1) };
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }
    cm.doc.scrollTop = val;
    if (!gecko) {
      updateDisplaySimple(cm, { top: val });
    }
    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) {
      updateDisplaySimple(cm);
    }
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) {
      return;
    }
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0;
  var wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) {
    wheelPixelsPerUnit = -.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX,
        dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }
    return { x: dx, y: dy };
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e),
        dx = delta.x,
        dy = delta.y;

    var display = cm.display,
        scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY) {
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      }
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop,
          bot = top + display.wrapper.clientHeight;
      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }
      updateDisplaySimple(cm, { top: top, bottom: bot });
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) {
            return;
          }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) {
            return;
          }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;display.wheelDY += dy;
      }
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display,
        gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert);place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  }

  NativeScrollbars.prototype = copyObj({
    update: function update(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width = measure.scrollWidth - measure.clientWidth + totalWidth + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) {
          this.zeroWidthHack();
        }
        this.checkedZeroWidth = true;
      }

      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
    },
    setScrollLeft: function setScrollLeft(pos) {
      if (this.horiz.scrollLeft != pos) {
        this.horiz.scrollLeft = pos;
      }
      if (this.disableHoriz) {
        this.enableZeroWidthBar(this.horiz, this.disableHoriz);
      }
    },
    setScrollTop: function setScrollTop(pos) {
      if (this.vert.scrollTop != pos) {
        this.vert.scrollTop = pos;
      }
      if (this.disableVert) {
        this.enableZeroWidthBar(this.vert, this.disableVert);
      }
    },
    zeroWidthHack: function zeroWidthHack() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed();
      this.disableVert = new Delayed();
    },
    enableZeroWidthBar: function enableZeroWidthBar(bar, delay) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        // To find out whether the scrollbar is still visible, we
        // check whether the element under the pixel in the bottom
        // left corner of the scrollbar box is the scrollbar box
        // itself (when the bar is still visible) or its filler child
        // (when the bar is hidden). If it is still visible, we keep
        // it enabled, if it's hidden, we disable pointer events.
        var box = bar.getBoundingClientRect();
        var elt$$1 = document.elementFromPoint(box.left + 1, box.bottom - 1);
        if (elt$$1 != bar) {
          bar.style.pointerEvents = "none";
        } else {
          delay.set(1000, maybeDisable);
        }
      }
      delay.set(1000, maybeDisable);
    },
    clear: function clear() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function update() {
      return { bottom: 0, right: 0 };
    },
    setScrollLeft: function setScrollLeft() {},
    setScrollTop: function setScrollTop() {},
    clear: function clear() {}
  }, NullScrollbars.prototype);

  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }
    var startWidth = cm.display.barWidth,
        startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }

  var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) {
          setTimeout(function () {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        setScrollTop(cm, pos);
      }
    }, cm);
    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }

    var display = cm.display,
        box = display.sizer.getBoundingClientRect(),
        doScroll = null;
    if (coords.top + box.top < 0) {
      doScroll = true;
    } else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
      doScroll = false;
    }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", '\u200B', null, "position: absolute;\n                         top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }
    var coords;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      coords = _cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop,
          startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) {
      setScrollTop(cm, scrollPos.scrollTop);
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display,
        snapMargin = textHeight(cm.display);
    if (y1 < 0) {
      y1 = 0;
    }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm),
        result = {};
    if (y2 - y1 > screen) {
      y2 = y1 + screen;
    }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin,
        atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) {
      x2 = x1 + screenw;
    }
    if (x1 < 10) {
      result.scrollLeft = 0;
    } else if (x1 < screenleft) {
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    }
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) {
      resolveScrollToPos(cm);
    }
    if (left != null) {
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    }
    if (top != null) {
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(),
        from = cur,
        to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = { from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true };
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from),
          to = estimateCoords(cm, range$$1.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range$$1.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range$$1.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false, // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false, // Used to force a redraw
      updateInput: null, // Whether to reset the input textarea
      typing: false, // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null, // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false, // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null, // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++) {
        group.ops[i].cm.curOp = null;
      }
      endOperations(group);
    });
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
    {
      endOperation_R1(ops[i]);
    }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    {
      endOperation_W1(ops[i$1]);
    }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    {
      endOperation_R2(ops[i$2]);
    }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    {
      endOperation_W2(ops[i$3]);
    }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    {
      endOperation_finish(ops[i$4]);
    }
  }

  function endOperation_R1(op) {
    var cm = op.cm,
        display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) {
      findMaxLine(cm);
    }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm,
        display = cm.display;
    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection(op.focus);
    }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());
    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }
    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }
    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }

    if (op.selectionChanged) {
      restartBlink(cm);
    }

    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }
    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }

  function endOperation_finish(op) {
    var cm = op.cm,
        display = cm.display,
        doc = cm.doc;

    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) {
        maybeScrollWindow(cm, coords);
      }
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers,
        unhidden = op.maybeUnhiddenMarkers;
    if (hidden) {
      for (var i = 0; i < hidden.length; ++i) {
        if (!hidden[i].lines.length) {
          signal(hidden[i], "hide");
        }
      }
    }
    if (unhidden) {
      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
        if (unhidden[i$1].lines.length) {
          signal(unhidden[i$1], "unhide");
        }
      }
    }

    if (display.wrapper.offsetHeight) {
      doc.scrollTop = cm.display.scroller.scrollTop;
    }

    // Fire change events, and delayed event handlers
    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }
    if (op.update) {
      op.update.finish();
    }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }
    startOperation(cm);
    try {
      return f();
    } finally {
      endOperation(cm);
    }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function () {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(cm, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function () {
      if (this.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(this);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(this);
      }
    };
  }
  function docMethodOp(f) {
    return function () {
      var cm = this.cm;
      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }
    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }
    if (!lendiff) {
      lendiff = 0;
    }

    var display = cm.display;
    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) {
      // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) {
      // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display,
        ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }

    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) {
      return;
    }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) {
      arr.push(type);
    }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN),
        diff,
        view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return { index: index, lineN: newN };
    }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++) {
      n += view[i].size;
    }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }
        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff;newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return { index: index, lineN: newN };
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display,
        view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }
      display.viewFrom = from;
      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view,
        dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }
    return dirty;
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) {
      doc.frontier = doc.first;
    }
    if (doc.frontier >= cm.display.viewTo) {
      return;
    }
    var end = +new Date() + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (doc.frontier >= cm.display.viewFrom) {
        // Visible
        var oldStyles = line.styles,
            tooLong = line.text.length > cm.options.maxHighlightLength;
        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses,
            newCls = highlighted.classes;
        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }
        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) {
          ischange = oldStyles[i] != line.styles[i];
        }
        if (ischange) {
          changedLines.push(doc.frontier);
        }
        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, state);
        }
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) {
      runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++) {
          regLineChange(cm, changedLines[i], "text");
        }
      });
    }
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type)) {
      this.events.push(arguments);
    }
  };
  DisplayUpdate.prototype.finish = function () {
    var this$1 = this;

    for (var i = 0; i < this.events.length; i++) {
      signal.apply(null, this$1.events[i]);
    }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display,
        doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc.first, display.viewFrom);
    }
    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) {
      focused.focus();
    }

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null) {
          viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
        }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      }
      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display,
        lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv,
        cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }

    var view = display.view,
        lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {} else if (!lineView.node || lineView.node.parentNode != container) {
        // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        // Already drawn
        while (cur != lineView.node) {
          cur = rm(cur);
        }
        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) {
      cur = rm(cur);
    }
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters,
        specs = cm.options.gutters;
    removeChildren(gutters);
    var i = 0;
    for (; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function primary() {
      return this.ranges[this.primIndex];
    },
    equals: function equals(other) {
      var this$1 = this;

      if (other == this) {
        return true;
      }
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
        return false;
      }
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this$1.ranges[i],
            there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) {
          return false;
        }
      }
      return true;
    },
    deepCopy: function deepCopy() {
      var this$1 = this;

      var out = [];
      for (var i = 0; i < this.ranges.length; i++) {
        out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
      }
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function somethingSelected() {
      var this$1 = this;

      for (var i = 0; i < this.ranges.length; i++) {
        if (!this$1.ranges[i].empty()) {
          return true;
        }
      }
      return false;
    },
    contains: function contains(pos, end) {
      var this$1 = this;

      if (!end) {
        end = pos;
      }
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this$1.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
          return i;
        }
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor;this.head = head;
  }

  Range.prototype = {
    from: function from() {
      return minPos(this.anchor, this.head);
    },
    to: function to() {
      return maxPos(this.anchor, this.head);
    },
    empty: function empty() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }

    // Take an unsorted, potentially overlapping set of ranges, and
    // build a selection out of it. 'Consumes' ranges array (modifying
    // it).
  };function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i],
          prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()),
            to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) {
          --primIndex;
        }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }
    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
        ch = pos.ch;
    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0),
        newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i],
            inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) {
      regChange(cm);
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i) {
        result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
      }
      return result;
    }

    var from = change.from,
        to = change.to,
        text = change.text;
    var firstLine = getLine(doc, from.line),
        lastLine = getLine(doc, to.line);
    var lastText = lst(text),
        lastSpans = spansFor(text.length - 1),
        nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) {
        doc.remove(from.line, nlines);
      }
      if (added.length) {
        doc.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) {
        doc.remove(from.line + 1, nlines - 1);
      }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) {
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip) {
            continue;
          }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) {
            continue;
          }
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) {
      throw new Error("This document is already in use.");
    }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = [];this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(),
        cur;
    var last;

    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges) {
        pushSelectionToHistory(doc.sel, hist.done);
      }
      cur = { changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) {
      signal(doc, "historyAdded");
    }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history,
        origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }

    hist.lastSelTime = +new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id],
        n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i);
        }
      } else if (out) {
        out.push(spans[i]);
      }
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) {
      return null;
    }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i) {
      nw.push(removeClearedSpans(found[i]));
    }
    return nw;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) {
      return stretched;
    }
    if (!stretched) {
      return old;
    }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i],
          stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes,
          newChanges = [];
      copy.push({ changes: newChanges });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j],
            m = void 0;
        newChanges.push({ from: change.from, to: change.to, text: change.text });
        if (newGroup) {
          for (var prop in change) {
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
      }
    }
    return copy;
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    }
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function update(ranges) {
        var this$1 = this;

        this.ranges = [];
        for (var i = 0; i < ranges.length; i++) {
          this$1.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));
        }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    }
    if (obj.ranges != sel.ranges) {
      return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done,
        last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc, sel, options);
    }

    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm) {
      ensureCursorVisible(doc.cm);
    }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) {
      return;
    }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) {
          out = sel.ranges.slice(0, i);
        }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) {
      for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i],
            m = sp.marker;
        if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i;continue;
              }
            }
          }
          if (!m.atomic) {
            continue;
          }

          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1),
                diff = void 0;
            if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) {
              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
            }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc, near, pos, dir, mayClear);
            }
          }

          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) {
            far = movePos(doc, far, dir, far.line == pos.line ? line : null);
          }
          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
        }
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) {
        return _clipPos(doc, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function cancel() {
        return obj.canceled = true;
      }
    };
    if (update) {
      obj.update = function (from, to, text, origin) {
        if (from) {
          obj.from = _clipPos(doc, from);
        }
        if (to) {
          obj.to = _clipPos(doc, to);
        }
        if (text) {
          obj.text = text;
        }
        if (origin !== undefined) {
          obj.origin = origin;
        }
      };
    }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeChange", doc.cm, obj);
    }

    if (obj.canceled) {
      return null;
    }
    return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) {
        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      }
      if (doc.cm.state.suppressEdits) {
        return;
      }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) {
        return;
      }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i) {
        makeChangeInner(doc, { from: split[i].from, to: split[i].to, text: i ? [""] : change.text });
      }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) {
      return;
    }

    var hist = doc.history,
        event,
        selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone,
        dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
        break;
      }
    }
    if (i == source.length) {
      return;
    }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, { clearRedo: false });
          return;
        }
        selAfter = event;
      } else {
        break;
      }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({ changes: antiChanges, generation: hist.generation });
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function loop(i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {};
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) {
        doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
      }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop(i$1);

      if (returned) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) {
      return;
    }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc.cm, l, "gutter");
      }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) {
      return;
    }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = { from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)], origin: change.origin };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = { from: change.from, to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]], origin: change.origin };
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) {
      selAfter = computeSelAfterChange(doc, change);
    }
    if (doc.cm) {
      makeChangeSingleDocInEditor(doc.cm, change, spans);
    } else {
      updateDoc(doc, change, spans);
    }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc,
        display = cm.display,
        from = change.from,
        to = change.to;

    var recomputeMaxLength = false,
        checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }

    var changesHandler = hasHandler(cm, "changes"),
        changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }
      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }
    cm.display.selForContextMenu = null;
  }

  function _replaceRange(doc, code, from, to, origin) {
    if (!to) {
      to = from;
    }
    if (cmp(to, from) < 0) {
      var tmp = to;to = from;from = tmp;
    }
    if (typeof code == "string") {
      code = doc.splitLines(code);
    }
    makeChange(doc, { from: from, to: to, text: code, origin: origin });
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i],
          ok = true;
      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i] = sub.deepCopy();sub.copied = true;
        }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line,
        to = change.to.line,
        diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle,
        line = handle;
    if (typeof handle == "number") {
      line = getLine(doc, clipLine(doc, handle));
    } else {
      no = lineNo(handle);
    }
    if (no == null) {
      return null;
    }
    if (op(line, no) && doc.cm) {
      regLineChange(doc.cm, no, changeType);
    }
    return line;
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;

    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.lines.length;
    },
    // Remove the n lines at offset 'at'.
    removeInner: function removeInner(at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function collapse(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;

      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) {
        lines[i].parent = this$1;
      }
    },
    // Used to iterate over a part of the tree.
    iterN: function iterN(at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at) {
        if (op(this$1.lines[at])) {
          return true;
        }
      }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;

    this.children = children;
    var size = 0,
        height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize();height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.size;
    },
    removeInner: function removeInner(at, n) {
      var this$1 = this;

      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at),
              oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) {
            this$1.children.splice(i--, 1);child.parent = null;
          }
          if ((n -= rm) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function collapse(lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        this$1.children[i].collapse(lines);
      }
    },
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;

      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function maybeSpill() {
      if (this.children.length <= 10) {
        return;
      }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function iterN(at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) {
            return true;
          }
          if ((n -= used) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
    }

    // Line widgets are block elements displayed above or below a line.

  };function LineWidget(doc, node, options) {
    var this$1 = this;

    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this$1[opt] = options[opt];
        }
      }
    }
    this.doc = doc;
    this.node = node;
  }
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollPos(cm, null, diff);
    }
  }

  LineWidget.prototype.clear = function () {
    var this$1 = this;

    var cm = this.doc.cm,
        ws = this.line.widgets,
        line = this.line,
        no = lineNo(line);
    if (no == null || !ws) {
      return;
    }
    for (var i = 0; i < ws.length; ++i) {
      if (ws[i] == this$1) {
        ws.splice(i--, 1);
      }
    }
    if (!ws.length) {
      line.widgets = null;
    }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
    }
  };
  LineWidget.prototype.changed = function () {
    var oldH = this.height,
        cm = this.doc.cm,
        line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) {
      return;
    }
    updateLineHeight(line, line.height + diff);
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
      });
    }
  };

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = _heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) {
          addToScrollPos(cm, null, widget.height);
        }
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  }
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    var this$1 = this;

    if (this.explicitlyCleared) {
      return;
    }
    var cm = this.doc.cm,
        withOp = cm && !cm.curOp;
    if (withOp) {
      startOperation(cm);
    }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }
    var min = null,
        max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }
        if (span.from != null) {
          min = lineNo(line);
        }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this$1.lines[i$1]),
            len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }

    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) {
        reCheckSelection(cm.doc);
      }
    }
    if (cm) {
      signalLater(cm, "markerCleared", cm, this);
    }
    if (withOp) {
      endOperation(cm);
    }
    if (this.parent) {
      this.parent.clear();
    }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;

    if (side == null && this.type == "bookmark") {
      side = 1;
    }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) {
          return from;
        }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) {
          return to;
        }
      }
    }
    return from && { from: from, to: to };
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
    var pos = this.find(-1, true),
        widget = this,
        cm = this.doc.cm;
    if (!pos || !cm) {
      return;
    }
    runInOp(cm, function () {
      var line = pos.line,
          lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Create a marker, wire it up to the right lines, and
  function _markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) {
      return markTextShared(doc, from, to, options, type);
    }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, _markText)(doc, from, to, options, type);
    }

    var marker = new TextMarker(doc, type),
        diff = cmp(from, to);
    if (options) {
      copyObj(options, marker, false);
    }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }
      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }
      seeCollapsedSpans();
    }

    if (marker.addToHistory) {
      addChangeToHistory(doc, { from: from, to: to, origin: "markText" }, doc.sel, NaN);
    }

    var curLine = from.line,
        cm = doc.cm,
        updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }
      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }
      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) {
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) {
          updateLineHeight(line, 0);
        }
      });
    }

    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function () {
        return marker.clear();
      });
    }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length) {
        doc.clearHistory();
      }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }
      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) {
        for (var i = from.line; i <= to.line; i++) {
          regLineChange(cm, i, "text");
        }
      }
      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  function SharedTextMarker(markers, primary) {
    var this$1 = this;

    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i) {
      markers[i].parent = this$1;
    }
  }
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function () {
    var this$1 = this;

    if (this.explicitlyCleared) {
      return;
    }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i) {
      this$1.markers[i].clear();
    }
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [_markText(doc, from, to, options, type)],
        primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }
      markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i) {
        if (doc.linked[i].isParent) {
          return;
        }
      }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
      return m.parent;
    });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i],
          pos = marker.find();
      var mFrom = doc.clipPos(pos.from),
          mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function loop(i) {
      var marker = markers[i],
          linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) {
        return linked.push(d);
      });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) {
      loop(i);
    }
  }

  var nextDocId = 0;
  var Doc = function Doc(text, mode, firstLine, lineSep) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep);
    }
    if (firstLine == null) {
      firstLine = 0;
    }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.extend = false;

    if (typeof text == "string") {
      text = this.splitLines(text);
    }
    updateDoc(this, { from: start, to: start, text: text });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function iter(from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },

    // Non-public interface for adding and removing lines.
    insert: function insert(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) {
        height += lines[i].height;
      }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function remove(at, n) {
      this.removeInner(at - this.first, n);
    },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function getValue(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0),
          last = this.first + this.size - 1;
      makeChange(this, { from: top, to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code), origin: "setValue", full: true }, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function replaceRange(code, from, to, origin) {
      from = _clipPos(this, from);
      to = to ? _clipPos(this, to) : from;
      _replaceRange(this, code, from, to, origin);
    },
    getRange: function getRange(from, to, lineSep) {
      var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },

    getLine: function getLine(line) {
      var l = this.getLineHandle(line);return l && l.text;
    },

    getLineHandle: function getLineHandle(line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function getLineNumber(line) {
      return lineNo(line);
    },

    getLineHandleVisualStart: function getLineHandleVisualStart(line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }
      return visualLine(line);
    },

    lineCount: function lineCount() {
      return this.size;
    },
    firstLine: function firstLine() {
      return this.first;
    },
    lastLine: function lastLine() {
      return this.first + this.size - 1;
    },

    clipPos: function clipPos(pos) {
      return _clipPos(this, pos);
    },

    getCursor: function getCursor(start) {
      var range$$1 = this.sel.primary(),
          pos;
      if (start == null || start == "head") {
        pos = range$$1.head;
      } else if (start == "anchor") {
        pos = range$$1.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range$$1.to();
      } else {
        pos = range$$1.from();
      }
      return pos;
    },
    listSelections: function listSelections() {
      return this.sel.ranges;
    },
    somethingSelected: function somethingSelected() {
      return this.sel.somethingSelected();
    },

    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, _clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) {
        return;
      }
      var out = [];
      for (var i = 0; i < ranges.length; i++) {
        out[i] = new Range(_clipPos(this$1, ranges[i].anchor), _clipPos(this$1, ranges[i].head));
      }
      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function getSelection(lineSep) {
      var this$1 = this;

      var ranges = this.sel.ranges,
          lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function getSelections(lineSep) {
      var this$1 = this;

      var parts = [],
          ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) {
          sel = sel.join(lineSep || this$1.lineSeparator());
        }
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function replaceSelection(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++) {
        dup[i] = code;
      }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var this$1 = this;

      var changes = [],
          sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = { from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin };
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
        makeChange(this$1, changes[i$1]);
      }
      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function () {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function () {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "redo", true);
    }),

    setExtending: function setExtending(val) {
      this.extend = val;
    },
    getExtending: function getExtending() {
      return this.extend;
    },

    historySize: function historySize() {
      var hist = this.history,
          done = 0,
          undone = 0;
      for (var i = 0; i < hist.done.length; i++) {
        if (!hist.done[i].ranges) {
          ++done;
        }
      }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
        if (!hist.undone[i$1].ranges) {
          ++undone;
        }
      }
      return { undo: done, redo: undone };
    },
    clearHistory: function clearHistory() {
      this.history = new History(this.history.maxGeneration);
    },

    markClean: function markClean() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function changeGeneration(forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }
      return this.history.generation;
    },
    isClean: function isClean(gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function getHistory() {
      return { done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone) };
    },
    setHistory: function setHistory(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function (line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) {
          line.gutterMarkers = null;
        }
        return true;
      });
    }),

    clearGutter: docMethodOp(function (gutterID) {
      var this$1 = this;

      var i = this.first;
      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }
            return true;
          });
        }
        ++i;
      });
    }),

    lineInfo: function lineInfo(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }
        n = line;
        line = getLine(this, line);
        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);
        if (n == null) {
          return null;
        }
      }
      return { line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
        textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
        widgets: line.widgets };
    },

    addLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) {
          line[prop] = cls;
        } else if (classTest(cls).test(line[prop])) {
          return false;
        } else {
          line[prop] += " " + cls;
        }
        return true;
      });
    }),
    removeLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop] = null;
        } else {
          var found = cur.match(classTest(cls));
          if (!found) {
            return false;
          }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function removeLineWidget(widget) {
      widget.clear();
    },

    markText: function markText(from, to, options) {
      return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function setBookmark(pos, options) {
      var realOpts = { replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false, shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents };
      pos = _clipPos(this, pos);
      return _markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function findMarksAt(pos) {
      pos = _clipPos(this, pos);
      var markers = [],
          spans = getLine(this, pos.line).markedSpans;
      if (spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }
      return markers;
    },
    findMarks: function findMarks(from, to, filter) {
      from = _clipPos(this, from);to = _clipPos(this, to);
      var found = [],
          lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) {
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to || span.from == null && lineNo$$1 != from.line || span.from != null && lineNo$$1 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }
        ++lineNo$$1;
      });
      return found;
    },
    getAllMarks: function getAllMarks() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            if (sps[i].from != null) {
              markers.push(sps[i].marker);
            }
          }
        }
      });
      return markers;
    },

    posFromIndex: function posFromIndex(off) {
      var ch,
          lineNo$$1 = this.first,
          sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) {
          ch = off;return true;
        }
        off -= sz;
        ++lineNo$$1;
      });
      return _clipPos(this, Pos(lineNo$$1, ch));
    },
    indexFromPos: function indexFromPos(coords) {
      coords = _clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index;
    },

    copy: function copy(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep);
      doc.scrollTop = this.scrollTop;doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function linkedDoc(options) {
      if (!options) {
        options = {};
      }
      var from = this.first,
          to = this.first + this.size;
      if (options.from != null && options.from > from) {
        from = options.from;
      }
      if (options.to != null && options.to < to) {
        to = options.to;
      }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
      if (options.sharedHist) {
        copy.history = this.history;
      }(this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
      copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function unlinkDoc(other) {
      var this$1 = this;

      if (other instanceof CodeMirror$1) {
        other = other.doc;
      }
      if (this.linked) {
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this$1.linked[i];
          if (link.doc != other) {
            continue;
          }
          this$1.linked.splice(i, 1);
          other.unlinkDoc(this$1);
          detachSharedMarkers(findSharedMarkers(this$1));
          break;
        }
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          return splitIds.push(doc.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function iterLinkedDocs(f) {
      linkedDocs(this, f);
    },

    getMode: function getMode() {
      return this.mode;
    },
    getEditor: function getEditor() {
      return this.cm;
    },

    splitLines: function splitLines(str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }
      return splitLinesAuto(str);
    },
    lineSeparator: function lineSeparator() {
      return this.lineSep || "\n";
    }
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e_preventDefault(e);
    if (ie) {
      lastDrop = +new Date();
    }
    var pos = posFromMouse(cm, e, true),
        files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) {
      return;
    }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length,
          text = Array(n),
          read = 0;
      var loadFile = function loadFile(file, i) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          return;
        }

        var reader = new FileReader();
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            content = "";
          }
          text[i] = content;
          if (++read == n) {
            pos = _clipPos(cm.doc, pos);
            var change = { from: pos, to: pos,
              text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
              origin: "paste" };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) {
        loadFile(files[i], i);
      }
    } else {
      // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () {
          return cm.display.input.focus();
        }, 20);
        return;
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) {
            for (var i$1 = 0; i$1 < selected.length; ++i$1) {
              _replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
            }
          }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e) {}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) {
      return;
    }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) {
      return;
    }
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) {
        f(cm);
      }
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () {
      return forEachCodeMirror(onBlur);
    });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth) {
      return;
    }
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"

    // Number keys
  };for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) {
    keyNames[i$1] = String.fromCharCode(i$1);
  }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) {
    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
  }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
    // Note that the save and find-related commands aren't defined by
    // default. User code or addons can define them. Unknown commands
    // are simply ignored.
  };keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
    // Very basic readline/emacs-style bindings, which are standard on Mac.
  };keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      name = "Alt-" + name;
    }
    if (ctrl) {
      name = "Ctrl-" + name;
    }
    if (cmd) {
      name = "Cmd-" + name;
    }
    if (shift) {
      name = "Shift-" + name;
    }
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
          continue;
        }
        if (value == "...") {
          delete keymap[keyname];continue;
        }

        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i = 0; i < keys.length; i++) {
          var val = void 0,
              name = void 0;
          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }
        delete keymap[keyname];
      }
    }
    for (var prop in copy) {
      keymap[prop] = copy[prop];
    }
    return keymap;
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) {
      return "nothing";
    }
    if (found === "...") {
      return "multi";
    }
    if (found != null && handle(found)) {
      return "handled";
    }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]") {
        return lookupKey(key, map$$1.fallthrough, handle, context);
      }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) {
          return result;
        }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }
    var base = keyNames[event.keyCode],
        name = base;
    if (name == null || event.altGraphKey) {
      return false;
    }
    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
      name = "Cmd-" + name;
    }
    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }
    return name;
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges,
        kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--) {
        _replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      }
      ensureCursorVisible(cm);
    });
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function singleSelection(cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function killLine(cm) {
      return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine()) {
            return { from: range.head, to: Pos(range.head.line + 1, 0) };
          } else {
            return { from: range.head, to: Pos(range.head.line, len) };
          }
        } else {
          return { from: range.from(), to: range.to() };
        }
      });
    },
    deleteLine: function deleteLine(cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function delLineLeft(cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0), to: range.from()
        };
      });
    },
    delWrappedLineLeft: function delWrappedLineLeft(cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({ left: 0, top: top }, "div");
        return { from: leftPos, to: range.from() };
      });
    },
    delWrappedLineRight: function delWrappedLineRight(cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div");
        return { from: range.from(), to: rightPos };
      });
    },
    undo: function undo(cm) {
      return cm.undo();
    },
    redo: function redo(cm) {
      return cm.redo();
    },
    undoSelection: function undoSelection(cm) {
      return cm.undoSelection();
    },
    redoSelection: function redoSelection(cm) {
      return cm.redoSelection();
    },
    goDocStart: function goDocStart(cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function goDocEnd(cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function goLineStart(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStart(cm, range.head.line);
      }, { origin: "+move", bias: 1 });
    },
    goLineStartSmart: function goLineStartSmart(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStartSmart(cm, range.head);
      }, { origin: "+move", bias: 1 });
    },
    goLineEnd: function goLineEnd(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineEnd(cm, range.head.line);
      }, { origin: "+move", bias: -1 });
    },
    goLineRight: function goLineRight(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div");
      }, sel_move);
    },
    goLineLeft: function goLineLeft(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({ left: 0, top: top }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function goLineLeftSmart(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({ left: 0, top: top }, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
          return lineStartSmart(cm, range.head);
        }
        return pos;
      }, sel_move);
    },
    goLineUp: function goLineUp(cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function goLineDown(cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function goPageUp(cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function goPageDown(cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function goCharLeft(cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function goCharRight(cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function goColumnLeft(cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function goColumnRight(cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function goWordLeft(cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function goGroupRight(cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function goGroupLeft(cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function goWordRight(cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function delCharBefore(cm) {
      return cm.deleteH(-1, "char");
    },
    delCharAfter: function delCharAfter(cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function delWordBefore(cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function delWordAfter(cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function delGroupBefore(cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function delGroupAfter(cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function indentAuto(cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function indentMore(cm) {
      return cm.indentSelection("add");
    },
    indentLess: function indentLess(cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function insertTab(cm) {
      return cm.replaceSelection("\t");
    },
    insertSoftTab: function insertSoftTab(cm) {
      var spaces = [],
          ranges = cm.listSelections(),
          tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function defaultTab(cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function transposeChars(cm) {
      return runInOp(cm, function () {
        var ranges = cm.listSelections(),
            newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) {
            continue;
          }
          var cur = ranges[i].head,
              line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function newlineAndIndent(cm) {
      return runInOp(cm, function () {
        var sels = cm.listSelections();
        for (var i = sels.length - 1; i >= 0; i--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
        }
        sels = cm.listSelections();
        for (var i$1 = 0; i$1 < sels.length; i$1++) {
          cm.indentLine(sels[i$1].from().line, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function openLine(cm) {
      return cm.replaceSelection("\n", "start");
    },
    toggleOverwrite: function toggleOverwrite(cm) {
      return cm.toggleOverwrite();
    }
  };

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged,
        line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) {
        return false;
      }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift,
        done = false;
    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }
      if (dropShift) {
        cm.display.shift = false;
      }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) {
        return result;
      }
    }
    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed();
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }
      stopSeq.set(50, function () {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi") {
      cm.state.keySeq = name;
    }
    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) {
      return false;
    }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function (b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function (b) {
        return doHandleBinding(cm, b);
      });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) {
      return doHandleBinding(cm, b, true);
    });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) {
      return;
    }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }
    var keyCode = e.keyCode,
        charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;e_preventDefault(e);return;
    }
    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") {
      return;
    }
    if (handleCharBinding(cm, e, ch)) {
      return;
    }
    cm.display.input.onKeyPress(e);
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this,
        display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () {
          return display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) {
      return;
    }
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
      case 1:
        // #3261: make sure, that we're not starting a second selection
        if (cm.state.selectingText) {
          cm.state.selectingText(e);
        } else if (start) {
          leftButtonDown(cm, e, start);
        } else if (e_target(e) == display.scroller) {
          e_preventDefault(e);
        }
        break;
      case 2:
        if (webkit) {
          cm.state.lastMiddleDown = +new Date();
        }
        if (start) {
          extendSelection(cm.doc, start);
        }
        setTimeout(function () {
          return display.input.focus();
        }, 20);
        e_preventDefault(e);
        break;
      case 3:
        if (captureRightClick) {
          onContextMenu(cm, e);
        } else {
          delayBlurEvent(cm);
        }
        break;
    }
  }

  var lastClick;
  var lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt();
    }

    var now = +new Date(),
        type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = { time: now, pos: start };
    } else {
      type = "single";
      lastClick = { time: now, pos: start };
    }

    var sel = cm.doc.sel,
        modifier = mac ? e.metaKey : e.ctrlKey,
        contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && type == "single" && (contained = sel.contains(start)) > -1 && (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) && (cmp(contained.to(), start) > 0 || start.xRel < 0)) {
      leftButtonStartDrag(cm, e, start, modifier);
    } else {
      leftButtonSelect(cm, e, start, type, modifier);
    }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display,
        startTime = +new Date();
    var dragEnd = operation(cm, function (e2) {
      if (webkit) {
        display.scroller.draggable = false;
      }
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier && +new Date() - 200 < startTime) {
          extendSelection(cm.doc, start);
        }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9) {
          setTimeout(function () {
            document.body.focus();display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });
    // Let the drag handler handle this.
    if (webkit) {
      display.scroller.draggable = true;
    }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = mac ? e.altKey : e.ctrlKey;
    // IE's approach to draggable
    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display,
        doc = cm.doc;
    e_preventDefault(e);

    var ourRange,
        ourIndex,
        startSel = doc.sel,
        ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
      type = "rect";
      if (!addNew) {
        ourRange = new Range(start, start);
      }
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend) {
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      } else {
        ourRange = word;
      }
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), _clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend) {
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      } else {
        ourRange = line;
      }
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }
      lastPos = pos;

      if (type == "rect") {
        var ranges = [],
            tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol),
            right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc, line).text,
              leftPos = findColumn(text, left, tabSize);
          if (left == right) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }
        if (!ranges.length) {
          ranges.push(new Range(start, start));
        }
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), { origin: "*mouse", scroll: false });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor,
            head = pos;
        if (type != "single") {
          var range$$1;
          if (type == "double") {
            range$$1 = cm.findWordAt(pos);
          } else {
            range$$1 = new Range(Pos(pos.line, 0), _clipPos(doc, Pos(pos.line + 1, 0)));
          }
          if (cmp(range$$1.anchor, anchor) > 0) {
            head = range$$1.head;
            anchor = minPos(oldRange.from(), range$$1.anchor);
          } else {
            head = range$$1.anchor;
            anchor = maxPos(oldRange.to(), range$$1.head);
          }
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = new Range(_clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) {
        return;
      }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function () {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) {
          setTimeout(operation(cm, function () {
            if (counter != curCount) {
              return;
            }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (!e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    try {
      mX = e.clientX;mY = e.clientY;
    } catch (e) {
      return false;
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }
    if (prevent) {
      e_preventDefault(e);
    }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) {
      return e_defaultPrevented(e);
    }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = _lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }
    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = { toString: function toString() {
      return "CodeMirror.Init";
    } };

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) {
        optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) {
        return;
      }
      var newBreaks = [],
          lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) {
            break;
          }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--) {
        _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      }
    });
    option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      guttersChanged(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) {
        prev.detach(cm, next);
      }
      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("firstLineNumber", 1, guttersChanged, true);
    option("lineNumberFormatter", function (integer) {
      return integer;
    }, guttersChanged, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
        cm.display.disabled = true;
      } else {
        cm.display.disabled = false;
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });

    option("tabindex", null, function (cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function () {
      return alignHorizontally(cm);
    }, 20);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      return updateScrollbars(cm);
    }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror$1(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror$1)) {
      return new CodeMirror$1(place, options);
    }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") {
      doc = new Doc(doc, options.mode, null, options.lineSeparator);
    }
    this.doc = doc;

    var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }
    if (options.autofocus && !mobile) {
      display.input.focus();
    }
    initScrollbars(this);

    this.state = {
      keyMaps: [], // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0, // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null, // Unfinished key sequence
      specialChars: null

      // Override magic textarea content restore that IE sometimes does
      // on our hidden textarea on reload
    };if (ie && ie_version < 11) {
      setTimeout(function () {
        return this$1.display.input.reset(true);
      }, 20);
    }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(bind(onFocus, this), 20);
    } else {
      onBlur(this);
    }

    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this$1, options[opt], Init);
      }
    }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) {
      options.finishInit(this);
    }
    for (var i = 0; i < initHooks.length; ++i) {
      initHooks[i](this$1);
    }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  }

  // The default configuration options.
  CodeMirror$1.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror$1.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function (e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) {
      on(d.scroller, "contextmenu", function (e) {
        return onContextMenu(cm, e);
      });
    }

    // Used to suppress mouse event handling when a touch happens
    var touchFinished,
        prevTouch = { end: 0 };
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () {
          return d.activeTouch = null;
        }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date();
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }
      var dx = other.left - touch.left,
          dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date();
        d.activeTouch = { start: now, moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null };
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"),
            range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          {
            range = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          {
            range = cm.findWordAt(pos);
          } else // Triple tap
          {
            range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function (e) {
      return onScrollWheel(cm, e);
    });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });

    d.dragFunctions = {
      enter: function enter(e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function over(e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);e_stop(e);
        }
      },
      start: function start(e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function leave(e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function (e) {
      return onBlur(cm, e);
    });
  }

  var initHooks = [];
  CodeMirror$1.defineInitHook = function (f) {
    return initHooks.push(f);
  };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc,
        state;
    if (how == null) {
      how = "add";
    }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) {
        how = "prev";
      } else {
        state = getStateBefore(cm, n);
      }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n),
        curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    var curSpaceString = line.text.match(/^\s*/)[0],
        indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) {
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "",
        pos = 0;
    if (cm.options.indentWithTabs) {
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;indentString += "\t";
      }
    }
    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }

    if (indentString != curSpaceString) {
      _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break;
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) {
      sel = doc.sel;
    }

    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = splitLinesAuto(inserted),
        multiPaste = null;
    // When pasing N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++) {
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
          }
        }
      } else if (textLines.length == sel.ranges.length) {
        multiPaste = map(textLines, function (l) {
          return [l];
        });
      }
    }

    var updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(),
          to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) // Handle overwrite
          {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
          from = to = Pos(from.line, 0);
        }
      }
      updateInput = cm.curOp.updateInput;
      var changeEvent = { from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input") };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput) {
        runInOp(cm, function () {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }
      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line) {
        continue;
      }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch))) {
          indented = indentLine(cm, range$$1.head.line, "smart");
        }
      }
      if (indented) {
        signalLater(cm, "electricInput", cm, range$$1.head.line);
      }
    }
  }

  function copyableRanges(cm) {
    var text = [],
        ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return { text: text, ranges: ranges };
  }

  function disableBrowserMagic(field, spellcheck) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) {
      te.style.border = "1px solid black";
    }
    disableBrowserMagic(te);
    return div;
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  var addEditorMethods = function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function focus() {
        window.focus();this.display.input.focus();
      },

      setOption: function setOption(option, value) {
        var options = this.options,
            old = options[option];
        if (options[option] == value && option != "mode") {
          return;
        }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option)) {
          operation(this, optionHandlers[option])(this, value, old);
        }
      },

      getOption: function getOption(option) {
        return this.options[option];
      },
      getDoc: function getDoc() {
        return this.doc;
      },

      addKeyMap: function addKeyMap(map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function removeKeyMap(map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i) {
          if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true;
          }
        }
      },

      addOverlay: methodOp(function (spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }
        insertSorted(this.state.overlays, { mode: mode, modeSpec: spec, opaque: options && options.opaque,
          priority: options && options.priority || 0 }, function (overlay) {
          return overlay.priority;
        });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function (spec) {
        var this$1 = this;

        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return;
          }
        }
      }),

      indentLine: methodOp(function (n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }
        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function (how) {
        var this$1 = this;

        var ranges = this.doc.sel.ranges,
            end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(),
                to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j) {
              indentLine(this$1, j, how);
            }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
              replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) {
              ensureCursorVisible(this$1);
            }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function getTokenAt(pos, precise) {
        return takeToken(this, pos, precise);
      },

      getLineTokens: function getLineTokens(line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },

      getTokenTypeAt: function getTokenTypeAt(pos) {
        pos = _clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0,
            after = (styles.length - 1) / 2,
            ch = pos.ch;
        var type;
        if (ch == 0) {
          type = styles[2];
        } else {
          for (;;) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type = styles[mid * 2 + 2];break;
            }
          }
        }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
      },

      getModeAt: function getModeAt(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) {
          return mode;
        }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
      },

      getHelper: function getHelper(pos, type) {
        return this.getHelpers(pos, type)[0];
      },

      getHelpers: function getHelpers(pos, type) {
        var this$1 = this;

        var found = [];
        if (!helpers.hasOwnProperty(type)) {
          return found;
        }
        var help = helpers[type],
            mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) {
            found.push(help[mode[type]]);
          }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }
        return found;
      },

      getStateAfter: function getStateAfter(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
        return getStateBefore(this, line + 1, precise);
      },

      cursorCoords: function cursorCoords(start, mode) {
        var pos,
            range$$1 = this.doc.sel.primary();
        if (start == null) {
          pos = range$$1.head;
        } else if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) == "object") {
          pos = _clipPos(this.doc, start);
        } else {
          pos = start ? range$$1.from() : range$$1.to();
        }
        return _cursorCoords(this, pos, mode || "page");
      },

      charCoords: function charCoords(pos, mode) {
        return _charCoords(this, _clipPos(this.doc, pos), mode || "page");
      },

      coordsChar: function coordsChar(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return _coordsChar(this, coords.left, coords.top);
      },

      lineAtHeight: function lineAtHeight(height, mode) {
        height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
        return _lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function heightAtLine(line, mode, includeWidgets) {
        var end = false,
            lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;end = true;
          }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);
      },

      defaultTextHeight: function defaultTextHeight() {
        return textHeight(this.display);
      },
      defaultCharWidth: function defaultCharWidth() {
        return charWidth(this.display);
      },

      getViewport: function getViewport() {
        return { from: this.display.viewFrom, to: this.display.viewTo };
      },

      addWidget: function addWidget(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = _cursorCoords(this, _clipPos(this.doc, pos));
        var top = pos.bottom,
            left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }
          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }
          node.style.left = left + "px";
        }
        if (scroll) {
          scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
        }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,

      execCommand: function execCommand(cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },

      triggerElectric: methodOp(function (text) {
        triggerElectric(this, text);
      }),

      findPosH: function findPosH(from, amount, unit, visually) {
        var this$1 = this;

        var dir = 1;
        if (amount < 0) {
          dir = -1;amount = -amount;
        }
        var cur = _clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = _findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },

      moveH: methodOp(function (dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty()) {
            return _findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
        }, sel_move);
      }),

      deleteH: methodOp(function (dir, unit) {
        var sel = this.doc.sel,
            doc = this.doc;
        if (sel.somethingSelected()) {
          doc.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function (range$$1) {
            var other = _findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? { from: other, to: range$$1.head } : { from: range$$1.head, to: other };
          });
        }
      }),

      findPosV: function findPosV(from, amount, unit, goalColumn) {
        var this$1 = this;

        var dir = 1,
            x = goalColumn;
        if (amount < 0) {
          dir = -1;amount = -amount;
        }
        var cur = _clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = _cursorCoords(this$1, cur, "div");
          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }
          cur = _findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },

      moveV: methodOp(function (dir, unit) {
        var this$1 = this;

        var doc = this.doc,
            goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse) {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
          var headPos = _cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) {
            headPos.left = range$$1.goalColumn;
          }
          goals.push(headPos.left);
          var pos = _findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary()) {
            addToScrollPos(this$1, null, _charCoords(this$1, pos, "div").top - headPos.top);
          }
          return pos;
        }, sel_move);
        if (goals.length) {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            doc.sel.ranges[i].goalColumn = goals[i];
          }
        }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function findWordAt(pos) {
        var doc = this.doc,
            line = getLine(doc, pos.line).text;
        var start = pos.ch,
            end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.xRel < 0 || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function (ch) {
            return isWordChar(ch, helper);
          } : /\s/.test(startChar) ? function (ch) {
            return (/\s/.test(ch)
            );
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }
          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },

      toggleOverwrite: function toggleOverwrite(value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }
        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function hasFocus() {
        return this.display.input.getField() == activeElt();
      },
      isReadOnly: function isReadOnly() {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },

      scrollTo: methodOp(function (x, y) {
        if (x != null || y != null) {
          resolveScrollToPos(this);
        }
        if (x != null) {
          this.curOp.scrollLeft = x;
        }
        if (y != null) {
          this.curOp.scrollTop = y;
        }
      }),
      getScrollInfo: function getScrollInfo() {
        var scroller = this.display.scroller;
        return { left: scroller.scrollLeft, top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this), clientWidth: displayWidth(this) };
      },

      scrollIntoView: methodOp(function (range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = { from: this.doc.sel.primary().head, to: null };
          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range$$1 == "number") {
          range$$1 = { from: Pos(range$$1, 0), to: null };
        } else if (range$$1.from == null) {
          range$$1 = { from: range$$1, to: null };
        }
        if (!range$$1.to) {
          range$$1.to = range$$1.from;
        }
        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          resolveScrollToPos(this);
          this.curOp.scrollToPos = range$$1;
        } else {
          var sPos = calculateScrollPos(this, Math.min(range$$1.from.left, range$$1.to.left), Math.min(range$$1.from.top, range$$1.to.top) - range$$1.margin, Math.max(range$$1.from.right, range$$1.to.right), Math.max(range$$1.from.bottom, range$$1.to.bottom) + range$$1.margin);
          this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
      }),

      setSize: methodOp(function (width, height) {
        var this$1 = this;

        var interpret = function interpret(val) {
          return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
        };
        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }
        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }
        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].noHScroll) {
                regLineChange(this$1, lineNo$$1, "widget");break;
              }
            }
          }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function operation(f) {
        return runInOp(this, f);
      },

      refresh: methodOp(function () {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
          estimateLineHeights(this);
        }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function (doc) {
        var old = this.doc;
        old.cm = null;
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        this.scrollTo(doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),

      getInputField: function getInputField() {
        return this.display.input.getField();
      },
      getWrapperElement: function getWrapperElement() {
        return this.display.wrapper;
      },
      getScrollerElement: function getScrollerElement() {
        return this.display.scroller;
      },
      getGutterElement: function getGutterElement() {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function (type, name, value) {
      if (!helpers.hasOwnProperty(type)) {
        helpers[type] = CodeMirror[type] = { _global: [] };
      }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({ pred: predicate, val: value });
    };
  };

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function _findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line,
        ch = pos.ch,
        origDir = dir;
    var lineObj = getLine(doc, line);
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) {
        return false;
      }
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) {
            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          } else {
            ch = dir < 0 ? lineObj.text.length : 0;
          }
        } else {
          return false;
        }
      } else {
        ch = next;
      }
      return true;
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null,
          group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
        if (group && !first && !type) {
          type = "s";
        }
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;moveOnce();
          }
          break;
        }

        if (type) {
          sawType = type;
        }
        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
    if (!cmp(pos, result)) {
      result.hitSide = true;
    }
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function _findPosV(cm, pos, dir, unit) {
    var doc = cm.doc,
        x = pos.left,
        y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = _coordsChar(cm, x, y);
      if (!target.outside) {
        break;
      }
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;break;
      }
      y += dir * 5;
    }
    return target;
  }

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  }

  ContentEditableInput.prototype = copyObj({
    init: function init(display) {
      var this$1 = this;

      var input = this,
          cm = input.cm;
      var div = input.div = display.lineDiv;
      disableBrowserMagic(div, cm.options.spellcheck);

      on(div, "paste", function (e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
          return;
        }
        // IE doesn't fire input events, so we schedule a read for the pasted content in this way
        if (ie_version <= 11) {
          setTimeout(operation(cm, function () {
            if (!input.pollContent()) {
              regChange(cm);
            }
          }), 20);
        }
      });

      on(div, "compositionstart", function (e) {
        this$1.composing = { data: e.data };
      });
      on(div, "compositionupdate", function (e) {
        if (!this$1.composing) {
          this$1.composing = { data: e.data };
        }
      });
      on(div, "compositionend", function (e) {
        if (this$1.composing) {
          if (e.data != this$1.composing.data) {
            this$1.readFromDOMSoon();
          }
          this$1.composing = null;
        }
      });

      on(div, "touchstart", function () {
        return input.forceCompositionEnd();
      });

      on(div, "input", function () {
        if (!this$1.composing) {
          this$1.readFromDOMSoon();
        }
      });

      function onCopyCut(e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
          if (e.type == "cut") {
            cm.replaceSelection("", null, "cut");
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.operation(function () {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e.clipboardData) {
          e.clipboardData.clearData();
          var content = lastCopied.text.join("\n");
          // iOS exposes the clipboard API, but seems to discard content inserted into it
          e.clipboardData.setData("Text", content);
          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return;
          }
        }
        // Old-fashioned briefly-focus-a-textarea hack
        var kludge = hiddenTextarea(),
            te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = lastCopied.text.join("\n");
        var hadFocus = document.activeElement;
        selectInput(te);
        setTimeout(function () {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div) {
            input.showPrimarySelection();
          }
        }, 50);
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function prepareSelection() {
      var result = _prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function showSelection(info, takeFocus) {
      if (!info || !this.cm.display.view.length) {
        return;
      }
      if (info.focus || takeFocus) {
        this.showPrimarySelection();
      }
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function showPrimarySelection() {
      var sel = window.getSelection(),
          prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), prim.from()) == 0 && cmp(maxPos(curAnchor, curFocus), prim.to()) == 0) {
        return;
      }

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) {
        return;
      }

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = { node: view[0].measure.map[2], offset: 0 };
      } else if (!end) {
        // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = { node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3] };
      }

      var rng;
      try {
        rng = range(start.node, start.offset, end.offset, end.node);
      } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        if (!gecko && this.cm.state.focused) {
          sel.collapse(start.node, start.offset);
          if (!rng.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) {
          sel.addRange(old);
        } else if (gecko) {
          this.startGracePeriod();
        }
      }
      this.rememberSelection();
    },

    startGracePeriod: function startGracePeriod() {
      var this$1 = this;

      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function () {
        this$1.gracePeriod = false;
        if (this$1.selectionChanged()) {
          this$1.cm.operation(function () {
            return this$1.cm.curOp.selectionChanged = true;
          });
        }
      }, 20);
    },

    showMultipleSelections: function showMultipleSelections(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function rememberSelection() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode;this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode;this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function selectionInEditor() {
      var sel = window.getSelection();
      if (!sel.rangeCount) {
        return false;
      }
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function focus() {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor()) {
          this.showSelection(this.prepareSelection(), true);
        }
        this.div.focus();
      }
    },
    blur: function blur() {
      this.div.blur();
    },
    getField: function getField() {
      return this.div;
    },

    supportsTouch: function supportsTouch() {
      return true;
    },

    receivedFocus: function receivedFocus() {
      var input = this;
      if (this.selectionInEditor()) {
        this.pollSelection();
      } else {
        runInOp(this.cm, function () {
          return input.cm.curOp.selectionChanged = true;
        });
      }

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function selectionChanged() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function pollSelection() {
      if (!this.composing && this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(),
            cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) {
          runInOp(cm, function () {
            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
            if (anchor.bad || head.bad) {
              cm.curOp.selectionChanged = true;
            }
          });
        }
      }
    },

    pollContent: function pollContent() {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }

      var cm = this.cm,
          display = cm.display,
          sel = cm.doc.sel.primary();
      var from = sel.from(),
          to = sel.to();
      if (from.ch == 0 && from.line > cm.firstLine()) {
        from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
      }
      if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
        to = Pos(to.line + 1, 0);
      }
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
        return false;
      }

      var fromIndex, fromLine, fromNode;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        fromLine = lineNo(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = lineNo(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      var toLine, toNode;
      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = lineNo(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }

      if (!fromNode) {
        return false;
      }
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) {
          newText.pop();oldText.pop();toLine--;
        } else if (newText[0] == oldText[0]) {
          newText.shift();oldText.shift();fromLine++;
        } else {
          break;
        }
      }

      var cutFront = 0,
          cutEnd = 0;
      var newTop = newText[0],
          oldTop = oldText[0],
          maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
        ++cutFront;
      }
      var newBot = lst(newText),
          oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        ++cutEnd;
      }

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        _replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function ensurePolled() {
      this.forceCompositionEnd();
    },
    reset: function reset() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function forceCompositionEnd() {
      if (!this.composing) {
        return;
      }
      this.composing = null;
      if (!this.pollContent()) {
        regChange(this.cm);
      }
      this.div.blur();
      this.div.focus();
    },
    readFromDOMSoon: function readFromDOMSoon() {
      var this$1 = this;

      if (this.readDOMTimeout != null) {
        return;
      }
      this.readDOMTimeout = setTimeout(function () {
        this$1.readDOMTimeout = null;
        if (this$1.composing) {
          return;
        }
        if (this$1.cm.isReadOnly() || !this$1.pollContent()) {
          runInOp(this$1.cm, function () {
            return regChange(this$1.cm);
          });
        }
      }, 80);
    },

    setUneditable: function setUneditable(node) {
      node.contentEditable = "false";
    },

    onKeyPress: function onKeyPress(e) {
      e.preventDefault();
      if (!this.cm.isReadOnly()) {
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
      }
    },

    readOnlyChanged: function readOnlyChanged(val) {
      this.div.contentEditable = String(val != "nocursor");
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) {
      return null;
    }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line),
        side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }return pos;
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "",
        closing = false,
        lineSep = cm.doc.lineSeparator();
    function recognizeMarker(id) {
      return function (marker) {
        return marker.id == id;
      };
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") {
            text += node.textContent.replace(/\u200b/g, "");
          } else {
            text += cmText;
          }
          return;
        }
        var markerID = node.getAttribute("cm-marker"),
            range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find())) {
            text += getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep);
          }
          return;
        }
        if (node.getAttribute("contenteditable") == "false") {
          return;
        }
        for (var i = 0; i < node.childNodes.length; i++) {
          walk(node.childNodes[i]);
        }
        if (/^(pre|div|p)$/i.test(node.nodeName)) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) {
          return;
        }
        if (closing) {
          text += lineSep;
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) {
        break;
      }
      from = from.nextSibling;
    }
    return text;
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }
      node = null;offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild,
        bad = false;
    if (!node || !contains(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null,
        topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }
    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }
    var measure = lineView.measure,
        maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) {
              ch = map$$1[j + (offset ? 1 : 0)];
            }
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) {
      return badPos(found, bad);
    }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found) {
        return badPos(Pos(found.line, found.ch + dist$1), bad);
      } else {
        dist$1 += before.textContent.length;
      }
    }
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  }

  TextareaInput.prototype = copyObj({
    init: function init(display) {
      var this$1 = this;

      var input = this,
          cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) {
        te.style.width = "0px";
      }

      on(te, "input", function () {
        if (ie && ie_version >= 9 && this$1.hasSelection) {
          this$1.hasSelection = null;
        }
        input.poll();
      });

      on(te, "paste", function (e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
          return;
        }

        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.text.join("\n");
            selectInput(te);
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") {
          cm.state.cutIncoming = true;
        }
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function (e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
          return;
        }
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function (e) {
        if (!eventInWidget(display, e)) {
          e_preventDefault(e);
        }
      });

      on(te, "compositionstart", function () {
        var start = cm.getCursor("from");
        if (input.composing) {
          input.composing.range.clear();
        }
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
        };
      });
      on(te, "compositionend", function () {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    },

    prepareSelection: function prepareSelection() {
      // Redraw the selection and/or cursor
      var cm = this.cm,
          display = cm.display,
          doc = cm.doc;
      var result = _prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = _cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(),
            lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function showSelection(drawn) {
      var cm = this.cm,
          display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function reset(typing) {
      if (this.contextMenuPending) {
        return;
      }
      var minimal,
          selected,
          cm = this.cm,
          doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range$$1 = doc.sel.primary();
        minimal = hasCopyEvent && (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) {
          selectInput(this.textarea);
        }
        if (ie && ie_version >= 9) {
          this.hasSelection = content;
        }
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }
      }
      this.inaccurateSelection = minimal;
    },

    getField: function getField() {
      return this.textarea;
    },

    supportsTouch: function supportsTouch() {
      return false;
    },

    focus: function focus() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try {
          this.textarea.focus();
        } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function blur() {
      this.textarea.blur();
    },

    resetPosition: function resetPosition() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function receivedFocus() {
      this.slowPoll();
    },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function slowPoll() {
      var this$1 = this;

      if (this.pollingFast) {
        return;
      }
      this.polling.set(this.cm.options.pollInterval, function () {
        this$1.poll();
        if (this$1.cm.state.focused) {
          this$1.slowPoll();
        }
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function fastPoll() {
      var missed = false,
          input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {
          missed = true;input.polling.set(60, p);
        } else {
          input.pollingFast = false;input.slowPoll();
        }
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function poll() {
      var this$1 = this;

      var cm = this.cm,
          input = this.textarea,
          prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
        return false;
      }

      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) {
        return false;
      }
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 0x200b && !prevInput) {
          prevInput = '\u200B';
        }
        if (first == 0x21da) {
          this.reset();return this.cm.execCommand("undo");
        }
      }
      // Find the part of the input that is actually new
      var same = 0,
          l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
        ++same;
      }

      runInOp(cm, function () {
        applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) {
          input.value = this$1.prevInput = "";
        } else {
          this$1.prevInput = text;
        }

        if (this$1.composing) {
          this$1.composing.range.clear();
          this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
        }
      });
      return true;
    },

    ensurePolled: function ensurePolled() {
      if (this.pollingFast && this.poll()) {
        this.pollingFast = false;
      }
    },

    onKeyPress: function onKeyPress() {
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
      this.fastPoll();
    },

    onContextMenu: function onContextMenu(e) {
      var input = this,
          cm = input.cm,
          display = cm.display,
          te = input.textarea;
      var pos = posFromMouse(cm, e),
          scrollPos = display.scroller.scrollTop;
      if (!pos || presto) {
        return;
      } // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1) {
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
      }

      var oldCSS = te.style.cssText,
          oldWrapperCSS = input.wrapper.style.cssText;
      input.wrapper.style.cssText = "position: absolute";
      var wrapperBox = input.wrapper.getBoundingClientRect();
      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      var oldScrollY;
      if (webkit) {
        oldScrollY = window.scrollY;
      } // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) {
        window.scrollTo(null, oldScrollY);
      }
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) {
        te.value = input.prevInput = " ";
      }
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = '\u200B' + (selected ? te.value : "");
          te.value = '\u21DA'; // Used to catch context-menu undo
          te.value = extval;
          input.prevInput = selected ? "" : '\u200B';
          te.selectionStart = 1;te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS;
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) {
          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
        }

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || ie && ie_version < 9) {
            prepareSelectAllHack();
          }
          var i = 0,
              poll = function poll() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == '\u200B') {
              operation(cm, selectAll)(cm);
            } else if (i++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.input.reset();
            }
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) {
        prepareSelectAllHack();
      }
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function mouseup() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    readOnlyChanged: function readOnlyChanged(val) {
      if (!val) {
        this.reset();
      }
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }
    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {
      textarea.value = cm.getValue();
    }

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () {
        return textarea;
      };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror$1(function (node) {
      return textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror$1);

  addEditorMethods(CodeMirror$1);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror$1.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }

  eventMixin(Doc);

  // INPUT HANDLING

  CodeMirror$1.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput

    // MODE DEFINITION AND QUERYING

    // Extra arguments are stored as the mode's dependencies, which is
    // used by (legacy) mechanisms like loadmode.js to automatically
    // load a mode. (Preferred mechanism is the require/define calls.)
  };CodeMirror$1.defineMode = function (name /*, mode, …*/) {
    if (!CodeMirror$1.defaults.mode && name != "null") {
      CodeMirror$1.defaults.mode = name;
    }
    defineMode.apply(this, arguments);
  };

  CodeMirror$1.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror$1.defineMode("null", function () {
    return { token: function token(stream) {
        return stream.skipToEnd();
      } };
  });
  CodeMirror$1.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror$1.defineExtension = function (name, func) {
    CodeMirror$1.prototype[name] = func;
  };
  CodeMirror$1.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror$1.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror$1);

  CodeMirror$1.version = "5.21.1";

  return CodeMirror$1;
});

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(34)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, PanelCanvas) {

    /**
     * Returns a helper class implementing a scaler object, containing a total range and a variable subrange within this total range
     * This is used to define a zoomed range (subrange) within a complete range (canvas)
     * @param {Scaler} iScaler - (optional) another scaler object from which settings should be copied
     * @returns {{}} - object instance
     * @constructor
     */
    var Scaler = function Scaler(iScaler) {
        var scaler = {};

        if (iScaler) {
            scaler.minVal = iScaler.minVal;
            scaler.maxVal = iScaler.maxVal;
            scaler.range = iScaler.range;
            scaler.offset = iScaler.offset;
        }

        /**
         * Sets the range of the scaler
         * @param {float} minVal
         * @param {float} maxVal
         */
        scaler.setRange = function (minVal, maxVal) {
            scaler.minVal = minVal;
            scaler.maxVal = maxVal;
            scaler.range = scaler.maxVal - scaler.minVal;
            scaler.offset = scaler.minVal;
            scaler.isZoomed = false;
        };

        /**
         * Returns the range size
         * @returns {float}
         */
        scaler.getRange = function () {
            return scaler.range;
        };

        /**
         * Returns the subrange offset
         * @returns {float}
         */
        scaler.getOffset = function () {
            return scaler.offset;
        };

        /**
         * Returns the minimum value of the subrange
         * @returns {float}
         */
        scaler.getMinVisibleRange = function () {
            return scaler.offset;
        };

        /**
         * Returns the maximum value of the subrange
         * @returns {float}
         */
        scaler.getMaxVisibleRange = function () {
            return scaler.offset + scaler.range;
        };

        /**
         * Converts a value into a fractional position within the subrange
         * @param {float} vl - value
         * @returns {number} - fraction
         */
        scaler.toFraction = function (vl) {
            return (vl - scaler.offset) / scaler.range;
        };

        /**
         * Returns the min and max position of the subrange as fractional positions within the entire range
         * @returns {{mn: number, mx: number}}
         */
        scaler.getViewPortFraction = function () {
            return {
                mn: (scaler.offset - scaler.minVal) / (scaler.maxVal - scaler.minVal),
                mx: (scaler.offset + scaler.range - scaler.minVal) / (scaler.maxVal - scaler.minVal)
            };
        };

        /**
         * Clips the subrange to the complete range
         */
        scaler.clipRange = function () {
            if (scaler.range > scaler.maxVal - scaler.minVal) scaler.range = scaler.maxVal - scaler.minVal;

            var minval = 0.0 * scaler.range + scaler.offset;
            if (minval < scaler.minVal) scaler.offset = scaler.minVal;

            var maxval = 1.0 * scaler.range + scaler.offset;
            if (maxval > scaler.maxVal) scaler.offset = scaler.maxVal - scaler.range;
        };

        /**
         * Zooms the subrange
         * @param {float} fac - zoom factor
         * @param {float} centerFrac - relative position of the zoom center
         */
        scaler.zoom = function (fac, centerFrac) {
            var fixedPosValue = centerFrac * scaler.range + scaler.offset;
            scaler.range /= fac;
            scaler.offset = (fixedPosValue / scaler.range - centerFrac) * scaler.range;
            scaler.clipRange();
            if (fac > 1) scaler.isZoomed = true;
        };

        /**
         * Shifts the subrange
         * @param {float} fr - shift distance as a fraction of the total range
         */
        scaler.panFraction = function (fr) {
            scaler.offset += fr * scaler.range;
            scaler.clipRange();
        };

        return scaler;
    };

    /**
     * Implements a panel that contains a html5 canvas element
     * @param {string} id - panel type id
     * @returns {Object} - panel instance
     * @constructor
     */
    var Module = {};

    /**
     * Implements a panel that contains a zoom-and-drag html5 canvas element
     * @param {string} id - panel type id
     * @param {{}} settings - panel settings
     * @param {int} settings.scaleMarginY - size of margin used to draw the scale
     * @param {boolean} settings.selectXDirOnly - if true, only x direction can be zoomed and scrolled
     * @param {boolean} settings.autoRemoveSelection - if false, the user-drawn selection is not automatically removed
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.create = function (id, settings) {
        var panel = PanelCanvas.create(id);

        if (!settings) settings = {};

        panel.scaleMarginX = 37;
        panel.scaleMarginY = settings.scaleMarginY || 37;

        panel.selectXDirOnly = settings.selectXDirOnly || false;

        panel._dragActionPan = true;
        panel._canZoomX = true;
        panel._canZoomY = true;
        panel._minRangeX = 1e-9; // to counter floating precision errors
        panel._minRangeY = 1e-9;
        panel._toolTipInfo = { ID: null };
        panel._selectionMode = false;
        panel.handleRectSelection = null;
        panel._autoRemoveSelection = true;
        if (settings.autoRemoveSelection === false) panel._autoRemoveSelection = false;
        //panel._directRedraw = true;

        /**
         * The X zoom range scaler
         * @type {Scaler}
         */
        panel.xScaler = Scaler();

        /**
         * The Y zoom range scaler
         * @type {Scaler}
         */
        panel.yScaler = Scaler();

        panel.getXRangeMin = function () {
            return panel.xScaler.getMinVisibleRange();
        };

        panel.getXRangeMax = function () {
            return panel.xScaler.getMaxVisibleRange();
        };

        panel.getYRangeMin = function () {
            return panel.yScaler.getMinVisibleRange();
        };

        panel.getYRangeMax = function () {
            return panel.yScaler.getMaxVisibleRange();
        };

        panel.setXRange = function (minval, maxval) {
            panel.xScaler.setRange(minval, maxval);
        };
        panel.setYRange = function (minval, maxval) {
            panel.yScaler.setRange(minval, maxval);
        };
        panel.getXScale = function () {
            return 1.0 / panel.xScaler.getRange() * (panel.drawSizeX - panel.scaleMarginX);
        };
        panel.getXOffset = function () {
            return panel.scaleMarginX - panel.xScaler.getOffset() * panel.getXScale();
        };
        panel.getYScale = function () {
            return -1.0 / panel.yScaler.getRange() * (panel.drawSizeY - panel.scaleMarginY);
        };
        panel.getYOffset = function () {
            return panel.drawSizeY - panel.scaleMarginY - panel.yScaler.getOffset() * panel.getYScale();
        };

        /**
         * Specifies in what direction the canvas can zoom
         * @param {boolean} canZoomX
         * @param {boolean} canZoomY
         */
        panel.setZoomDirections = function (canZoomX, canZoomY) {
            panel._canZoomX = canZoomX;
            panel._canZoomY = canZoomY;
        };

        /**
         * Specify min range on both axes
         * @param {boolean} minRangeX
         * @param {boolean} minRangeY
         */
        panel.setMinRanges = function (minRangeX, minRangeY) {
            panel._minRangeX = minRangeX;
            panel._minRangeY = minRangeY;
        };

        /**
         * Specifies in what direction the canvas can zoom
         */
        panel.canZoomX = function (scaleFactor) {
            return panel._canZoomX && (scaleFactor <= 1.0 || panel.xScaler.getRange() > panel._minRangeX);
        };

        /**
         * Specifies in what direction the canvas can zoom
         */
        panel.canZoomY = function (scaleFactor) {
            return panel._canZoomY && (scaleFactor <= 1.0 || panel.yScaler.getRange() > panel._minRangeY);
        };

        /**
         * Enables or disables the selection modus. When enables, mouse dragging sets the selection rather than panning
         * @param {bool} status
         */
        panel.setSelectionMode = function (status) {
            panel._selectionMode = status;
        };

        /**
         * Sets the handler that handles selection events
         * @param {function(pointTopLeft, pointRightbottom)} handler
         */
        panel.setHandleRectSelection = function (handler) {
            panel.handleRectSelection = handler;
        };

        /**
         * Drawing function, to be implemented in derived classes
         * @param drawInfo
         */
        panel.drawCenter = function (drawInfo) {};

        /**
         * Returns tooltip information for a location
         * Optionally to be implemented in a direved class
         * @param {int} px - x position
         * @param {int} py - y position
         * @returns {{ID, px, py, content}} - tooltip info (may be null if no tooltip is to be shown)
         */
        panel.getToolTipInfo = function (px, py) {
            return null;
        };

        /**
         * Optionally to be implemented by a derived class to be notified about clicks
         * @param {{}} ev - event handler
         * @param info
         */
        panel.onMouseClick = function (ev, info) {};

        /**
         * Draws the canvas
         * @param drawInfo
         */
        panel.draw = function (drawInfo) {
            panel.drawSizeX = drawInfo.sizeX;
            panel.drawSizeY = drawInfo.sizeY;
            panel.drawCenter(drawInfo);
            panel.drawScale(drawInfo);
        };

        /**
         * Draws the scale(s)
         * @param drawInfo
         */
        panel.drawScale = function (drawInfo) {
            panel.drawSizeX = drawInfo.sizeX;
            panel.drawSizeY = drawInfo.sizeY;
            var ctx = drawInfo.ctx;

            ctx.fillStyle = "rgb(220,220,220)";
            ctx.fillRect(0, 0, panel.scaleMarginX, drawInfo.sizeY);
            ctx.fillRect(0, drawInfo.sizeY - panel.scaleMarginY, drawInfo.sizeX, panel.scaleMarginY);

            if (panel.drawXScale) panel.drawXScale(drawInfo);
            if (panel.drawYScale) panel.drawYScale(drawInfo);

            ctx.fillStyle = "rgba(0,0,0,0.2)";
            var vpFraction = panel.xScaler.getViewPortFraction();
            var imW = drawInfo.sizeX - panel.scaleMarginX;
            ctx.fillRect(panel.scaleMarginX + vpFraction.mn * imW, drawInfo.sizeY - 5, (vpFraction.mx - vpFraction.mn) * imW, 5);
            var vpFraction = panel.yScaler.getViewPortFraction();
            var imH = drawInfo.sizeY - panel.scaleMarginY;
            ctx.fillRect(0, (1 - vpFraction.mx) * imH, 5, (vpFraction.mx - vpFraction.mn) * imH);
        };

        /**
         * Updates the scale drawings
         */
        panel.renderScale = function () {
            var ctx = panel.getCanvasElement('main').getContext("2d");
            ctx.fillStyle = "#FFFFFF";
            var drawInfo = {
                ctx: ctx,
                sizeX: panel._cnvWidth,
                sizeY: panel._cnvHeight,
                scaleBorderOnly: true
            };
            panel.drawScale(drawInfo);
        };

        /**
         * Display a tooltip
         * @param tooltipInfo
         * @private
         */
        panel._showToolTip = function (tooltipInfo) {
            panel._hideToolTip();
            panel._toolTipInfo = tooltipInfo;
            if (tooltipInfo.content) {
                var tooltip = DOM.Div();
                tooltip.addCssClass("AXMToolTip");
                tooltip.addStyle("position", "absolute");
                var screenX = panel.posXCanvas2Screen(panel._toolTipInfo.px);
                var screenY = panel.posYCanvas2Screen(panel._toolTipInfo.py);
                tooltip.addStyle("left", screenX + 10 + 'px');
                tooltip.addStyle("top", screenY + 10 + 'px');
                tooltip.addStyle("z-index", '9999999');
                tooltip.addElem(panel._toolTipInfo.content);
                $('.AXMContainer').append(tooltip.toString());
            }
        };

        /**
         * Hides a displayed tooltip, if any
         * @private
         */
        panel._hideToolTip = function () {
            panel._toolTipInfo.ID = null;
            $('.AXMContainer').find('.AXMToolTip').remove();
        };

        /**
         * Finalises a zoom & pan action
         */
        panel.finishZoomPan = function () {
            if (panel.zoompanProcessing) {
                panel.zoompanProcessing = false;
                panel.render();
            }
        };

        panel.ThrottledFinishZoomPan = AXMUtils.debounce(panel.finishZoomPan, 250);
        /**
         * Adjusts the scalers according to a new position
         * @param {Scaler} newXScaler - new X scaler
         * @param {Scaler} newYScaler - new Y scaler
         * @private
         */
        panel._setNewScalers = function (newXScaler, newYScaler) {
            if (panel._directRedraw) {
                panel.xScaler = newXScaler;
                panel.yScaler = newYScaler;
                panel.render();
            } else {
                var mainCanvas = panel.getCanvasElement('main');
                var ctx = mainCanvas.getContext("2d");
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                if (!panel.zoompanProcessing) {
                    panel.zoompanProcessing = true;
                    panel.zoompanImage = new Image();
                    panel.zoompanImage.id = "tempzoompic";
                    panel.zoompanImage.src = mainCanvas.toDataURL();
                    panel.origXScaler = Scaler(panel.xScaler);
                    panel.origYScaler = Scaler(panel.yScaler);
                }
                panel.xScaler = newXScaler;
                panel.yScaler = newYScaler;
                if (!panel.zoompanProcessing) {
                    panel.zoompanProcessing = true;
                    panel.zoompanImage = new Image();
                    panel.zoompanImage.id = "tempzoompic";
                    panel.zoompanImage.src = mainCanvas.toDataURL();
                }

                ctx.scale(panel.ratio, panel.ratio);
                ctx.fillStyle = "rgb(240,240,240)";
                ctx.fillRect(0, 0, panel._cnvWidth, panel._cnvHeight);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                var frx1 = panel.xScaler.toFraction(panel.origXScaler.getMinVisibleRange());
                var frx2 = panel.xScaler.toFraction(panel.origXScaler.getMaxVisibleRange());
                var fry1 = panel.yScaler.toFraction(panel.origYScaler.getMinVisibleRange());
                var fry2 = panel.yScaler.toFraction(panel.origYScaler.getMaxVisibleRange());
                var imW = panel.zoompanImage.width - panel.scaleMarginX * panel.ratio;
                var imH = panel.zoompanImage.height - panel.scaleMarginY * panel.ratio;
                ctx.drawImage(panel.zoompanImage, panel.scaleMarginX * panel.ratio, 0, imW, imH, panel.scaleMarginX * panel.ratio + imW * frx1, imH * (1 - fry2), imW * (frx2 - frx1), imH * (fry2 - fry1));
                ctx.scale(panel.ratio, panel.ratio);
                panel.renderScale();
                panel.ThrottledFinishZoomPan();
            }
        };

        /**
         * Draws a selection rectangle
         * @param {x,y} firstPoint - top left corner
         * @param {x,y}secondPoint - bottom right corner
         * @private
         */
        panel._drawSelRect = function (firstPoint, secondPoint) {
            var selCanvas = panel.getCanvasElement('selection');
            var ctx = selCanvas.getContext("2d");
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            ctx.scale(panel.ratio, panel.ratio);
            //ctx.fillStyle="rgb(255,255,255)";
            //ctx.fillRect(0, 0, panel._cnvWidth,panel._cnvHeight);
            ctx.clearRect(0, 0, panel._cnvWidth, panel._cnvHeight);
            ctx.fillStyle = 'rgba(255,0,0,0.1)';
            ctx.strokeStyle = 'rgba(255,0,0,0.5)';
            if (firstPoint && secondPoint) {
                if (panel.selectXDirOnly) {
                    firstPoint.y = 0;
                    secondPoint.y = panel._cnvHeight;
                }
                ctx.beginPath();
                ctx.moveTo(firstPoint.x, firstPoint.y);
                ctx.lineTo(firstPoint.x, secondPoint.y);
                ctx.lineTo(secondPoint.x, secondPoint.y);
                ctx.lineTo(secondPoint.x, firstPoint.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        };

        /**
         * Handles a zoom action
         * @param {float} scaleFactor - zoom factor
         * @param {float} px - center x position
         * @param {float} py - center y position
         * @private
         */
        panel._handleZoom = function (scaleFactor, px, py) {
            var centerFracX = (px - panel.scaleMarginX) * 1.0 / (panel.drawSizeX - panel.scaleMarginX);
            var centerFracY = (panel.drawSizeY - panel.scaleMarginY - py) / (panel.drawSizeY - panel.scaleMarginY);
            var newXScaler = panel.xScaler;
            if (panel.canZoomX(scaleFactor)) {
                newXScaler = Scaler(panel.xScaler);
                newXScaler.zoom(scaleFactor, centerFracX);
            }
            var newYScaler = panel.yScaler;
            if (panel.canZoomY(scaleFactor)) {
                newYScaler = Scaler(panel.yScaler);
                newYScaler.zoom(scaleFactor, centerFracY);
            }
            panel._setNewScalers(newXScaler, newYScaler);
        };

        /**
         * Handles the mouse scrolled event
         * @param {{}} params - mouse scroll parameters
         * @private
         */
        panel._handleScrolled = function (params) {
            var delta = params.deltaY;
            if (delta != 0 && !panel._selectionMode) {
                if (delta < 0) //zoom out
                    var scaleFactor = 1.0 / (1.0 + 0.4 * Math.abs(delta));else //zoom in
                    var scaleFactor = 1.0 + 0.4 * Math.abs(delta);
                var px = panel.getEventPosX(params.event);
                var py = panel.getEventPosY(params.event);
                panel._handleZoom(scaleFactor, px, py);
            }
        };

        /**
         * Initialises a panning action (initiated by a mouse button down event)
         * @param params
         * @private
         */
        panel._panningStart = function (params) {
            panel.bubbleMessage("Activated");
            panel._hideToolTip();
            panel._isRectSelecting = params.shiftPressed || panel._selectionMode;
            if (panel._isRectSelecting) {
                panel._rectSelectPoint1 = {
                    x: panel.getEventPosX(params.event),
                    y: panel.getEventPosY(params.event)
                };
                panel._rectSelectPoint2 = null;
            }
            panel._isPanning = !params.shiftPressed;
            if (panel._isPanning) {
                panel._hasPanned = false;
                panel._panning_x0 = 0;
                panel._panning_y0 = 0;
                panel.origXScaler = Scaler(panel.xScaler);
                panel.origYScaler = Scaler(panel.yScaler);
            }
        };

        /**
         * Handles a panning change action (initiated by a mouse drag event)
         * @param dragInfo
         * @private
         */
        panel._panningDo = function (dragInfo) {
            if (panel._isRectSelecting) {
                panel._rectSelectPoint2 = {
                    x: panel.getEventPosX(dragInfo.event),
                    y: panel.getEventPosY(dragInfo.event)
                };
                panel._drawSelRect(panel._rectSelectPoint1, panel._rectSelectPoint2);
            }
            if (panel._isPanning) {
                if (Math.abs(dragInfo.diffTotalX) + Math.abs(dragInfo.diffTotalY) > 10) panel._hasPanned = true;
                if (panel._hasPanned) {
                    var imW = panel.drawSizeX - panel.scaleMarginX;
                    var imH = panel.drawSizeY - panel.scaleMarginY;
                    var newXScaler = Scaler(panel.xScaler);newXScaler.panFraction(-(dragInfo.diffTotalX - panel._panning_x0) / imW);
                    var newYScaler = Scaler(panel.yScaler);newYScaler.panFraction((dragInfo.diffTotalY - panel._panning_y0) / imH);
                    panel._panning_x0 = dragInfo.diffTotalX;
                    panel._panning_y0 = dragInfo.diffTotalY;
                    panel._setNewScalers(newXScaler, newYScaler);
                }
            }
        };

        /**
         * Handles a panning stop action (initiated by a mouse button up event)
         * @private
         */
        panel._panningStop = function () {
            if (panel._isRectSelecting) {
                if (panel._rectSelectPoint2) {
                    if (panel._autoRemoveSelection) panel._drawSelRect(null, null);
                    if (panel.handleRectSelection) panel.handleRectSelection(panel._rectSelectPoint1, panel._rectSelectPoint2);
                    setTimeout(function () {
                        // some delay to avoid the click handler to kick in
                        panel._isRectSelecting = false;
                    }, 100);
                }
            }
            if (panel._isPanning) {
                panel._isPanning = false;
                if (panel._hasPanned) {
                    setTimeout(function () {
                        // some delay to avoid the click handler to kick in
                        panel._hasPanned = false;
                    }, 100);
                    panel.finishZoomPan();
                }
            }
        };

        panel.removeSelection = function () {
            panel._drawSelRect(null, null);
        };

        /**
         * Html mouse move event handler
         * @param ev
         * @private
         */
        panel._onMouseMove = function (ev) {
            if (panel._lassoSelecting) return;
            if (panel._isRectSelecting) return;
            if (panel._isPanning) return;
            var px = panel.getEventPosX(ev);
            var py = panel.getEventPosY(ev);
            var newToolTipInfo = panel.getToolTipInfo(px, py);
            var showPointer = false;
            if (newToolTipInfo && !_AXM_HasTransientPopups()) {
                if (newToolTipInfo.showPointer) showPointer = true;
                if (panel._toolTipInfo.ID != newToolTipInfo.ID) panel._showToolTip(newToolTipInfo);
            } else panel._hideToolTip();
            var pointerType = showPointer ? "pointer" : "auto";
            if (panel._selectionMode && !showPointer) pointerType = "crosshair";
            panel.getCanvas$El('main').css('cursor', pointerType);
            panel.getCanvas$El('selection').css('cursor', pointerType);
        };

        /**
         * Html mouse click event handler
         * @param ev
         * @private
         */
        panel._onClick = function (ev) {
            if (panel._lassoSelecting) return;
            if (panel._isRectSelecting) return;
            if (panel._hasPanned) return;
            panel._hideToolTip();
            panel.onMouseClick(ev, {
                x: panel.getEventPosX(ev),
                y: panel.getEventPosY(ev),
                pageX: ev.pageX,
                pageY: ev.pageY
            });
        };

        panel.isLassoSelecting = function () {
            return panel._lassoSelecting;
        };

        panel.doLassoSelection = function (onCompleted) {
            if (panel._lassoSelecting) return;
            panel._lassoSelecting = true;

            var selPts = [];
            var clickLayer$El = panel.getCanvas$El('selection');

            var drawSelArea = function drawSelArea(tempPt) {
                var selCanvas = panel.getCanvasElement('selection');
                var ctx = selCanvas.getContext("2d");
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, selCanvas.width, selCanvas.height);
                ctx.fillStyle = 'rgba(255,0,0,0.1)';
                ctx.strokeStyle = 'rgba(255,0,0,0.5)';
                ctx.scale(panel.ratio, panel.ratio);
                ctx.beginPath();
                $.each(selPts, function (idx, pt) {
                    if (idx == 0) ctx.moveTo(pt.x, pt.y);else ctx.lineTo(pt.x, pt.y);
                });
                if (tempPt && selPts.length > 0) ctx.lineTo(tempPt.x, tempPt.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            };

            var end = function end() {
                clickLayer$El.unbind("click.FrameCanvasLasso");
                clickLayer$El.unbind("dblclick.FrameCanvasLasso");
                $(document).unbind("mousemove.FrameCanvasLasso");
                selPts = [];
                drawSelArea();
                clickLayer$El.css('cursor', 'auto');
                panel._lassoSelecting = false;
            };

            var lassoEventListener_click = function lassoEventListener_click(ev) {
                var px = panel.getEventPosX(ev);
                var py = panel.getEventPosY(ev);
                if (selPts.length == 0 || px != selPts[selPts.length - 1].x || py != selPts[selPts.length - 1].y) selPts.push({ x: px, y: py });
                drawSelArea();
            };

            var lassoEventListener_dblclick = function lassoEventListener_dblclick() {
                var selectedPoints = selPts;
                end();
                onCompleted(selectedPoints);
            };

            var lassoEventListener_mousemove = function lassoEventListener_mousemove(ev) {
                var px = panel.getEventPosX(ev);
                var py = panel.getEventPosY(ev);
                drawSelArea({ x: px, y: py });
            };

            if (!panel._lassoSelecting) {
                // end the lasso selection
                end();
            } else {
                // start the lasso selection
                clickLayer$El.bind("click.FrameCanvasLasso", lassoEventListener_click);
                clickLayer$El.bind("dblclick.FrameCanvasLasso", lassoEventListener_dblclick);
                $(document).bind("mousemove.FrameCanvasLasso", lassoEventListener_mousemove);
                clickLayer$El.css('cursor', 'crosshair');
            }
        };

        var _super_attachEventHandlers = panel.attachEventHandlers;
        /**
         * Attached the html event handlers after DOM insertion
         */
        panel.attachEventHandlers = function () {
            _super_attachEventHandlers();
            var clickLayer$El = panel.getCanvas$El('selection');
            AXMUtils.create$ElScrollHandler(clickLayer$El, panel._handleScrolled);
            AXMUtils.create$ElDragHandler(clickLayer$El, panel._panningStart, panel._panningDo, panel._panningStop);
            clickLayer$El.mousemove(panel._onMouseMove);
            clickLayer$El.click(panel._onClick);
            clickLayer$El.mouseleave(panel._hideToolTip);
        };

        var _super_detachEventHandlers = panel.detachEventHandlers;
        /**
         * Detach the html event handlers
         */
        panel.detachEventHandlers = function () {
            _super_detachEventHandlers();
            var clickLayer$El = panel.getCanvas$El('selection');
            AXMUtils.remove$ElScrollHandler(clickLayer$El);
            AXMUtils.remove$ElDragHandler(clickLayer$El);
            clickLayer$El.unbind('mousemove');
            clickLayer$El.unbind('click');
            clickLayer$El.unbind('mouseleave');
        };

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils) {

    var Module = {};

    /**
     * Estimates the parameters of a normal distribution from a set of observations
     * @param {number[]} values - list of observations
     * @returns {Object} - Normal df class instance
     * @constructor
     */
    Module.NormDfEstimator = function (values) {

        /**
         * Object instance
         * @type {{
         *      values: number[],
         *      average: number,
         *      stdev: number,
         *      getSortedValues: function,
         *      calcParametric: function,
         *      getCount: function,
         *      getMean: function,
         *      getStdev: function,
         *      getMedian: function,
         *      getMinimum: function,
         *      getMaximum: function,
         *      getPercentile: function
         * }}
         */
        var that = {};
        that.values = values;
        that.sortedValues = null;

        /**
         * Returns values sorted
         */
        that.getSortedValues = function () {
            if (!that.sortedValues) {
                that.sortedValues = that.values.slice();
                that.sortedValues = that.sortedValues.sort(function (a, b) {
                    return a - b;
                });
            }
            return that.sortedValues;
        };

        /**
         * Parametric estimation of average and standard deviation
         */
        that.calcParametric = function () {
            if (values.length === 0) return;
            var sum = 0;
            var i;
            for (i = 0; i < values.length; i += 1) {
                sum += values[i];
            }var average = sum / values.length;
            that.average = average;

            var stdev = 0;
            for (i = 0; i < values.length; i += 1) {
                stdev += Math.pow(values[i] - average, 2.0);
            }stdev = Math.sqrt(stdev / values.length);
            that.stdev = stdev;
        };

        /**
         * Returns number of values
         * @returns {number}
         */
        that.getCount = function () {
            return values.length;
        };

        /**
         * Returns distribution average
         * @returns {number}
         */
        that.getMean = function () {
            return that.average;
        };

        /**
         * Returns distribution standard deviation
         * @returns {number}
         */
        that.getStdev = function () {
            return that.stdev;
        };

        /**
         * Returns distribution median
         * @returns {number}
         */
        that.getMedian = function () {
            var sortedValues = that.getSortedValues();
            var half = Math.floor(sortedValues.length / 2);
            if (sortedValues.length % 2) return sortedValues[half];else return (sortedValues[half - 1] + sortedValues[half]) / 2.0;
        };

        /**
         * Returns distribution minimum
         * @returns {number}
         */
        that.getMinimum = function () {
            return that.getSortedValues()[0];
        };

        /**
         * Returns distribution maximum
         * @returns {number}
         */
        that.getMaximum = function () {
            return that.getSortedValues()[that.getCount() - 1];
        };

        /**
         * Get the percentile value for a given percentile in the sorted list
         * @param {number} p - percentile
         * @returns {number}
         */
        that.getPercentile = function (p) {
            if (p < 0 || p > 1.0) {
                AXMUtils.Test.reportBug("p is not a percentile: " + p);
            }
            return that.getSortedValues()[Math.round(that.getCount() * p)];
        };

        return that;
    };

    /**
     * Selects rows from the passed lists that contain valid floating point values and omits
     * null or NaN values. Does not test for strings.
     * @param {number[]} dataX: list of floats
     * @param {number[]} dataY: list of floats
     * @returns {*[]}: array of 2 elements: sublist of dataX, sublist of dataY.
     */
    Module._selectValidValues = function (dataX, dataY) {
        var valuesX = [];
        var valuesY = [];
        for (var rowNr = 0; rowNr < dataX.length; rowNr++) {
            var valX = dataX[rowNr];
            var valY = dataY[rowNr];
            if (valX !== null && !isNaN(valX) && valY !== null && !isNaN(valY)) {
                valuesX.push(valX);
                valuesY.push(valY);
            }
        }
        return [valuesX, valuesY];
    };

    /**
     * Calculates the pearson correlation coefficient for a set of data points.
     * @param {number[]} dataX - list of floats
     * @param {number[]} dataY - list of floats
     * @returns {number} - correlation coefficient or NaN if unable to calculate
     */
    Module.correlationCoefficient = function (dataX, dataY) {
        var correlation = Number.NaN;
        var dataXY = Module._selectValidValues(dataX, dataY);
        var valuesX = dataXY[0];
        var valuesY = dataXY[1];

        if (valuesX.length > 1) {
            var dfX = Module.NormDfEstimator(valuesX);
            dfX.calcParametric();
            var dfY = Module.NormDfEstimator(valuesY);
            dfY.calcParametric();
            var covariance = 0;
            for (var rowNr = 0; rowNr < dfX.getCount(); rowNr++) {
                covariance += (valuesX[rowNr] - dfX.getMean()) * (valuesY[rowNr] - dfY.getMean());
            }
            covariance = covariance / dfX.getCount();
            correlation = covariance / (dfX.getStdev() * dfY.getStdev());
        }

        return correlation;
    };

    /**
     * Calculates slope and intercept of linear fit through a set of data points.
     * @param {number[]} dataX - list of floats
     * @param {number[]} dataY - list of floats
     * @returns {[]} - [slope, intercept] or [NaN, NaN] if not able to calculate
     */
    Module.slopeIntercept = function (dataX, dataY) {
        var slope = Number.NaN;
        var intercept = Number.NaN;
        var correlation = Module.correlationCoefficient(dataX, dataY);
        if (!isNaN(correlation)) {
            var dataXY = Module._selectValidValues(dataX, dataY);
            var valuesX = dataXY[0];
            var valuesY = dataXY[1];

            if (valuesX.length > 1) {
                var dfX = Module.NormDfEstimator(valuesX);
                dfX.calcParametric();
                var dfY = Module.NormDfEstimator(valuesY);
                dfY.calcParametric();
                if (dfX.getStdev() != 0) {
                    slope = correlation * dfY.getStdev() / dfX.getStdev();
                    intercept = dfY.getMean() - slope * dfX.getMean();
                }
            }
        }
        return [slope, intercept];
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(7), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Msg, Frame) {

    /**
     * Module encapsulating the functionality for the one and only Axiom window that represents the full web app client area
     * @type {{}}
     */
    var Module = {};

    /**
     * Creates the root window
     * @param {AXM.Panels.Frame} iFrameRoot - root frame to be placed in the root window
     * @returns {{}} - root window object
     * @constructor
     */
    Module.create = function (iFrameRoot) {
        var rootWindow = {};
        rootWindow._rootFrame = iFrameRoot;

        rootWindow.render = function () {
            var st = rootWindow._rootFrame.createHtml();
            $('.AXMContainer').html(st);
            rootWindow._rootFrame.attachEventHandlers();
            rootWindow._monitorResize();
        };

        rootWindow._prevSizeX = 0;
        rootWindow._prevSizeY = 0;
        rootWindow._monitorResize = function () {
            var myparent = $('#' + rootWindow._rootFrame.getId()).parent();
            var sizeX = myparent.innerWidth();
            var sizeY = myparent.innerHeight();
            if (sizeX != rootWindow._prevSizeX || sizeY != rootWindow._prevSizeY) {
                rootWindow._doResize(sizeX, sizeY, {});
                rootWindow._prevSizeX = sizeX;
                rootWindow._prevSizeY = sizeY;
                Msg.broadcast('MsgBrowserResized', { sizeX: sizeX, sizeY: sizeY });
            }
            setTimeout(rootWindow._monitorResize, 100);
        };

        rootWindow.forceResize = function () {
            var myparent = $('#' + rootWindow._rootFrame.getId()).parent();
            var sizeX = myparent.innerWidth();
            var sizeY = myparent.innerHeight();
            rootWindow._doResize(sizeX, sizeY, {});
            rootWindow._prevSizeX = sizeX;
            rootWindow._prevSizeY = sizeY;
            Msg.broadcast('MsgBrowserResized', { sizeX: sizeX, sizeY: sizeY });
        };

        rootWindow._doResize = function (sizeX, sizeY, params) {
            //var myparent = $('#' + rootWindow._rootFrame.getId()).parent();
            //var sizeX = myparent.innerWidth();
            //var sizeY = myparent.innerHeight();
            rootWindow._rootFrame.setPosition(0, 0, sizeX, sizeY, params);
        };

        return rootWindow;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(7), __webpack_require__(4), __webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Msg, DOM, Icon) {

    /**
     * Module encapsulating a class that creates a transient popup window in the web application's client area that is automatically closed when the user clicks outside of it
     * @type {{}}
     */
    var Module = {};

    Module._current = null;

    /**
     * Creates a transient popup window
     * @param {{}} settings
     * @param {{}} settings.event - (optional) mouse click event that created this popup
     * @param {{}} settings.point - (optional) {x, y} pointer position of the transient popup
     * @param {{}} settings.DOM$Elem - (optional) jQuery DOM element where the popup should appear on
     * @returns {{}} - popup window instance
     */
    Module.create = function (settings) {
        if (!settings.doNotCloseOthers) {
            AXMUtils.closeTransientPopups();
        }
        var window = { _id: AXMUtils.getUniqueID() };
        window.zIndex = AXMUtils.getNextZIndex();
        window._tearDownHanders = []; //List of functions that will be called when the window is about to be removed

        window.offsetX = 30;
        window.offsetY = 30;
        var processed = false;
        if (settings.event) {
            processed = true;
            window.offsetX = settings.event.pageX;
            window.offsetY = settings.event.pageY;
        }
        if (settings.point) {
            processed = true;
            window.offsetX = settings.point.x;
            window.offsetY = settings.point.y;
        }
        if (settings.DOM$Elem) {
            processed = true;
            var elemW = settings.DOM$Elem.width();
            var elemH = settings.DOM$Elem.height();
            window.offsetX = settings.DOM$Elem.offset().left + elemW / 2;
            window.offsetY = settings.DOM$Elem.offset().top + elemH - 5;
        }

        if (!processed) AXMUtils.Test.reportBug("No anchor data provided for transient popup");

        /**
         * Defines the root control to be displayed in the popup
         * @param iControl
         */
        window.setRootControl = function (iControl) {
            window._rootControl = iControl;
        };

        /**
         * Adds a new function that will be called when the window is about to be removed
         * @param func
         */
        window.addTearDownHandler = function (func) {
            window._tearDownHanders.push(func);
        };

        /**
         * Starts the popup, making it visible in the application
         */
        window.start = function () {

            var rootDiv = DOM.Div({ id: window._id });
            rootDiv.addStyle('z-index', window.zIndex);
            //rootDiv.addStyle('top', window.offsetY + "px");
            //rootDiv.addStyle('left', window.offsetX + "px");
            rootDiv.addCssClass('AXMTransientContainer');

            var browserSize = AXMUtils.getBrowserSize();

            var divClient = DOM.Div({ parent: rootDiv }).addCssClass('AXMTransientClient');
            if (window._rootControl) divClient.addElem(window._rootControl.createHtml());

            var arrow = DOM.Div({ parent: rootDiv });
            arrow.addCssClass('AXMTransientContainerArrow');
            arrow.addCssClass('AXMTransientContainerArrowTop');

            divClient.addElem('<span class="SWXTransientCloseBox"><i class="fa fa-times-circle"></i></span>');

            $('.AXMContainer').append(rootDiv.toString());
            window._$ElContainer = $('#' + window._id);

            if (window._rootControl) window._rootControl.attachEventHandlers();

            var windowSizeX = window._$ElContainer.width();
            var windowSizeY = settings.maxHeight ? Math.max(window._$ElContainer.height(), settings.maxHeight) : window._$ElContainer.height();

            if (window.offsetX + windowSizeX < browserSize.sizeX) {
                window._$ElContainer.css('left', window.offsetX - 26);
                window._$ElContainer.find(".AXMTransientContainerArrow").css("left", 16);
            } else {
                var leftX = browserSize.sizeX - windowSizeX - 20;
                window._$ElContainer.css('left', leftX);
                window._$ElContainer.find(".AXMTransientContainerArrow").css("left", window.offsetX - leftX - 10);
            }
            if (window._$ElContainer.outerWidth() + Math.max(window._$ElContainer.position().left, 0) >= browserSize.sizeX) {
                var leftX = 0;
                window._$ElContainer.css('left', leftX);
                window._$ElContainer.css('width', browserSize.sizeX);
                // take into account 2*15 px padding
                window._$ElContainer.find(".AXMTransientClient").css('width', browserSize.sizeX - 30);
                window._$ElContainer.find(".AXMTransientClient").css('overflow-x', "scroll");
                window._$ElContainer.find(".AXMTransientContainerArrow").css("left", window.offsetX - leftX - 10);
            }

            var bottomSpace = browserSize.sizeY - 14 - window.offsetY - windowSizeY;
            var topSpace = window.offsetY - windowSizeY - 14;
            if (bottomSpace >= 0 || topSpace >= 0) {
                if (window.offsetY + windowSizeY < browserSize.sizeY - 10) {
                    window._$ElContainer.css('top', window.offsetY + 14);
                } else {
                    window._$ElContainer.css('top', window.offsetY - windowSizeY - 14);
                    window._$ElContainer.find(".AXMTransientContainerArrow").removeClass("AXMTransientContainerArrowTop").addClass("AXMTransientContainerArrowBottom");
                }
            } else {
                // Transient popup does not fit in current browser window

                if (bottomSpace >= topSpace) {
                    window._$ElContainer.css('top', window.offsetY + 14);
                    window._$ElContainer.css('height', browserSize.sizeY - 14 - window.offsetY);
                    // take into account 2*15 px padding
                    window._$ElContainer.find(".AXMTransientClient").css('height', browserSize.sizeY - 14 - window.offsetY - 30);
                } else {
                    window._$ElContainer.css('top', 0);
                    window._$ElContainer.css('height', window.offsetY - 14);
                    // take into account 2*15 px padding
                    window._$ElContainer.find(".AXMTransientClient").css('height', window.offsetY - 14 - 30);
                    window._$ElContainer.find(".AXMTransientContainerArrow").removeClass("AXMTransientContainerArrowTop").addClass("AXMTransientContainerArrowBottom");
                }
                // Add space for scroll bar
                window._$ElContainer.find('.SWXTransientCloseBox').css('right', 12);
                window._$ElContainer.find(".AXMTransientClient").css('overflow-y', "scroll");
            }

            window._$ElContainer.find('.SWXTransientCloseBox').click(function () {
                window.close();
            });

            setTimeout(function () {
                $(document).bind("mouseup.transientpopup", window._onDocClicked);
            }, 50);
        };

        window._onDocClicked = function (ev) {
            if (ev.target) {
                var clicked$El = $(ev.target);
                if (clicked$El.length < 1) return;
                if (window._$ElContainer[0] != clicked$El[0] && !$.contains(window._$ElContainer[0], clicked$El[0])) {
                    window.close();
                }
            }
        };

        window.close = function () {
            $.each(window._tearDownHanders, function (idx, handler) {
                handler();
            });
            window._tearDownHanders = [];
            if (window._rootControl) window._rootControl.detachEventHandlers();
            window._$ElContainer.remove();
            $(document).unbind("mouseup.transientpopup");
            Module._current = null;
        };

        Module._current = window;
        return window;
    };

    Msg.listen(null, "CloseTransientPopups", function () {
        if (Module._current) Module._current.close();
    });

    Msg.listen(null, "CloseRegularTransientPopups", function () {
        if (Module._current) Module._current.close();
    });

    _AXM_HasTransientPopups = function _AXM_HasTransientPopups() {
        return Module._current;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(7), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, Msg, Test) {

    var Module = {};

    var ranseed = 0;
    var random = function random() {
        ranseed = (ranseed * 9301 + 49297) % 233280;
        return ranseed / 233280.0;
    };

    var alphabet = 'abcdefghijklmnopqrstuvwxyz      ';
    var alphabetlen = alphabet.length;

    var randomString = function randomString(avLen) {
        var st = '';
        var len = Math.round(avLen * (1 + 0.5 * random()));
        for (var i = 0; i < len; i++) {
            st += alphabet[Math.floor(alphabetlen * random())];
        }
        return st;
    };

    Module.create = function (id, primKey) {
        var tableData = AXMUtils.object('@TableData');
        tableData._id = id;
        tableData._primKey = primKey;

        tableData._sortCol = null;
        tableData._sortInverse = true;

        tableData.getId = function () {
            return tableData._id;
        };

        tableData._toggleSortByField = function (colId) {
            if (colId != tableData._sortCol) {
                tableData._sortCol = colId;
                tableData._sortInverse = false;
            } else {
                tableData._sortInverse = !tableData._sortInverse;
            }
            tableData.resetBuffer();
        };

        tableData._sortByField = function (colId, inverse) {
            tableData._sortCol = colId;
            tableData._sortInverse = !!inverse;
            tableData.resetBuffer();
        };

        tableData.getPrimKey = function () {
            return tableData._primKey;
        };

        tableData.getSortColumn = function () {
            return tableData._sortCol;
        };

        tableData.getSortInverse = function () {
            return tableData._sortInverse;
        };

        tableData.resetBuffer = function () {
            Test.reportBug('Not implemented');
        };

        tableData.getRowCount = function () {
            Test.reportBug('Not implemented');
        };

        tableData.getRow = function (rowNr) {
            Test.reportBug('Not implemented');
        };

        tableData.requireRowRange = function (rowFirst, rowLast, onAvailable) {
            Test.reportBug('Not implemented');
        };

        // Item selection functionality

        tableData._selectedItemsMap = {};
        tableData._selectedCount = 0;

        tableData.setItemSelected = function (itemId, state) {
            if (state == tableData.isItemSelected(itemId)) return;
            tableData._selectedCount += state ? +1 : -1;
            tableData._selectedItemsMap[itemId] = state;
        };

        tableData.isItemSelected = function (itemId) {
            return !!tableData._selectedItemsMap[itemId];
        };

        tableData.getSelectedItemCount = function () {
            return tableData._selectedCount;
        };

        tableData.getSelectedItemList = function () {
            var lst = [];
            $.each(tableData._selectedItemsMap, function (id, status) {
                if (status) lst.push(id);
            });
            return lst;
        };

        tableData.notifySelectionModified = function () {
            Msg.broadcast('TableSelectionModified', tableData.getId());
        };

        tableData.clearSelection = function () {
            tableData._selectedItemsMap = {};
            tableData._selectedCount = 0;
            tableData.notifySelectionModified();
        };

        tableData.selectAll = function () {
            var _maxDownloadRowCount = 9999;

            var _exec_Select = function _exec_Select() {
                tableData._selectedItemsMap = {};
                tableData._selectedCount = 0;

                var cnt = Math.min(_maxDownloadRowCount, tableData.getRowCount());
                for (var rowNr = 0; rowNr < cnt; rowNr++) {
                    var rowData = tableData.getRow(rowNr);
                    tableData.setItemSelected(rowData[tableData._primKey], true);
                }

                tableData.notifySelectionModified();
            };

            if (tableData.requireRowRange(0, _maxDownloadRowCount, _exec_Select)) _exec_Select();
        };

        return tableData;
    };

    Module.DummyData = function (rowCount, iranseed) {
        ranseed = iranseed;
        var tableData = Module.create();
        tableData._cols = [];

        tableData.addTextCol = function (id, len) {
            tableData._cols.push({ tpe: 'text', id: id, len: len });
        };

        tableData.addIntCol = function (id, minv, maxv) {
            tableData._cols.push({ tpe: 'int', id: id, minv: minv, maxv: maxv });
        };

        tableData.addFloatCol = function (id, minv, maxv) {
            tableData._cols.push({ tpe: 'float', id: id, minv: minv, maxv: maxv });
        };

        tableData.requireRowRange = function () {
            return true;
        };

        tableData.getRow = function (rowNr) {
            if (rowNr < 0 || rowNr >= rowCount) AXMUtils.reportBug('Invalid row number');
            ranseed = iranseed + rowNr;
            var rowInfo = {
                index: rowNr + 1
            };
            $.each(tableData._cols, function (colNr, colInfo) {
                if (colInfo.tpe == 'text') rowInfo[colInfo.id] = randomString(colInfo.len);
                if (colInfo.tpe == 'int') rowInfo[colInfo.id] = Math.round(colInfo.minv + random() * (colInfo.maxv - colInfo.minv));
                if (colInfo.tpe == 'float') rowInfo[colInfo.id] = colInfo.minv + random() * (colInfo.maxv - colInfo.minv);
            });
            return rowInfo;
        };

        tableData.getRowCount = function () {
            return rowCount;
        };

        return tableData;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(19), __webpack_require__(20), __webpack_require__(2), __webpack_require__(4), __webpack_require__(3), __webpack_require__(10), __webpack_require__(13), __webpack_require__(7), __webpack_require__(14), __webpack_require__(5), __webpack_require__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Blob, FileSaver, AXMUtils, DOM, Controls, Frame, PanelBase, Msg, Icon, SimplePopups, TableInfo) {

    /**
     * Module encapsulating a panel that contains a paged table
     * @type {{}}
     */
    var Module = {};

    /**
     * Implements a panel that contains a paged table
     * @param {string} id - panel type id
     * @param {AXM.Tables.TableData} tableData - object containing the data of the table (content of the cells)
     * @param {AXM.Tables.TableInfo} tableInfo - object containing the definition of the table (column definitions)
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.create = function (id, tableData, tableInfo) {
        var panel = PanelBase.create(id);
        AXMUtils.Test.checkIsType(tableData, '@TableData');
        AXMUtils.Test.checkIsType(tableInfo, '@TableInfo');

        panel._tableData = tableData;
        panel._tableInfo = tableInfo;

        panel._tableLineCount = 20;
        panel._tableOffset = 0;
        panel._currentRowNr = 0;
        panel._lastSelClickedRowNr = null;

        panel._columns = [];

        panel._accumulatedScrollLineDiff = 0;
        panel._storeLayout = true;

        /**
         * Defines whether or not the user-adjusted layout should be stored
         * @param {boolean} newValue
         */
        panel.setStoreLayout = function (newValue) {
            panel._storeLayout = newValue;
        };

        /**
         * To be called to reflect changes in the table info
         */
        panel.updateTableInfo = function () {

            panel._columns = [];

            if (tableInfo.canOpenRow()) {
                var openerCol = TableInfo.colInfo('_opener_');
                openerCol.isOpener = true;
                openerCol._dispSize = 25;
                openerCol.setName('');
                panel._columns.push(openerCol);
            }

            if (tableInfo.canSelect()) {
                var selectorCol = TableInfo.colInfo('_selector_');
                selectorCol.isSelector = true;
                selectorCol._dispSize = 25;
                selectorCol.setName('');
                panel._columns.push(selectorCol);
            }

            $.each(tableInfo.getColumns(), function (idx, col) {
                if (col.isVisibleInTable()) panel._columns.push(col);
            });
        };
        panel.updateTableInfo();

        panel._colIsRightPart = function (colInfo) {
            return !colInfo.isOpener && !colInfo.isSelector;
        };

        panel._getSubId = function (ext) {
            return panel._id + '_' + ext;
        };

        panel._getSub$El = function (ext) {
            return $('#' + panel._getSubId(ext));
        };

        panel._getColSubId = function (colNr, ext) {
            return panel._id + '_col_' + colNr + '_' + ext;
        };

        panel._getColSub$El = function (colNr, ext) {
            return $('#' + panel._getColSubId(colNr, ext));
        };

        /**
         * Returns the html implementing the panel
         * @returns {string}
         */
        panel.createHtml = function () {

            panel._divid_leftHeadRow = panel._getSubId('leftheadrow');
            panel._divid_leftBody = panel._getSubId('leftbody');
            panel._divid_rightHeadRow = panel._getSubId('rightheadrow');
            panel._divid_rightBody = panel._getSubId('rightbody');

            var divRoot = DOM.Div({ id: 'tb' + panel._id }).addStyle('width', '100%').addStyle('height', '100%').addStyle('overflow-x', 'hidden').addStyle('overflow-y', 'hidden').addStyle('white-space', 'nowrap');

            divRoot.addElem(panel.createHtmlBody());

            return divRoot.toString();
        };

        /**
         * Returns the html implementing the table body
         * @returns {string}
         */
        panel.createHtmlBody = function () {
            panel._loadColumnSettings();

            var divLeftTableContainer = DOM.Div({ id: panel._getSubId('leftTableScrollContainer') }).addStyle('height', '100%').addStyle('display', 'inline-block').addStyle('background-color', 'rgb(247,247,247)');

            var divRightTableContainer = DOM.Div({ id: panel._getSubId('rightTableScrollContainer') }).addStyle('height', '100%').addStyle('overflow-x', 'scroll').addStyle('overflow-y', 'hidden').addStyle('display', 'inline-block').addStyle('background-color', 'rgb(247,247,247)');

            ///////////// Left table ////////////////////////////////

            var divLeftTable = DOM.Create('table', { parent: divLeftTableContainer }).addCssClass('AXMPgTableLeft');
            var colLeftGroup = DOM.Create('colgroup', { parent: divLeftTable });
            var divLeftTableHead = DOM.Create('thead', { parent: divLeftTable });
            var divLeftTableHeadRow = DOM.Create('tr', { parent: divLeftTableHead, id: panel._divid_leftHeadRow });
            var divLeftTableBody = DOM.Create('tbody', { parent: divLeftTable, id: panel._divid_leftBody });

            ///////////// Right table ///////////////////////////////

            var divRightTable = DOM.Create('table', { parent: divRightTableContainer }).addCssClass('AXMPgTableRight');
            var colRightGroup = DOM.Create('colgroup', { parent: divRightTable });
            var divRightTableHead = DOM.Create('thead', { parent: divRightTable });
            var divRightTableHeadRow = DOM.Create('tr', { parent: divRightTableHead, id: panel._divid_rightHeadRow });
            var divRightTableBody = DOM.Create('tbody', { parent: divRightTable, id: panel._divid_rightBody });

            $.each(panel._columns, function (colNr, colInfo) {
                var col = DOM.Create('col', {
                    parent: panel._colIsRightPart(colInfo) ? colRightGroup : colLeftGroup,
                    id: panel._getColSubId(colNr, '')
                }).addStyle('width', colInfo._dispSize + 'px').addStyle('overflow', 'hidden');
            });

            return divLeftTableContainer.toString() + divRightTableContainer.toString();
        };

        /**
         * Attached the html event handlers after DOM insertion
         */
        panel.attachEventHandlers = function () {
            var $ElLeftHeadRow = $('#' + panel._divid_leftHeadRow);
            var $ElRightHeadRow = $('#' + panel._divid_rightHeadRow);
            var $ElRightBody = $('#' + panel._divid_rightBody);
            var $ElLeftBody = $('#' + panel._divid_leftBody);

            var headerLeftHtml = '';
            var headerRightHtml = '';
            $.each(panel._columns, function (colNr, colInfo) {
                var cell = DOM.Create('th', { id: panel._getColSubId('header', colNr) });
                cell.addElem(colInfo.getName());
                cell.addAttribute('title', colInfo.getName());
                if (colInfo.canSort()) {
                    DOM.Div({ parent: cell }).addCssClass('AXMPgTableColSortBox');
                }
                if (colInfo.canOpen()) {
                    cell.addStyle('cursor', 'pointer');
                    DOM.Div({ parent: cell, id: panel._getColSubId('open', colNr) }).addCssClass('AXMPgTableColOpenBox').addElem('<i class="fa fa-external-link-square"></i>');
                }
                DOM.Div({ parent: cell, id: panel._getColSubId('dragger', colNr) }).addCssClass('AXMPgTableRightColDragger');
                if (panel._colIsRightPart(colInfo)) headerRightHtml += cell.toString();else headerLeftHtml += cell.toString();
            });
            $ElLeftHeadRow.html(headerLeftHtml);
            $ElRightHeadRow.html(headerRightHtml);

            $.each(panel._columns, function (colNr, colInfo) {
                var $ElColDrag = panel._getColSub$El('dragger', colNr);
                var $ElCol = panel._getColSub$El(colNr, '');
                var $ElColHeader = panel._getColSub$El('header', colNr);
                if (colInfo.canOpen()) $ElColHeader.mousedown(function (ev) {
                    colInfo.callOnOpen();
                    return false;
                });
                $ElColHeader.find('.AXMPgTableColSortBox').mousedown(function () {
                    panel._toggleSortByField(colInfo._id);
                });
                if (panel._colIsRightPart(colInfo)) {
                    var dispSizeStart = 0;
                    AXMUtils.create$ElDragHandler($ElColDrag, function () {
                        dispSizeStart = colInfo._dispSize;
                    }, function (params) {
                        colInfo._dispSize = Math.max(35, dispSizeStart + params.diffTotalX);
                        $ElCol.width(colInfo._dispSize);
                    }, function () {
                        panel._storeColumnSettings();
                    });
                }
            });

            $ElLeftBody.click(function (event) {
                panel._handleCellClicked($(event.target), {
                    shiftPressed: event.shiftKey,
                    controlPressed: event.ctrlKey
                });
            });
            $ElRightBody.click(function (event) {
                panel._handleCellClicked($(event.target), {
                    shiftPressed: event.shiftKey,
                    controlPressed: event.ctrlKey
                });
            });

            AXMUtils.create$ElScrollHandler(panel._getSub$El('leftTableScrollContainer'), panel._handleScrolled);
            AXMUtils.create$ElScrollHandler(panel._getSub$El('rightTableScrollContainer'), panel._handleScrolled);

            $('#' + panel._divid_rightBody).contextmenu(function (event) {
                //alert('contextmenu');
                event.stopPropagation();
                event.preventDefault();
                return false;
            });

            panel._updateSortStatus();
            panel.renderTableContent();
        };

        /**
         * Detach the html event handlers
         */
        panel.detachEventHandlers = function () {
            var $ElLeftHeadRow = $('#' + panel._divid_leftHeadRow);
            var $ElRightHeadRow = $('#' + panel._divid_rightHeadRow);
            var $ElRightBody = $('#' + panel._divid_rightBody);
            var $ElLeftBody = $('#' + panel._divid_leftBody);

            $.each(panel._columns, function (colNr, colInfo) {
                var $ElColDrag = panel._getColSub$El('dragger', colNr);
                var $ElCol = panel._getColSub$El(colNr, '');
                var $ElColHeader = panel._getColSub$El('header', colNr);
                if (colInfo.canOpen()) $ElColHeader.unbind('mousedown');
                $ElColHeader.find('.AXMPgTableColSortBox').unbind('mousedown');
                if (panel._colIsRightPart(colInfo)) {
                    AXMUtils.remove$ElDragHandler($ElColDrag);
                }
            });
            $ElLeftBody.unbind('click');
            $ElRightBody.unbind('click');

            AXMUtils.remove$ElScrollHandler(panel._getSub$El('leftTableScrollContainer'));
            AXMUtils.remove$ElScrollHandler(panel._getSub$El('rightTableScrollContainer'));

            $('#' + panel._divid_rightBody).unbind('contextmenu');

            panel._updateSortStatus();
            panel.renderTableContent();
        };

        /**
         * Returns the html code for a single cell content
         * @param {int} rowNr - row number
         * @param {int} colNr - column number
         * @param {{}} rowData - content of the row
         * @param {AXM.TableInfo.colInfo} colInfo - column information
         */
        panel.renderCell = function (rowNr, colNr, rowData, colInfo) {
            if (colInfo.isOpener) {
                var cell = '<div class="AXMPgTableLinkCell" title="{txt}">'.AXMInterpolate({ txt: _TRL('Open this item') });
                cell += '<div class="AXMPgTableLinkIcon"><i class="fa fa-external-link-square"></i></div>';
                cell += '<div style="display:inline-block;height:100%;width:1px;vertical-align:middle"/>';
                cell += '</div>';
                return cell;
            }
            if (colInfo.isSelector) {
                var rowId = rowData[panel._tableData.getPrimKey()];
                var cell = '<div class="AXMPgTableSelectorCell" title="{txt}">'.AXMInterpolate({ txt: _TRL('Select this item') });
                if (!panel._tableData.isItemSelected(rowId)) cell += '<div class="AXMPgTableSelectorIcon"><i class="fa fa-circle-thin"></i></div>';else cell += '<div class="AXMPgTableSelectorIconActive"><i class="fa fa-check-circle"></i></div>';
                cell += '<div style="display:inline-block;height:100%;width:1px;vertical-align:middle"/>';
                cell += '</div>';
                return cell;
            }
            if (colInfo.content2CellHtml) return colInfo.content2CellHtml(rowData[colInfo.getId()], rowData);
            return colInfo.content2DisplayString(rowData[colInfo.getId()], rowData);
        };

        panel._getRowLeftId = function (rowNr) {
            return 'rowleft_' + panel.getId() + '_' + rowNr;
        };

        panel._getRowRightId = function (rowNr) {
            return 'rowright_' + panel.getId() + '_' + rowNr;
        };

        /**
         * Returns the html code for a single row in the table
         * @param {int} rowNr - table row number
         * @returns {{left: string, right: string}}
         * @private
         */
        panel._renderTableRow = function (rowNr) {
            if (rowNr < 0) AXMUtils.Test.reportBug('Negative row number');
            if (rowNr >= panel._tableData.getRowCount()) AXMUtils.Test.reportBug('Row number {nr} outside count {count}'.AXMInterpolate({ nr: rowNr, count: panel._tableData.getRowCount() }));
            var rowLeftHtml = '<tr id="' + panel._getRowLeftId(rowNr) + '">';
            var rowRightHtml = '<tr id="' + panel._getRowRightId(rowNr) + '">';
            var rowData = panel._tableData.getRow(rowNr);
            if (!rowData) AXMUtils.Test.reportBug('Unable to get row data');
            $.each(panel._columns, function (colNr, colInfo) {
                var bkcolor = colInfo.content2BackgroundColor(rowData[colInfo.getId()], rowData);
                var fgcolor = colInfo.content2ForegroundColor(rowData[colInfo.getId()], rowData);
                var styles = '';
                if (bkcolor) styles += 'background-color:' + bkcolor.toString();
                if (fgcolor) styles += 'color:' + fgcolor.toString();
                var titleText = '';
                if (!colInfo.isOpener && !colInfo.isSelector) titleText = colInfo.content2DisplayString(rowData[colInfo.getId()], rowData);
                if (titleText.indexOf('<') >= 0) titleText = ""; // ugly hack because we don't want html content to be used in the tooltip
                var cell = '<td style="{styles}" id="tbcell_{id}" title="{titletext}">'.AXMInterpolate({
                    styles: styles,
                    id: panel.getId() + '_' + rowNr + '_' + colNr,
                    titletext: titleText
                }) + panel.renderCell(rowNr, colNr, rowData, colInfo) + '</td>';
                if (panel._colIsRightPart(colInfo)) rowRightHtml += cell;else rowLeftHtml += cell;
            });
            rowLeftHtml += '</tr>';
            rowRightHtml += '</tr>';
            return {
                left: rowLeftHtml,
                right: rowRightHtml
            };
        };

        /**
         * Sets the html code for the table pager control
         * @private
         */
        panel._renderPager = function () {
            var rowFirst = panel._tableOffset;
            var rowLast = Math.min(panel._tableRowCount - 1, panel._tableOffset + panel._tableLineCount - 1);
            panel._pagerInfo.modifyText('<span style="font-size:90%">Current: {start}-{stop}<br>Total: {total}</span>'.AXMInterpolate({
                start: rowFirst + 1,
                stop: rowLast + 1,
                total: panel._tableRowCount
            }));
        };

        /**
         * Sets the html code for the table content
         */
        panel.renderTableContent = function () {
            panel._tableRowCount = panel._tableData.getRowCount();
            var rowFirst = panel._tableOffset;
            var rowLast = Math.min(panel._tableRowCount - 1, panel._tableOffset + panel._tableLineCount - 1);

            if (!panel._tableData.requireRowRange(rowFirst, rowLast, panel.renderTableContent, panel.renderFail)) return;

            var $ElRightBody = $('#' + panel._divid_rightBody);
            var $ElLeftBody = $('#' + panel._divid_leftBody);
            var bodyLeftHtml = '';
            var bodyRightHtml = '';
            for (var rowNr = rowFirst; rowNr <= rowLast; rowNr++) {
                var rowHtml = panel._renderTableRow(rowNr);
                bodyLeftHtml += rowHtml.left;
                bodyRightHtml += rowHtml.right;
            }
            $ElLeftBody.html(bodyLeftHtml);
            $ElRightBody.html(bodyRightHtml);

            panel._renderHighlightRowNr();
            panel._renderPager();

            if (!panel._sizeMeasured) panel._measureSize();
        };

        /**
         * Renders an error message
         */
        panel.renderFail = function () {
            panel._pagerInfo.modifyText('<span style="color:red">Failed to load data</span>');
        };

        /**
         * Renders the highlight for the highlighted row
         * @private
         */
        panel._renderHighlightRowNr = function () {
            var $ElRightBody = $('#' + panel._divid_rightBody);
            var $ElLeftBody = $('#' + panel._divid_leftBody);
            $ElRightBody.find('tr').removeClass('AXMPgTableHightlightRow');
            $ElLeftBody.find('tr').removeClass('AXMPgTableHightlightRow');
            $("#" + panel._getRowLeftId(panel._currentRowNr)).addClass('AXMPgTableHightlightRow');
            $("#" + panel._getRowRightId(panel._currentRowNr)).addClass('AXMPgTableHightlightRow');
        };

        /**
         * Handles the clicking on an individual cell html element
         * @param {jquery} $El - clicked element
         * @param {{}} settings
         * @private
         */
        panel._handleCellClicked = function ($El, settings) {
            var cellInfo = panel._findTableCell$El($El);
            if (cellInfo) {
                panel._currentRowNr = cellInfo.rowNr;
                panel._renderHighlightRowNr();
                if (cellInfo.colNr != null) {
                    var colInfo = panel._columns[cellInfo.colNr];
                    if (colInfo.isOpener) panel._tableInfo.callOnOpenRow(cellInfo.rowNr, settings, panel._tableData);
                    if (colInfo.isSelector) panel._handleSelectorClicked(cellInfo.rowNr, settings);
                }
            }
        };

        /**
         * Handles the clicking on the icon maintaining the row selection state
         * @param {int} rowNr - table row number
         * @param {{}} settings
         * @private
         */
        panel._handleSelectorClicked = function (rowNr, settings) {
            var rowId = panel._tableData.getRowId(rowNr);
            if (rowId === null) return;
            var prevState = panel._tableData.isItemSelected(rowId);
            if (!settings.shiftPressed || panel._lastSelClickedRowNr == null) panel._tableData.setItemSelected(rowId, !prevState);else {
                for (var i = Math.min(rowNr, panel._lastSelClickedRowNr); i <= Math.max(rowNr, panel._lastSelClickedRowNr); i++) {
                    var t_rowId = panel._tableData.getRowId(i);
                    if (t_rowId !== null) panel._tableData.setItemSelected(t_rowId, !prevState);
                }
            }
            panel._lastSelClickedRowNr = rowNr;
            panel._tableData.notifySelectionModified();
        };

        /**
         * Updates the table pager offset
         * @private
         */
        panel._updateScrollLineDiff = function () {
            if (panel._accumulatedScrollLineDiff) {
                panel.navigateLineDiff(panel._accumulatedScrollLineDiff);
                panel._accumulatedScrollLineDiff = 0;
            }
        };

        /**
         * Handles the mouse scroll wheel event
         * @param params
         * @private
         */
        panel._handleScrolled = function (params) {
            if (params.deltaY < 0) panel._accumulatedScrollLineDiff += 3;
            if (params.deltaY > 0) panel._accumulatedScrollLineDiff -= 3;
            panel._updateScrollLineDiff();
        };

        /**
         * Handles the toggling of the sort state for an individuale column
         * @param {string} colId - column id
         * @private
         */
        panel._toggleSortByField = function (colId) {
            panel._tableData._toggleSortByField(colId);
            panel.resetView();
            panel._updateSortStatus();
        };

        /**
         * Updates the row sort status
         * @private
         */
        panel._updateSortStatus = function () {
            $.each(panel._columns, function (colNr, colInfo) {
                var $ElColHeader = panel._getColSub$El('header', colNr);
                if (colInfo.canSort()) {
                    var sortInv = false;
                    var sortBox = $ElColHeader.find('.AXMPgTableColSortBox');
                    if (panel._tableData.getSortColumn() == colInfo._id) {
                        sortBox.addClass('AXMPgTableColSortBoxActive');
                        sortInv = panel._tableData.getSortInverse();
                    } else sortBox.removeClass('AXMPgTableColSortBoxActive');
                    sortBox.html('<i class="fa fa-arrow-{dir}"></i>'.AXMInterpolate({ dir: sortInv ? 'up' : 'down' }));
                }
            });
        };

        /**
         * Stores the column layout settings as a local cookie
         * @private
         */
        panel._storeColumnSettings = function () {
            if (panel._storeLayout) {
                var colSettings = [];
                $.each(panel._columns, function (colNr, colInfo) {
                    colSettings.push({
                        id: colInfo.getId(),
                        size: colInfo._dispSize
                    });
                });
                var content = window.btoa(JSON.stringify(colSettings));
                if (content.length < appData.maxCookieLength) $.cookie('TableSettings_' + panel.getTypeId(), content);
            }
        };

        /**
         * Loads the column layout settings from a local cookie, if present
         * @private
         */
        panel._loadColumnSettings = function () {
            if (panel._storeLayout) {
                var encodedContent = $.cookie('TableSettings_' + panel.getTypeId());
                if (!encodedContent) return;
                var content = window.atob(encodedContent);
                var colSettings = JSON.parse(content);
                var settingMap = {};
                $.each(colSettings, function (idx, colSetting) {
                    settingMap[colSetting.id] = colSetting;
                });
                $.each(panel._columns, function (colNr, colInfo) {
                    var colSetting = settingMap[colInfo.getId()];
                    if (colSetting) {
                        colInfo.setDispSize(colSetting.size);
                    }
                });
            }
        };

        /**
         * Returns row & column number of a cell, given the jquery cell element
         * @param {jquery} $El
         * @returns {rowNr, colNr}
         * @private
         */
        panel._findTableCell$El = function ($El) {
            if ($El.length == 0) return null;
            var elId = $El.attr('id');
            if (elId) {
                var idComps = elId.split('_');
                if (idComps.length > 0 && idComps[0] == 'tbcell') {
                    return {
                        rowNr: parseInt(idComps[2]),
                        colNr: parseInt(idComps[3])
                    };
                }
            }
            return panel._findTableCell$El($El.parent());
        };

        /**
         * Clears the content of the table
         */
        panel.emptyContent = function () {
            var $ElRightBody = $('#' + panel._divid_rightBody);
            var $ElLeftBody = $('#' + panel._divid_leftBody);
            $ElLeftBody.html('');
            $ElRightBody.html('');
        };

        /**
         * Resets the table pager to top view
         */
        panel.resetView = function () {
            panel._tableOffset = 0;
            panel._lastSelClickedRowNr = null;
            panel._currentRowNr = 0;
            panel.invalidate();
        };

        /**
         * Forces an update of the displayed table content, refreshing any available cache
         */
        panel.reloadContent = function () {
            panel._tableData.resetBuffer();
            panel.invalidate();
        };

        /**
         * Re-renders the table content
         */
        panel.invalidate = function () {
            panel.renderTableContent();
        };

        /**
         * Navigates the pager to the first page
         */
        panel.navigateFirstPage = function () {
            panel._tableOffset = 0;
            panel._lastSelClickedRowNr = null;
            panel.renderTableContent();
        };

        /**
         * Navigates the pager to the previous page
         */
        panel.navigatePreviousPage = function () {
            panel._tableOffset = Math.max(0, panel._tableOffset - panel._tableLineCount);
            panel._lastSelClickedRowNr = null;
            panel.renderTableContent();
        };

        /**
         * Navigates the pager to the next page
         */
        panel.navigateNextPage = function () {
            panel._tableOffset = Math.min(Math.max(0, panel._tableRowCount - panel._tableLineCount + 2), panel._tableOffset + panel._tableLineCount);
            panel._lastSelClickedRowNr = null;
            panel.renderTableContent();
        };

        /**
         * Navigates the pager to the last page
         */
        panel.navigateLastPage = function () {
            panel._tableOffset = Math.max(0, panel._tableRowCount - panel._tableLineCount + 2);
            panel._lastSelClickedRowNr = null;
            panel.renderTableContent();
        };

        /**
         * Navigates the pager over a number of lines (positive or negative
         * @param {int} diff - number of lines to change the offset
         */
        panel.navigateLineDiff = function (diff) {
            var $ElRightBody = $('#' + panel._divid_rightBody);
            var $ElLeftBody = $('#' + panel._divid_leftBody);

            var tableOffsetPrev = panel._tableOffset;
            var rowLastPrev = Math.min(panel._tableRowCount - 1, panel._tableOffset + panel._tableLineCount - 1);

            panel._tableOffset += diff;
            panel._tableOffset = Math.min(Math.max(0, panel._tableRowCount - panel._tableLineCount + 2), panel._tableOffset);
            panel._tableOffset = Math.max(0, panel._tableOffset);
            var rowFirst = panel._tableOffset;
            var rowLast = Math.min(panel._tableRowCount - 1, panel._tableOffset + panel._tableLineCount - 1);
            diff = panel._tableOffset - tableOffsetPrev; // Corrected difference

            if (!panel._tableData.requireRowRange(rowFirst, rowLast, panel.renderTableContent, panel.renderFail)) return; // We need to fetch data first - no fast update here - full rendering will happen

            if (diff > 0) {
                for (var rowNr = tableOffsetPrev; rowNr < panel._tableOffset; rowNr++) {
                    $ElLeftBody.find('#' + panel._getRowLeftId(rowNr)).remove();
                    $ElRightBody.find('#' + panel._getRowRightId(rowNr)).remove();
                }
                for (var rowNr = rowLastPrev + 1; rowNr <= rowLast; rowNr++) {
                    var rowHtml = panel._renderTableRow(rowNr);
                    $ElLeftBody.append(rowHtml.left);
                    $ElRightBody.append(rowHtml.right);
                }
            }

            if (diff < 0) {
                for (var rowNr = rowLastPrev + 1; rowNr > rowLast; rowNr--) {
                    $ElLeftBody.find('#' + panel._getRowLeftId(rowNr)).remove();
                    $ElRightBody.find('#' + panel._getRowRightId(rowNr)).remove();
                }
                for (var rowNr = tableOffsetPrev - 1; rowNr >= panel._tableOffset; rowNr--) {
                    var rowHtml = panel._renderTableRow(rowNr);
                    $ElLeftBody.prepend(rowHtml.left);
                    $ElRightBody.prepend(rowHtml.right);
                }
            }

            panel._renderPager();
        };

        /**
         * Saves the table content to the client's machine
         */
        panel.saveLocal = function () {
            SimplePopups.ConfirmationBox('Do you want to download the table content<br>to your local computer?', 'Download', {}, function () {
                panel._maxDownloadRowCount = 9999;
                if (panel._tableData.requireRowRange(0, panel._maxDownloadRowCount, panel._exec_Save)) panel._exec_Save();
            });
        };

        /**
         * Executes saving the data to the client's machine
         * @private
         */
        panel._exec_Save = function () {
            var cnt = Math.min(panel._maxDownloadRowCount, panel._tableData.getRowCount());
            var data = '';
            var line = '';
            $.each(panel._columns, function (colNr, colInfo) {
                if (colInfo.getName().length > 0) {
                    if (line.length > 0) line += '\t';
                    line += colInfo.getName();
                }
            });
            data += line + '\n';
            for (var rowNr = 0; rowNr < cnt; rowNr++) {
                var rowData = panel._tableData.getRow(rowNr);
                var line = '';
                $.each(panel._columns, function (colNr, colInfo) {
                    if (colInfo.getName().length > 0) {
                        if (line.length > 0) line += '\t';
                        line += colInfo.content2DisplayString(rowData[colInfo.getId()], rowData);
                    }
                });
                data += line + '\n';
            }
            var blob = new Blob([data], { type: "text/plain;charset=utf-8" });
            FileSaver(blob, 'TableContent.txt');
            if (cnt < panel._tableData.getRowCount()) SimplePopups.ErrorBox('Download was restricted to the first {cnt} rows'.AXMInterpolate({ cnt: cnt }));
        };

        /**
         * Resizes the panel
         * @param {int} xl - new x size
         * @param {int} yl - new y size
         */
        panel.resize = function (xl, yl) {
            AXMUtils.Test.checkIsNumber(xl, yl);
            if (!panel) return;
            panel._availableWidth = xl;
            panel._availableHeight = yl;
            panel._measureSize();
        };

        /**
         * Measures the available size for the table, and automatically adjusts the number of lines in the table
         * @private
         */
        panel._measureSize = function () {
            if (!panel._availableHeight) return;

            var leftWidth = $('#' + panel._id + '_leftTableScrollContainer').width();
            $('#' + panel._id + '_rightTableScrollContainer').width(panel._availableWidth - leftWidth + 'px');

            var $ElRightHeadRow = $('#' + panel._divid_rightHeadRow);
            var $ElRightBody = $('#' + panel._divid_rightBody);
            var tableHeight = $ElRightBody.height();
            var rowFirst = panel._tableOffset;
            var rowLast = Math.min(panel._tableRowCount - 1, panel._tableOffset + panel._tableLineCount - 1);
            var displayedLineCount = Math.max(1, rowLast - rowFirst + 1);
            var rowHeight = tableHeight * 1.0 / displayedLineCount;
            var headerHeight = $ElRightHeadRow.height();
            if (rowHeight > 0) {
                panel._tableLineCount = Math.max(1, Math.floor((panel._availableHeight - headerHeight) / rowHeight) - 1);
                panel._sizeMeasured = true;
                panel.renderTableContent();
            }
        };

        panel.listen('UpdateTableRecordContent', function (msg) {
            if (msg.tableId == panel._tableInfo.tableId) {
                panel.reloadContent();
            }
        });

        panel.listen('DeleteTableRecord', function (msg) {
            if (msg.tableId == panel._tableInfo.tableId) {
                panel._tableData.setItemSelected(msg.primKey, false);
                panel.reloadContent();
            }
        });

        panel.listen('UpdateTableInfo', function (tableid) {
            if (tableid == panel._tableInfo.tableId) {
                panel.updateTableInfo();
                panel._tableData.resetBuffer();
                $('#tb' + panel._id).html(panel.createHtmlBody());
                panel.renderTableContent();
                panel.attachEventHandlers();
            }
        });

        panel.listen('TableSelectionModified', function (tableid) {
            if (tableid == panel._tableInfo.tableId) {
                panel.renderTableContent();
            }
        });

        // We keep trying to measure the size, because we don't know when data will arrive
        var autoRetryMeasureSize = function autoRetryMeasureSize() {
            if (panel == null) return;
            if (panel._sizeMeasured) return;
            panel._measureSize();
            setTimeout(autoRetryMeasureSize, 200);
        };
        autoRetryMeasureSize();

        //Remove own object on closing
        panel.addTearDownHandler(function () {
            panel = null;
        });

        return panel;
    };

    /**
     * Creates a frame that contains a table panel
     * @param {string} id - panel type id
     * @param {AXM.Tables.TableData} tableData - object containing the data of the table (content of the cells)
     * @param {AXM.Tables.TableInfo} tableInfo - object containing the definition of the table (column definitions)
     * @returns {Object} - frame instance
     * @constructor
     */
    Module.createTableViewerFrame = function (id, tableData, tableInfo) {
        AXMUtils.Test.checkIsString(id);
        AXMUtils.Test.checkIsType(tableData, '@TableData');
        AXMUtils.Test.checkIsType(tableInfo, '@TableInfo');
        var thePanel = Module.create(id, tableData, tableInfo);
        var theFrame = Frame.FrameFinalCommands(thePanel);

        theFrame.addCommand({
            icon: Icon.createFA("fa-download", 0.85).setOpacity(0.7),
            hint: _TRL("Download table content to local machine")
        }, thePanel.saveLocal);

        theFrame.addSeparator();

        theFrame.addCommand({
            icon: Icon.createFA("fa-flip-horizontal fa-fast-forward", 0.85).setOpacity(0.7),
            hint: _TRL("First page")
        }, thePanel.navigateFirstPage);
        theFrame.addCommand({
            icon: Icon.createFA("fa-flip-horizontal fa-play", 0.85).setOpacity(0.7),
            hint: _TRL("Previous page")
        }, thePanel.navigatePreviousPage);
        theFrame.addCommand({
            icon: Icon.createFA("fa-play", 0.85).setOpacity(0.7),
            hint: _TRL("Next page")
        }, thePanel.navigateNextPage);
        theFrame.addCommand({
            icon: Icon.createFA("fa-fast-forward", 0.85).setOpacity(0.7),
            hint: _TRL("Last page")
        }, thePanel.navigateLastPage);

        thePanel._pagerInfo = Controls.Static({
            text: ''
        });

        theFrame.addSeparator();

        theFrame.addControl(thePanel._pagerInfo);

        theFrame.getTablePanel = function () {
            return thePanel;
        };

        return theFrame;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, PanelBase) {

    /**
     * Module encapsulating a panel with a html5 canvas element
     * @type {{}}
     */
    var Module = {};

    /**
     * Implements a panel that contains a html5 canvas element
     * @param {string} id - panel type id
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.create = function (id) {
        var panel = PanelBase.create(id);

        panel._canvasLayerIds = ['main', 'selection'];
        panel.canvasBaseId = 'CNV_' + panel.getId() + '_';
        panel._canvasLayerMap = {};
        $.each(panel._canvasLayerIds, function (idx, id) {
            panel._canvasLayerMap[id] = {};
        });

        /**
         * Returns the html element id of a canvas associated with a specific layer
         * @param {string} layerid - layer identifier
         * @returns {string} - html id
         */
        panel.getCanvasID = function (layerid) {
            if (!(layerid in panel._canvasLayerMap)) reportError('Invalid canvas id: ' + layerid);
            return panel.canvasBaseId + layerid;
        };

        /**
         * Returns the jquery element of a canvas associated with a specific layer
         * @param {string} layerid - layer identifier
         * @returns {jQuery} - jquery element
         */
        panel.getCanvas$El = function (layerid) {
            return $("#" + panel.getCanvasID(layerid));
        };

        /**
         * Returns the html element of a canvas associated with a specific layer
         * @param {string} layerid - layer identifier
         * @returns {htmlElement} - html element
         */
        panel.getCanvasElement = function (layerid) {
            return panel.getCanvas$El(layerid)[0];
        };

        /**
         * Returns the html implementing the panel
         * @returns {string}
         */
        panel.createHtml = function () {
            var rootDiv = DOM.Div({ id: panel.getId() + '_content' });
            rootDiv.addCssClass('AXMHtmlPanelBody');
            rootDiv.addStyle('width', '100%');
            rootDiv.addStyle('height', '100%');
            rootDiv.addStyle('overflow', 'hidden');

            $.each(panel._canvasLayerIds, function (idx, layerid) {
                var cnv = DOM.Create('canvas', { id: panel.getCanvasID(layerid), parent: rootDiv });
                cnv.addStyle("position", "absolute");
                cnv.addStyle("left", "0");
                cnv.addStyle("top", "0");
            });

            return rootDiv.toString();
        };

        /**
         * Attached html event handlers after DOM insertion
         */
        panel.attachEventHandlers = function () {};

        panel.detachEventHandlers = function () {};

        /**
         * Resizes the panel
         * @param {int} xl - new x dimension
         * @param {int} yl - new y dimension
         * @param params
         */
        panel.resize = function (xl, yl, params) {
            panel._cnvWidth = xl;
            panel._cnvHeight = yl;

            var context = panel.getCanvasElement('main').getContext("2d");
            panel.devicePixelRatio = window.devicePixelRatio || 1;
            panel.backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

            panel.ratio = panel.devicePixelRatio / panel.backingStoreRatio;

            $.each(panel._canvasLayerIds, function (idx, layerid) {
                var $El = panel.getCanvas$El(layerid);
                $El.width(panel._cnvWidth + 'px');
                $El.height(panel._cnvHeight + 'px');
            });

            if (!params.resizing) {
                $.each(panel._canvasLayerIds, function (idx, layerid) {
                    var canvasElement = panel.getCanvasElement(layerid);
                    if (canvasElement) {
                        canvasElement.width = panel._cnvWidth * panel.ratio;
                        canvasElement.height = panel._cnvHeight * panel.ratio;
                    }
                });
                panel.render();
            }
        };

        /**
         * Renders the drawing in the canvas element
         */
        panel.render_exec = function () {
            var ctx = panel.getCanvasElement('main').getContext("2d");
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(panel.ratio, panel.ratio);
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, panel._cnvWidth, panel._cnvHeight);
            var drawInfo = {
                ctx: ctx,
                sizeX: panel._cnvWidth,
                sizeY: panel._cnvHeight
            };
            panel.draw(drawInfo);
        };

        /**
         * Renders the drawing in the canvas element
         */
        panel.render = function () {
            panel.render_exec();
        };

        /**
         * Implements the drawing to the canvas element (to be overriden in derived classes)
         * @param {{}} drawInfo - drawing info
         */
        panel.draw = function (drawInfo) {
            drawInfo.ctx.beginPath();
            drawInfo.ctx.moveTo(0, 0);
            drawInfo.ctx.lineTo(drawInfo.sizeX, drawInfo.sizeY);
            drawInfo.ctx.stroke();
        };

        /**
         * Returns the X position contained in a html event object
         * @param {{}} ev - html event object
         * @returns {number} - returns the X position
         */
        panel.getEventPosX = function (ev) {
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            return ev1.pageX - panel.getCanvas$El('main').offset().left;
        };

        /**
         * Returns the Y position contained in a html event object
         * @param {{}} ev - html event object
         * @returns {number} - returns the Y position
         */
        panel.getEventPosY = function (ev) {
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            return ev1.pageY - panel.getCanvas$El('main').offset().top;
        };

        /**
         * Converts a canvas X position to browser x position
         * @param {int} px - x position
         * @returns {int}
         */
        panel.posXCanvas2Screen = function (px) {
            return px + panel.getCanvas$El('main').offset().left;
        };

        /**
         * Converts a canvas Y position to browser y position
         * @param {int} py - y position
         * @returns {int}
         */
        panel.posYCanvas2Screen = function (py) {
            return py + panel.getCanvas$El('main').offset().top;
        };

        /**
         * Saves the canvas element content to a data url
         */
        panel.save = function () {
            var win = window.open('_blank');
            win.document.write("<img src='" + panel.getCanvasElement('main').toDataURL('image/png') + "'/>");
        };

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(56), __webpack_require__(61), __webpack_require__(57), __webpack_require__(58), __webpack_require__(59), __webpack_require__(60)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, ScatterPlot, Histogram, BarGraph, MultiCatHistogram, CrossTab, BinPredictor) {

    var Module = {
        plotTypes: []
    };

    Module.plotTypes.push(ScatterPlot);
    Module.plotTypes.push(Histogram);
    Module.plotTypes.push(BarGraph);
    Module.plotTypes.push(MultiCatHistogram);
    Module.plotTypes.push(CrossTab);
    Module.plotTypes.push(BinPredictor);

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, Controls, SimplePopups, Plots) {

    var Module = {};
    Module.lastExpr = '';

    Module.create = function (dataFrame, startQuery, onCompleted) {

        var win = PopupWindow.create({
            title: _TRL('Query'),
            blocking: true,
            autoCenter: true
        });

        if (startQuery) Module.lastExpr = startQuery;
        var grp = Controls.Compound.GroupVert({ separator: 5 });
        grp.add(_TRL('<i>Use the following tokens in the expression:</i>'));
        var grd = Controls.Compound.Grid({ sepH: 4, sepV: 2 });
        $.each(dataFrame.getProperties(), function (idx, property) {
            var filterButton = Controls.Button({
                icon: 'fa-plus-square',
                width: 25,
                height: 19,
                buttonClass: 'AXMButtonCommandBar',
                iconSizeFraction: 0.9
            }).addNotificationHandler(function () {
                var str = win.ctrlExpr.getValue() + 'pt.' + property.getId();
                win.ctrlExpr.setValue(str);
                win.ctrlExpr.setFocus();
            });
            grd.setItem(idx, 0, filterButton);
            grd.setItem(idx, 1, '<b>pt.' + property.getId() + '</b>');
            grd.setItem(idx, 2, property.getDispName());
        });
        grp.add(Controls.Compound.VScroller(grd, 300));

        win.ctrlExpr = Controls.Edit({ width: 500, value: Module.lastExpr }).setHasDefaultFocus();
        grp.add(win.ctrlExpr);

        grp.add(_TRL('<i>NOTE: test equality with "==". Surround strings with single quotes.</i>'));

        var btOK = Controls.Button({
            text: _TRL('Execute'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.execute();
        });
        grp.add(btOK);

        win.execute = function () {
            win.close();
            var expr = win.ctrlExpr.getValue();
            Module.lastExpr = expr;
            var selList = [];
            var dataPrimKey = dataFrame.getPrimKeyProperty().data;
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var pt = {};
                $.each(dataFrame.getProperties(), function (idx, property) {
                    pt[property.getId()] = property.data[rowNr];
                });
                if (eval(expr)) selList.push(dataPrimKey[rowNr]);
            }
            onCompleted(selList, expr);
        };

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(36)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, Controls, SimplePopups, FrameQuery) {

    var Module = {};

    Module.create = function (dataFrame, primKey, parentWin) {
        var win = PopupWindow.create({
            title: _TRL('Data point'),
            blocking: false,
            autoCenter: true
        });

        var dataPrimKey = dataFrame.getPrimKeyProperty().data;
        var rowNr = -1;
        for (var i = 0; i < dataFrame.getRowCount(); i++) {
            if (primKey == dataPrimKey[i]) rowNr = i;
        }
        if (rowNr < 0) AXMUtils.reportBug(_TRL('Invalid dataframe item'));

        var rootGrp = Controls.Compound.GroupVert({ separator: 12 });

        var grp = Controls.Compound.Grid({});
        rootGrp.add(Controls.Compound.VScroller(grp, 400));

        var rowData = {};
        $.each(dataFrame.getProperties(), function (idx, property) {
            grp.setItem(idx, 0, property.getDispName());
            grp.setItem(idx, 1, property.content2DisplayString(property.data[rowNr]));
            rowData[property.getId()] = property.data[rowNr];
            if (parentWin.performRowSelected) {
                var filterButton = Controls.Button({
                    icon: 'fa-filter',
                    width: 25,
                    height: 19,
                    buttonClass: 'AXMButtonCommandBar',
                    iconSizeFraction: 0.9
                }).addNotificationHandler(function () {
                    win.filter(property);
                });
                grp.setItem(idx, 2, filterButton);
            }
            grp.setItem(idx, 3, '<span style="color:rgb(192,192,192);font-size:80%">' + property.getId() + '</span>');
        });

        var openHandler = dataFrame.getObjectType().getOpenHandler();
        if (openHandler) {
            var btOpen = Controls.Button({
                text: _TRL('Open'),
                icon: 'fa-arrow-right'
            }).addNotificationHandler(function () {
                openHandler(primKey, rowData);
            });
            rootGrp.add(btOpen);
        }

        $.each(dataFrame.getRowOpenHandlerList(), function (idx, handlerInfo) {
            var btOpen = Controls.Button({
                text: _TRL(handlerInfo.name),
                icon: 'fa-arrow-right'
            }).addNotificationHandler(function () {
                handlerInfo.handler(primKey, rowData);
                win.close();
            });
            rootGrp.add(btOpen);
        });

        win.filter = function (property) {
            var value = property.data[rowNr];
            if (property.getDataType().isString()) value = "'" + value + "'";
            var expr = 'pt.' + property.getId() + ' == ' + value;
            FrameQuery.create(dataFrame, expr, function (selList, expr) {
                win.close();
                parentWin.performRowSelected(selList, expr);
            });
        };

        win.setRootControl(Controls.Compound.StandardMargin(rootGrp));
        win.start();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

__webpack_require__(39);

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(7), __webpack_require__(2), __webpack_require__(8), __webpack_require__(4), __webpack_require__(21), __webpack_require__(14), __webpack_require__(43), __webpack_require__(32), __webpack_require__(24), __webpack_require__(3), __webpack_require__(22), __webpack_require__(10), __webpack_require__(66), __webpack_require__(16), __webpack_require__(33), __webpack_require__(49), __webpack_require__(50), __webpack_require__(34), __webpack_require__(28), __webpack_require__(25), __webpack_require__(11), __webpack_require__(51), __webpack_require__(30), __webpack_require__(6), __webpack_require__(5), __webpack_require__(53), __webpack_require__(23), __webpack_require__(31), __webpack_require__(54), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Msg, Utils, Color, DOM, DrawUtils, Icon, Application, TableData, TableInfo, Controls, Compound, Frame, FlexTabber, PanelForm, PanelTable, PanelFHTable, PanelList, PanelCanvas, PanelCanvasZoomPan, PanelCanvasXYPlot, PanelHtml, FrameTrackViewer, RootWindow, PopupWindow, SimplePopups, LogViewer, DocViewer, TransientPopup, DataFrame, Stats) {

    /**
     * Module encapsulating a hierarchical tree of all Axiom modules
     * @type {{}}
     */
    var Module = {
        Msg: Msg,
        DOM: DOM,
        Utils: Utils,
        Color: Color,
        DrawUtils: DrawUtils,
        Test: Utils.Test,
        Icon: Icon,
        Stats: Stats,
        Application: Application,
        Tables: {
            TableData: TableData,
            TableInfo: TableInfo
        },
        Controls: Controls,
        Panels: {
            Frame: Frame,
            FlexTabber: FlexTabber,
            PanelForm: PanelForm,
            PanelTable: PanelTable,
            PanelFHTable: PanelFHTable,
            PanelList: PanelList,
            PanelCanvas: PanelCanvas,
            PanelCanvasZoomPan: PanelCanvasZoomPan,
            PanelCanvasXYPlot: PanelCanvasXYPlot,
            PanelHtml: PanelHtml,
            FrameTrackViewer: FrameTrackViewer
        },
        Windows: {
            RootWindow: RootWindow,
            PopupWindow: PopupWindow,
            SimplePopups: SimplePopups,
            LogViewer: LogViewer,
            DocViewer: DocViewer,
            TransientPopup: TransientPopup
        },
        DataFrame: DataFrame
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 39 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */

(function (factory) {
    if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // CommonJS
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function ($) {

    var pluses = /\+/g;

    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            // If we can't parse the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses, ' '));
            return config.json ? JSON.parse(s) : s;
        } catch (e) {}
    }

    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }

    var config = $.cookie = function (key, value, options) {

        // Write

        if (arguments.length > 1 && !$.isFunction(value)) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires,
                    t = options.expires = new Date();
                t.setTime(+t + days * 864e+5);
            }

            return document.cookie = [encode(key), '=', stringifyCookieValue(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
            options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join('');
        }

        // Read

        var result = key ? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling $.cookie().
        var cookies = document.cookie ? document.cookie.split('; ') : [];

        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = parts.join('=');

            if (key && key === name) {
                // If second argument (value) is a function it's a converter...
                result = read(cookie, value);
                break;
            }

            // Prevent storing a cookie that we couldn't decode.
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }

        return result;
    };

    config.defaults = {};

    $.removeCookie = function (key, options) {
        if ($.cookie(key) === undefined) {
            return false;
        }

        // Must not alter options, thus extending a fresh object...
        $.cookie(key, '', $.extend({}, options, { expires: -1 }));
        return !$.cookie(key);
    };
});

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(12), __webpack_require__(30), __webpack_require__(7), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Test, RootWindow, Msg, Color) {

    /**
     * A global object containing some basic styling data such as colours
     */
    AXMBaseStyling = {
        color1: Color.Color(0, 138 / 255.0, 150 / 255.0)
    };

    /**
     * Module encapsulating the one and only global application object
     * @type {{}}
     */
    var Module = {};

    /**
     * The one and only global application object
     * @type {{}}
     */
    var theApp = {};

    /**
     * Sets the one and only root frame for the app window
     * @param {AXM.Panels.Frame} iRootFrame - frame object
     */
    theApp.setRootFrame = function (iRootFrame) {
        Test.checkIsType(iRootFrame, "@Frame");
        theApp._rootFrame = iRootFrame;
    };

    /**
     * Returns the one and only application root frame
     * @returns {AXM.Panels.Frame}
     */
    theApp.getRootFrame = function () {
        return theApp._rootFrame;
    };

    /**
     * Handles the html event associated with closing the app
     * @param ev
     * @returns {*}
     */
    theApp.confirmExit = function (ev) {
        var confirmMessage = null;
        var results = Msg.broadcast('ConfirmExit');
        $.each(results, function (idx, msg) {
            if (msg) confirmMessage = msg;
        });
        if (confirmMessage) return confirmMessage;else {
            Msg.broadcast('ExecuteExit');
            // theApp._rootFrame.detachEventHandlers();
            // theApp._rootFrame.informWillClose();
        }
    };

    /**
     * Initialises the app
     */
    theApp.init = function () {
        Test.checkDefined(theApp._rootFrame, "No root frame defined. Call Application.setRootFrame first.");
        theApp._rootWindow = RootWindow.create(theApp._rootFrame);
        theApp._rootWindow.render();

        window.onbeforeunload = theApp.confirmExit;

        //Prevent drag & drop to app area
        window.addEventListener("dragover", function (e) {
            e = e || event;
            e.preventDefault();
        }, false);
        window.addEventListener("drop", function (e) {
            e = e || event;
            e.preventDefault();
        }, false);

        //$(document).mouseup(function(e) {
        //    console.log("mouseup");
        //    //var container = $("YOUR CONTAINER SELECTOR");
        //    //
        //    //if (!container.is(e.target) // if the target of the click isn't the container...
        //    //    && container.has(e.target).length === 0) // ... nor a descendant of the container
        //    //{
        //    //    container.hide();
        //    //}
        //});

        //$().load(function() {
        //    console.log("test1");
        //    console.log("datepicker id="+datepickerid);

        //console.log("test2");
        //
        //});
    };

    /**
     * Returns the one and only app instance
     * @returns {{}}
     */
    Module.get = function () {
        return theApp;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014 - 2015
 * @version 1.3.3
 *
 * Date formatter utility library that allows formatting date/time variables or Date objects using PHP DateTime format.
 * @see http://php.net/manual/en/function.date.php
 *
 * For more JQuery plugins visit http://plugins.krajee.com
 * For more Yii related demos visit http://demos.krajee.com
 */
var DateFormatter;
(function () {
    "use strict";

    var _compare, _lpad2, _extend2, defaultSettings, DAY, HOUR;
    DAY = 1000 * 60 * 60 * 24;
    HOUR = 3600;

    _compare = function _compare(str1, str2) {
        return typeof str1 === 'string' && typeof str2 === 'string' && str1.toLowerCase() === str2.toLowerCase();
    };
    _lpad2 = function _lpad(value, length, char) {
        var chr = char || '0',
            val = value.toString();
        return val.length < length ? _lpad2(chr + val, length) : val;
    };
    _extend2 = function _extend(out) {
        var i, obj;
        out = out || {};
        for (i = 1; i < arguments.length; i++) {
            obj = arguments[i];
            if (!obj) {
                continue;
            }
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (_typeof(obj[key]) === 'object') {
                        _extend2(out[key], obj[key]);
                    } else {
                        out[key] = obj[key];
                    }
                }
            }
        }
        return out;
    };
    defaultSettings = {
        dateSettings: {
            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            meridiem: ['AM', 'PM'],
            ordinal: function ordinal(number) {
                var n = number % 10,
                    suffixes = { 1: 'st', 2: 'nd', 3: 'rd' };
                return Math.floor(number % 100 / 10) === 1 || !suffixes[n] ? 'th' : suffixes[n];
            }
        },
        separators: /[ \-+\/\.T:@]/g,
        validParts: /[dDjlNSwzWFmMntLoYyaABgGhHisueTIOPZcrU]/g,
        intParts: /[djwNzmnyYhHgGis]/g,
        tzParts: /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        tzClip: /[^-+\dA-Z]/g
    };

    DateFormatter = function DateFormatter(options) {
        var self = this,
            config = _extend2(defaultSettings, options);
        self.dateSettings = config.dateSettings;
        self.separators = config.separators;
        self.validParts = config.validParts;
        self.intParts = config.intParts;
        self.tzParts = config.tzParts;
        self.tzClip = config.tzClip;
    };

    DateFormatter.prototype = {
        constructor: DateFormatter,
        parseDate: function parseDate(vDate, vFormat) {
            var self = this,
                vFormatParts,
                vDateParts,
                i,
                vDateFlag = false,
                vTimeFlag = false,
                vDatePart,
                iDatePart,
                vSettings = self.dateSettings,
                vMonth,
                vMeriIndex,
                vMeriOffset,
                len,
                mer,
                out = { date: null, year: null, month: null, day: null, hour: 0, min: 0, sec: 0 };
            if (!vDate) {
                return undefined;
            }
            if (vDate instanceof Date) {
                return vDate;
            }
            if (typeof vDate === 'number') {
                return new Date(vDate);
            }
            if (vFormat === 'U') {
                i = parseInt(vDate);
                return i ? new Date(i * 1000) : vDate;
            }
            if (typeof vDate !== 'string') {
                return '';
            }
            vFormatParts = vFormat.match(self.validParts);
            if (!vFormatParts || vFormatParts.length === 0) {
                throw new Error("Invalid date format definition.");
            }
            vDateParts = vDate.replace(self.separators, '\0').split('\0');
            for (i = 0; i < vDateParts.length; i++) {
                vDatePart = vDateParts[i];
                iDatePart = parseInt(vDatePart);
                switch (vFormatParts[i]) {
                    case 'y':
                    case 'Y':
                        len = vDatePart.length;
                        if (len === 2) {
                            out.year = parseInt((iDatePart < 70 ? '20' : '19') + vDatePart);
                        } else if (len === 4) {
                            out.year = iDatePart;
                        }
                        vDateFlag = true;
                        break;
                    case 'm':
                    case 'n':
                    case 'M':
                    case 'F':
                        if (isNaN(vDatePart)) {
                            vMonth = vSettings.monthsShort.indexOf(vDatePart);
                            if (vMonth > -1) {
                                out.month = vMonth + 1;
                            }
                            vMonth = vSettings.months.indexOf(vDatePart);
                            if (vMonth > -1) {
                                out.month = vMonth + 1;
                            }
                        } else {
                            if (iDatePart >= 1 && iDatePart <= 12) {
                                out.month = iDatePart;
                            }
                        }
                        vDateFlag = true;
                        break;
                    case 'd':
                    case 'j':
                        if (iDatePart >= 1 && iDatePart <= 31) {
                            out.day = iDatePart;
                        }
                        vDateFlag = true;
                        break;
                    case 'g':
                    case 'h':
                        vMeriIndex = vFormatParts.indexOf('a') > -1 ? vFormatParts.indexOf('a') : vFormatParts.indexOf('A') > -1 ? vFormatParts.indexOf('A') : -1;
                        mer = vDateParts[vMeriIndex];
                        if (vMeriIndex > -1) {
                            vMeriOffset = _compare(mer, vSettings.meridiem[0]) ? 0 : _compare(mer, vSettings.meridiem[1]) ? 12 : -1;
                            if (iDatePart >= 1 && iDatePart <= 12 && vMeriOffset > -1) {
                                out.hour = iDatePart + vMeriOffset - 1;
                            } else if (iDatePart >= 0 && iDatePart <= 23) {
                                out.hour = iDatePart;
                            }
                        } else if (iDatePart >= 0 && iDatePart <= 23) {
                            out.hour = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                    case 'G':
                    case 'H':
                        if (iDatePart >= 0 && iDatePart <= 23) {
                            out.hour = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                    case 'i':
                        if (iDatePart >= 0 && iDatePart <= 59) {
                            out.min = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                    case 's':
                        if (iDatePart >= 0 && iDatePart <= 59) {
                            out.sec = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                }
            }
            if (vDateFlag === true && out.year && out.month && out.day) {
                out.date = new Date(out.year, out.month - 1, out.day, out.hour, out.min, out.sec, 0);
            } else {
                if (vTimeFlag !== true) {
                    return false;
                }
                out.date = new Date(0, 0, 0, out.hour, out.min, out.sec, 0);
            }
            return out.date;
        },
        guessDate: function guessDate(vDateStr, vFormat) {
            if (typeof vDateStr !== 'string') {
                return vDateStr;
            }
            var self = this,
                vParts = vDateStr.replace(self.separators, '\0').split('\0'),
                vPattern = /^[djmn]/g,
                vFormatParts = vFormat.match(self.validParts),
                vDate = new Date(),
                vDigit = 0,
                vYear,
                i,
                iPart,
                iSec;

            if (!vPattern.test(vFormatParts[0])) {
                return vDateStr;
            }

            for (i = 0; i < vParts.length; i++) {
                vDigit = 2;
                iPart = vParts[i];
                iSec = parseInt(iPart.substr(0, 2));
                switch (i) {
                    case 0:
                        if (vFormatParts[0] === 'm' || vFormatParts[0] === 'n') {
                            vDate.setMonth(iSec - 1);
                        } else {
                            vDate.setDate(iSec);
                        }
                        break;
                    case 1:
                        if (vFormatParts[0] === 'm' || vFormatParts[0] === 'n') {
                            vDate.setDate(iSec);
                        } else {
                            vDate.setMonth(iSec - 1);
                        }
                        break;
                    case 2:
                        vYear = vDate.getFullYear();
                        if (iPart.length < 4) {
                            vDate.setFullYear(parseInt(vYear.toString().substr(0, 4 - iPart.length) + iPart));
                            vDigit = iPart.length;
                        } else {
                            vDate.setFullYear = parseInt(iPart.substr(0, 4));
                            vDigit = 4;
                        }
                        break;
                    case 3:
                        vDate.setHours(iSec);
                        break;
                    case 4:
                        vDate.setMinutes(iSec);
                        break;
                    case 5:
                        vDate.setSeconds(iSec);
                        break;
                }
                if (iPart.substr(vDigit).length > 0) {
                    vParts.splice(i + 1, 0, iPart.substr(vDigit));
                }
            }
            return vDate;
        },
        parseFormat: function parseFormat(vChar, vDate) {
            var self = this,
                vSettings = self.dateSettings,
                fmt,
                backspace = /\\?(.?)/gi,
                doFormat = function doFormat(t, s) {
                return fmt[t] ? fmt[t]() : s;
            };
            fmt = {
                /////////
                // DAY //
                /////////
                /**
                 * Day of month with leading 0: `01..31`
                 * @return {string}
                 */
                d: function d() {
                    return _lpad2(fmt.j(), 2);
                },
                /**
                 * Shorthand day name: `Mon...Sun`
                 * @return {string}
                 */
                D: function D() {
                    return vSettings.daysShort[fmt.w()];
                },
                /**
                 * Day of month: `1..31`
                 * @return {number}
                 */
                j: function j() {
                    return vDate.getDate();
                },
                /**
                 * Full day name: `Monday...Sunday`
                 * @return {number}
                 */
                l: function l() {
                    return vSettings.days[fmt.w()];
                },
                /**
                 * ISO-8601 day of week: `1[Mon]..7[Sun]`
                 * @return {number}
                 */
                N: function N() {
                    return fmt.w() || 7;
                },
                /**
                 * Day of week: `0[Sun]..6[Sat]`
                 * @return {number}
                 */
                w: function w() {
                    return vDate.getDay();
                },
                /**
                 * Day of year: `0..365`
                 * @return {number}
                 */
                z: function z() {
                    var a = new Date(fmt.Y(), fmt.n() - 1, fmt.j()),
                        b = new Date(fmt.Y(), 0, 1);
                    return Math.round((a - b) / DAY);
                },

                //////////
                // WEEK //
                //////////
                /**
                 * ISO-8601 week number
                 * @return {number}
                 */
                W: function W() {
                    var a = new Date(fmt.Y(), fmt.n() - 1, fmt.j() - fmt.N() + 3),
                        b = new Date(a.getFullYear(), 0, 4);
                    return _lpad2(1 + Math.round((a - b) / DAY / 7), 2);
                },

                ///////////
                // MONTH //
                ///////////
                /**
                 * Full month name: `January...December`
                 * @return {string}
                 */
                F: function F() {
                    return vSettings.months[vDate.getMonth()];
                },
                /**
                 * Month w/leading 0: `01..12`
                 * @return {string}
                 */
                m: function m() {
                    return _lpad2(fmt.n(), 2);
                },
                /**
                 * Shorthand month name; `Jan...Dec`
                 * @return {string}
                 */
                M: function M() {
                    return vSettings.monthsShort[vDate.getMonth()];
                },
                /**
                 * Month: `1...12`
                 * @return {number}
                 */
                n: function n() {
                    return vDate.getMonth() + 1;
                },
                /**
                 * Days in month: `28...31`
                 * @return {number}
                 */
                t: function t() {
                    return new Date(fmt.Y(), fmt.n(), 0).getDate();
                },

                //////////
                // YEAR //
                //////////
                /**
                 * Is leap year? `0 or 1`
                 * @return {number}
                 */
                L: function L() {
                    var Y = fmt.Y();
                    return Y % 4 === 0 && Y % 100 !== 0 || Y % 400 === 0 ? 1 : 0;
                },
                /**
                 * ISO-8601 year
                 * @return {number}
                 */
                o: function o() {
                    var n = fmt.n(),
                        W = fmt.W(),
                        Y = fmt.Y();
                    return Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);
                },
                /**
                 * Full year: `e.g. 1980...2010`
                 * @return {number}
                 */
                Y: function Y() {
                    return vDate.getFullYear();
                },
                /**
                 * Last two digits of year: `00...99`
                 * @return {string}
                 */
                y: function y() {
                    return fmt.Y().toString().slice(-2);
                },

                //////////
                // TIME //
                //////////
                /**
                 * Meridian lower: `am or pm`
                 * @return {string}
                 */
                a: function a() {
                    return fmt.A().toLowerCase();
                },
                /**
                 * Meridian upper: `AM or PM`
                 * @return {string}
                 */
                A: function A() {
                    var n = fmt.G() < 12 ? 0 : 1;
                    return vSettings.meridiem[n];
                },
                /**
                 * Swatch Internet time: `000..999`
                 * @return {string}
                 */
                B: function B() {
                    var H = vDate.getUTCHours() * HOUR,
                        i = vDate.getUTCMinutes() * 60,
                        s = vDate.getUTCSeconds();
                    return _lpad2(Math.floor((H + i + s + HOUR) / 86.4) % 1000, 3);
                },
                /**
                 * 12-Hours: `1..12`
                 * @return {number}
                 */
                g: function g() {
                    return fmt.G() % 12 || 12;
                },
                /**
                 * 24-Hours: `0..23`
                 * @return {number}
                 */
                G: function G() {
                    return vDate.getHours();
                },
                /**
                 * 12-Hours with leading 0: `01..12`
                 * @return {string}
                 */
                h: function h() {
                    return _lpad2(fmt.g(), 2);
                },
                /**
                 * 24-Hours w/leading 0: `00..23`
                 * @return {string}
                 */
                H: function H() {
                    return _lpad2(fmt.G(), 2);
                },
                /**
                 * Minutes w/leading 0: `00..59`
                 * @return {string}
                 */
                i: function i() {
                    return _lpad2(vDate.getMinutes(), 2);
                },
                /**
                 * Seconds w/leading 0: `00..59`
                 * @return {string}
                 */
                s: function s() {
                    return _lpad2(vDate.getSeconds(), 2);
                },
                /**
                 * Microseconds: `000000-999000`
                 * @return {string}
                 */
                u: function u() {
                    return _lpad2(vDate.getMilliseconds() * 1000, 6);
                },

                //////////////
                // TIMEZONE //
                //////////////
                /**
                 * Timezone identifier: `e.g. Atlantic/Azores, ...`
                 * @return {string}
                 */
                e: function e() {
                    var str = /\((.*)\)/.exec(String(vDate))[1];
                    return str || 'Coordinated Universal Time';
                },
                /**
                 * Timezone abbreviation: `e.g. EST, MDT, ...`
                 * @return {string}
                 */
                T: function T() {
                    var str = (String(vDate).match(self.tzParts) || [""]).pop().replace(self.tzClip, "");
                    return str || 'UTC';
                },
                /**
                 * DST observed? `0 or 1`
                 * @return {number}
                 */
                I: function I() {
                    var a = new Date(fmt.Y(), 0),
                        c = Date.UTC(fmt.Y(), 0),
                        b = new Date(fmt.Y(), 6),
                        d = Date.UTC(fmt.Y(), 6);
                    return a - c !== b - d ? 1 : 0;
                },
                /**
                 * Difference to GMT in hour format: `e.g. +0200`
                 * @return {string}
                 */
                O: function O() {
                    var tzo = vDate.getTimezoneOffset(),
                        a = Math.abs(tzo);
                    return (tzo > 0 ? '-' : '+') + _lpad2(Math.floor(a / 60) * 100 + a % 60, 4);
                },
                /**
                 * Difference to GMT with colon: `e.g. +02:00`
                 * @return {string}
                 */
                P: function P() {
                    var O = fmt.O();
                    return O.substr(0, 3) + ':' + O.substr(3, 2);
                },
                /**
                 * Timezone offset in seconds: `-43200...50400`
                 * @return {number}
                 */
                Z: function Z() {
                    return -vDate.getTimezoneOffset() * 60;
                },

                ////////////////////
                // FULL DATE TIME //
                ////////////////////
                /**
                 * ISO-8601 date
                 * @return {string}
                 */
                c: function c() {
                    return 'Y-m-d\\TH:i:sP'.replace(backspace, doFormat);
                },
                /**
                 * RFC 2822 date
                 * @return {string}
                 */
                r: function r() {
                    return 'D, d M Y H:i:s O'.replace(backspace, doFormat);
                },
                /**
                 * Seconds since UNIX epoch
                 * @return {number}
                 */
                U: function U() {
                    return vDate.getTime() / 1000 || 0;
                }
            };
            return doFormat(vChar, vChar);
        },
        formatDate: function formatDate(vDate, vFormat) {
            var self = this,
                i,
                n,
                len,
                str,
                vChar,
                vDateStr = '';
            if (typeof vDate === 'string') {
                vDate = self.parseDate(vDate, vFormat);
                if (vDate === false) {
                    return false;
                }
            }
            if (vDate instanceof Date) {
                len = vFormat.length;
                for (i = 0; i < len; i++) {
                    vChar = vFormat.charAt(i);
                    if (vChar === 'S') {
                        continue;
                    }
                    str = self.parseFormat(vChar, vDate);
                    if (i !== len - 1 && self.intParts.test(vChar) && vFormat.charAt(i + 1) === 'S') {
                        n = parseInt(str);
                        str += self.dateSettings.ordinal(n);
                    }
                    vDateStr += str;
                }
                return vDateStr;
            }
            return '';
        }
    };
})(); /**
      * @preserve jQuery DateTimePicker plugin v2.5.1
      * @homepage http://xdsoft.net/jqplugins/datetimepicker/
      * @author Chupurnov Valeriy (<chupurnov@gmail.com>)
      */
/*global DateFormatter, document,window,jQuery,setTimeout,clearTimeout,HighlightedDate,getCurrentValue*/
;(function (factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(45)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function ($) {
    'use strict';

    var default_options = {
        i18n: {
            ar: { // Arabic
                months: ["كانون الثاني", "شباط", "آذار", "نيسان", "مايو", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"],
                dayOfWeekShort: ["ن", "ث", "ع", "خ", "ج", "س", "ح"],
                dayOfWeek: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت", "الأحد"]
            },
            ro: { // Romanian
                months: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"],
                dayOfWeekShort: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"],
                dayOfWeek: ["Duminică", "Luni", "Marţi", "Miercuri", "Joi", "Vineri", "Sâmbătă"]
            },
            id: { // Indonesian
                months: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"],
                dayOfWeekShort: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
                dayOfWeek: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
            },
            is: { // Icelandic
                months: ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní", "Júlí", "Ágúst", "September", "Október", "Nóvember", "Desember"],
                dayOfWeekShort: ["Sun", "Mán", "Þrið", "Mið", "Fim", "Fös", "Lau"],
                dayOfWeek: ["Sunnudagur", "Mánudagur", "Þriðjudagur", "Miðvikudagur", "Fimmtudagur", "Föstudagur", "Laugardagur"]
            },
            bg: { // Bulgarian
                months: ["Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"],
                dayOfWeekShort: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
                dayOfWeek: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"]
            },
            fa: { // Persian/Farsi
                months: ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
                dayOfWeekShort: ['یکشنبه', 'دوشنبه', 'سه شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه', 'شنبه'],
                dayOfWeek: ["یک‌شنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنج‌شنبه", "جمعه", "شنبه", "یک‌شنبه"]
            },
            ru: { // Russian
                months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
                dayOfWeekShort: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
                dayOfWeek: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"]
            },
            uk: { // Ukrainian
                months: ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'],
                dayOfWeekShort: ["Ндл", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Сбт"],
                dayOfWeek: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"]
            },
            en: { // English
                months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            },
            el: { // Ελληνικά
                months: ["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"],
                dayOfWeekShort: ["Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"],
                dayOfWeek: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"]
            },
            de: { // German
                months: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
                dayOfWeekShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
                dayOfWeek: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
            },
            nl: { // Dutch
                months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
                dayOfWeekShort: ["zo", "ma", "di", "wo", "do", "vr", "za"],
                dayOfWeek: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
            },
            tr: { // Turkish
                months: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"],
                dayOfWeekShort: ["Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"],
                dayOfWeek: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
            },
            fr: { //French
                months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
                dayOfWeekShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
                dayOfWeek: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
            },
            es: { // Spanish
                months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
                dayOfWeekShort: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
                dayOfWeek: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"]
            },
            th: { // Thai
                months: ['มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'],
                dayOfWeekShort: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
                dayOfWeek: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัส", "ศุกร์", "เสาร์", "อาทิตย์"]
            },
            pl: { // Polish
                months: ["styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"],
                dayOfWeekShort: ["nd", "pn", "wt", "śr", "cz", "pt", "sb"],
                dayOfWeek: ["niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota"]
            },
            pt: { // Portuguese
                months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
                dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"],
                dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
            },
            ch: { // Simplified Chinese
                months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
                dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"]
            },
            se: { // Swedish
                months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
                dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"]
            },
            kr: { // Korean
                months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
                dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
                dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
            },
            it: { // Italian
                months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
                dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
                dayOfWeek: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
            },
            da: { // Dansk
                months: ["January", "Februar", "Marts", "April", "Maj", "Juni", "July", "August", "September", "Oktober", "November", "December"],
                dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
                dayOfWeek: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
            },
            no: { // Norwegian
                months: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
                dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
                dayOfWeek: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag']
            },
            ja: { // Japanese
                months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
                dayOfWeekShort: ["日", "月", "火", "水", "木", "金", "土"],
                dayOfWeek: ["日曜", "月曜", "火曜", "水曜", "木曜", "金曜", "土曜"]
            },
            vi: { // Vietnamese
                months: ["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"],
                dayOfWeekShort: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
                dayOfWeek: ["Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", "Thứ năm", "Thứ sáu", "Thứ bảy"]
            },
            sl: { // Slovenščina
                months: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"],
                dayOfWeekShort: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
                dayOfWeek: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"]
            },
            cs: { // Čeština
                months: ["Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"],
                dayOfWeekShort: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"]
            },
            hu: { // Hungarian
                months: ["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"],
                dayOfWeekShort: ["Va", "Hé", "Ke", "Sze", "Cs", "Pé", "Szo"],
                dayOfWeek: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"]
            },
            az: { //Azerbaijanian (Azeri)
                months: ["Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"],
                dayOfWeekShort: ["B", "Be", "Ça", "Ç", "Ca", "C", "Ş"],
                dayOfWeek: ["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"]
            },
            bs: { //Bosanski
                months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
                dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
                dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
            },
            ca: { //Català
                months: ["Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"],
                dayOfWeekShort: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
                dayOfWeek: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
            },
            'en-GB': { //English (British)
                months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            },
            et: { //"Eesti"
                months: ["Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"],
                dayOfWeekShort: ["P", "E", "T", "K", "N", "R", "L"],
                dayOfWeek: ["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"]
            },
            eu: { //Euskara
                months: ["Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"],
                dayOfWeekShort: ["Ig.", "Al.", "Ar.", "Az.", "Og.", "Or.", "La."],
                dayOfWeek: ['Igandea', 'Astelehena', 'Asteartea', 'Asteazkena', 'Osteguna', 'Ostirala', 'Larunbata']
            },
            fi: { //Finnish (Suomi)
                months: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"],
                dayOfWeekShort: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
                dayOfWeek: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
            },
            gl: { //Galego
                months: ["Xan", "Feb", "Maz", "Abr", "Mai", "Xun", "Xul", "Ago", "Set", "Out", "Nov", "Dec"],
                dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Xov", "Ven", "Sab"],
                dayOfWeek: ["Domingo", "Luns", "Martes", "Mércores", "Xoves", "Venres", "Sábado"]
            },
            hr: { //Hrvatski
                months: ["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"],
                dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
                dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
            },
            ko: { //Korean (한국어)
                months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
                dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
                dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
            },
            lt: { //Lithuanian (lietuvių)
                months: ["Sausio", "Vasario", "Kovo", "Balandžio", "Gegužės", "Birželio", "Liepos", "Rugpjūčio", "Rugsėjo", "Spalio", "Lapkričio", "Gruodžio"],
                dayOfWeekShort: ["Sek", "Pir", "Ant", "Tre", "Ket", "Pen", "Šeš"],
                dayOfWeek: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"]
            },
            lv: { //Latvian (Latviešu)
                months: ["Janvāris", "Februāris", "Marts", "Aprīlis ", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"],
                dayOfWeekShort: ["Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "St"],
                dayOfWeek: ["Svētdiena", "Pirmdiena", "Otrdiena", "Trešdiena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
            },
            mk: { //Macedonian (Македонски)
                months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
                dayOfWeekShort: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
                dayOfWeek: ["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"]
            },
            mn: { //Mongolian (Монгол)
                months: ["1-р сар", "2-р сар", "3-р сар", "4-р сар", "5-р сар", "6-р сар", "7-р сар", "8-р сар", "9-р сар", "10-р сар", "11-р сар", "12-р сар"],
                dayOfWeekShort: ["Дав", "Мяг", "Лха", "Пүр", "Бсн", "Бям", "Ням"],
                dayOfWeek: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
            },
            'pt-BR': { //Português(Brasil)
                months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
                dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
                dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
            },
            sk: { //Slovenčina
                months: ["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"],
                dayOfWeekShort: ["Ne", "Po", "Ut", "St", "Št", "Pi", "So"],
                dayOfWeek: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"]
            },
            sq: { //Albanian (Shqip)
                months: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"],
                dayOfWeekShort: ["Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Shtu"],
                dayOfWeek: ["E Diel", "E Hënë", "E Martē", "E Mërkurë", "E Enjte", "E Premte", "E Shtunë"]
            },
            'sr-YU': { //Serbian (Srpski)
                months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
                dayOfWeekShort: ["Ned", "Pon", "Uto", "Sre", "čet", "Pet", "Sub"],
                dayOfWeek: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"]
            },
            sr: { //Serbian Cyrillic (Српски)
                months: ["јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар"],
                dayOfWeekShort: ["нед", "пон", "уто", "сре", "чет", "пет", "суб"],
                dayOfWeek: ["Недеља", "Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"]
            },
            sv: { //Svenska
                months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
                dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
                dayOfWeek: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"]
            },
            'zh-TW': { //Traditional Chinese (繁體中文)
                months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
                dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
                dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
            },
            zh: { //Simplified Chinese (简体中文)
                months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
                dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
                dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
            },
            he: { //Hebrew (עברית)
                months: ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'],
                dayOfWeekShort: ['א\'', 'ב\'', 'ג\'', 'ד\'', 'ה\'', 'ו\'', 'שבת'],
                dayOfWeek: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת", "ראשון"]
            },
            hy: { // Armenian
                months: ["Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"],
                dayOfWeekShort: ["Կի", "Երկ", "Երք", "Չոր", "Հնգ", "Ուրբ", "Շբթ"],
                dayOfWeek: ["Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "Ուրբաթ", "Շաբաթ"]
            },
            kg: { // Kyrgyz
                months: ['Үчтүн айы', 'Бирдин айы', 'Жалган Куран', 'Чын Куран', 'Бугу', 'Кулжа', 'Теке', 'Баш Оона', 'Аяк Оона', 'Тогуздун айы', 'Жетинин айы', 'Бештин айы'],
                dayOfWeekShort: ["Жек", "Дүй", "Шей", "Шар", "Бей", "Жум", "Ише"],
                dayOfWeek: ["Жекшемб", "Дүйшөмб", "Шейшемб", "Шаршемб", "Бейшемби", "Жума", "Ишенб"]
            },
            rm: { // Romansh
                months: ["Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October", "November", "December"],
                dayOfWeekShort: ["Du", "Gli", "Ma", "Me", "Gie", "Ve", "So"],
                dayOfWeek: ["Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"]
            },
            ka: { // Georgian
                months: ['იანვარი', 'თებერვალი', 'მარტი', 'აპრილი', 'მაისი', 'ივნისი', 'ივლისი', 'აგვისტო', 'სექტემბერი', 'ოქტომბერი', 'ნოემბერი', 'დეკემბერი'],
                dayOfWeekShort: ["კვ", "ორშ", "სამშ", "ოთხ", "ხუთ", "პარ", "შაბ"],
                dayOfWeek: ["კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი"]
            }
        },
        value: '',
        rtl: false,

        format: 'Y/m/d H:i',
        formatTime: 'H:i',
        formatDate: 'Y/m/d',

        startDate: false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05',
        step: 60,
        monthChangeSpinner: true,

        closeOnDateSelect: false,
        closeOnTimeSelect: true,
        closeOnWithoutClick: true,
        closeOnInputClick: true,

        timepicker: true,
        datepicker: true,
        weeks: false,

        defaultTime: false, // use formatTime format (ex. '10:00' for formatTime:	'H:i')
        defaultDate: false, // use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')

        minDate: false,
        maxDate: false,
        minTime: false,
        maxTime: false,
        disabledMinTime: false,
        disabledMaxTime: false,

        allowTimes: [],
        opened: false,
        initTime: true,
        inline: false,
        theme: '',

        onSelectDate: function onSelectDate() {},
        onSelectTime: function onSelectTime() {},
        onChangeMonth: function onChangeMonth() {},
        onGetWeekOfYear: function onGetWeekOfYear() {},
        onChangeYear: function onChangeYear() {},
        onChangeDateTime: function onChangeDateTime() {},
        onShow: function onShow() {},
        onClose: function onClose() {},
        onGenerate: function onGenerate() {},

        withoutCopyright: true,
        inverseButton: false,
        hours12: false,
        next: 'xdsoft_next',
        prev: 'xdsoft_prev',
        dayOfWeekStart: 0,
        parentID: 'body',
        timeHeightInTimePicker: 25,
        timepickerScrollbar: true,
        todayButton: true,
        prevButton: true,
        nextButton: true,
        defaultSelect: true,

        scrollMonth: true,
        scrollTime: true,
        scrollInput: true,

        lazyInit: false,
        mask: false,
        validateOnBlur: true,
        allowBlank: true,
        yearStart: 1950,
        yearEnd: 2050,
        monthStart: 0,
        monthEnd: 11,
        style: '',
        id: '',
        fixed: false,
        roundTime: 'round', // ceil, floor
        className: '',
        weekends: [],
        highlightedDates: [],
        highlightedPeriods: [],
        allowDates: [],
        allowDateRe: null,
        disabledDates: [],
        disabledWeekDays: [],
        yearOffset: 0,
        beforeShowDay: null,

        enterLikeTab: true,
        showApplyButton: false
    };

    var dateHelper = null,
        globalLocaleDefault = 'en',
        globalLocale = 'en';

    var dateFormatterOptionsDefault = {
        meridiem: ['AM', 'PM']
    };

    var initDateFormatter = function initDateFormatter() {
        var locale = default_options.i18n[globalLocale],
            opts = {
            days: locale.dayOfWeek,
            daysShort: locale.dayOfWeekShort,
            months: locale.months,
            monthsShort: $.map(locale.months, function (n) {
                return n.substring(0, 3);
            })
        };

        dateHelper = new DateFormatter({
            dateSettings: $.extend({}, dateFormatterOptionsDefault, opts)
        });
    };

    // for locale settings
    $.datetimepicker = {
        setLocale: function setLocale(locale) {
            var newLocale = default_options.i18n[locale] ? locale : globalLocaleDefault;
            if (globalLocale != newLocale) {
                globalLocale = newLocale;
                // reinit date formatter
                initDateFormatter();
            }
        },
        setDateFormatter: function setDateFormatter(dateFormatter) {
            dateHelper = dateFormatter;
        },
        RFC_2822: 'D, d M Y H:i:s O',
        ATOM: 'Y-m-d\TH:i:sP',
        ISO_8601: 'Y-m-d\TH:i:sO',
        RFC_822: 'D, d M y H:i:s O',
        RFC_850: 'l, d-M-y H:i:s T',
        RFC_1036: 'D, d M y H:i:s O',
        RFC_1123: 'D, d M Y H:i:s O',
        RSS: 'D, d M Y H:i:s O',
        W3C: 'Y-m-d\TH:i:sP'
    };

    // first init date formatter
    initDateFormatter();

    // fix for ie8
    if (!window.getComputedStyle) {
        window.getComputedStyle = function (el, pseudo) {
            this.el = el;
            this.getPropertyValue = function (prop) {
                var re = /(\-([a-z]){1})/g;
                if (prop === 'float') {
                    prop = 'styleFloat';
                }
                if (re.test(prop)) {
                    prop = prop.replace(re, function (a, b, c) {
                        return c.toUpperCase();
                    });
                }
                return el.currentStyle[prop] || null;
            };
            return this;
        };
    }
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (obj, start) {
            var i, j;
            for (i = start || 0, j = this.length; i < j; i += 1) {
                if (this[i] === obj) {
                    return i;
                }
            }
            return -1;
        };
    }
    Date.prototype.countDaysInMonth = function () {
        return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
    };
    $.fn.xdsoftScroller = function (percent) {
        return this.each(function () {
            var timeboxparent = $(this),
                pointerEventToXY = function pointerEventToXY(e) {
                var out = { x: 0, y: 0 },
                    touch;
                if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
                    touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                    out.x = touch.clientX;
                    out.y = touch.clientY;
                } else if (e.type === 'mousedown' || e.type === 'mouseup' || e.type === 'mousemove' || e.type === 'mouseover' || e.type === 'mouseout' || e.type === 'mouseenter' || e.type === 'mouseleave') {
                    out.x = e.clientX;
                    out.y = e.clientY;
                }
                return out;
            },
                timebox,
                parentHeight,
                height,
                scrollbar,
                scroller,
                maximumOffset = 100,
                start = false,
                startY = 0,
                startTop = 0,
                h1 = 0,
                touchStart = false,
                startTopScroll = 0,
                calcOffset = function calcOffset() {};
            if (percent === 'hide') {
                timeboxparent.find('.xdsoft_scrollbar').hide();
                return;
            }
            if (!$(this).hasClass('xdsoft_scroller_box')) {
                timebox = timeboxparent.children().eq(0);
                parentHeight = timeboxparent[0].clientHeight;
                height = timebox[0].offsetHeight;
                scrollbar = $('<div class="xdsoft_scrollbar"></div>');
                scroller = $('<div class="xdsoft_scroller"></div>');
                scrollbar.append(scroller);

                timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);
                calcOffset = function calcOffset(event) {
                    var offset = pointerEventToXY(event).y - startY + startTopScroll;
                    if (offset < 0) {
                        offset = 0;
                    }
                    if (offset + scroller[0].offsetHeight > h1) {
                        offset = h1 - scroller[0].offsetHeight;
                    }
                    timeboxparent.trigger('scroll_element.xdsoft_scroller', [maximumOffset ? offset / maximumOffset : 0]);
                };

                scroller.on('touchstart.xdsoft_scroller mousedown.xdsoft_scroller', function (event) {
                    if (!parentHeight) {
                        timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
                    }

                    startY = pointerEventToXY(event).y;
                    startTopScroll = parseInt(scroller.css('margin-top'), 10);
                    h1 = scrollbar[0].offsetHeight;

                    if (event.type === 'mousedown' || event.type === 'touchstart') {
                        if (document) {
                            $(document.body).addClass('xdsoft_noselect');
                        }
                        $([document.body, window]).on('touchend mouseup.xdsoft_scroller', function arguments_callee() {
                            $([document.body, window]).off('touchend mouseup.xdsoft_scroller', arguments_callee).off('mousemove.xdsoft_scroller', calcOffset).removeClass('xdsoft_noselect');
                        });
                        $(document.body).on('mousemove.xdsoft_scroller', calcOffset);
                    } else {
                        touchStart = true;
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }).on('touchmove', function (event) {
                    if (touchStart) {
                        event.preventDefault();
                        calcOffset(event);
                    }
                }).on('touchend touchcancel', function () {
                    touchStart = false;
                    startTopScroll = 0;
                });

                timeboxparent.on('scroll_element.xdsoft_scroller', function (event, percentage) {
                    if (!parentHeight) {
                        timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percentage, true]);
                    }
                    percentage = percentage > 1 ? 1 : percentage < 0 || isNaN(percentage) ? 0 : percentage;

                    scroller.css('margin-top', maximumOffset * percentage);

                    setTimeout(function () {
                        timebox.css('marginTop', -parseInt((timebox[0].offsetHeight - parentHeight) * percentage, 10));
                    }, 10);
                }).on('resize_scroll.xdsoft_scroller', function (event, percentage, noTriggerScroll) {
                    var percent, sh;
                    parentHeight = timeboxparent[0].clientHeight;
                    height = timebox[0].offsetHeight;
                    percent = parentHeight / height;
                    sh = percent * scrollbar[0].offsetHeight;
                    if (percent > 1) {
                        scroller.hide();
                    } else {
                        scroller.show();
                        scroller.css('height', parseInt(sh > 10 ? sh : 10, 10));
                        maximumOffset = scrollbar[0].offsetHeight - scroller[0].offsetHeight;
                        if (noTriggerScroll !== true) {
                            timeboxparent.trigger('scroll_element.xdsoft_scroller', [percentage || Math.abs(parseInt(timebox.css('marginTop'), 10)) / (height - parentHeight)]);
                        }
                    }
                });

                timeboxparent.on('mousewheel', function (event) {
                    var top = Math.abs(parseInt(timebox.css('marginTop'), 10));

                    top = top - event.deltaY * 20;
                    if (top < 0) {
                        top = 0;
                    }

                    timeboxparent.trigger('scroll_element.xdsoft_scroller', [top / (height - parentHeight)]);
                    event.stopPropagation();
                    return false;
                });

                timeboxparent.on('touchstart', function (event) {
                    start = pointerEventToXY(event);
                    startTop = Math.abs(parseInt(timebox.css('marginTop'), 10));
                });

                timeboxparent.on('touchmove', function (event) {
                    if (start) {
                        event.preventDefault();
                        var coord = pointerEventToXY(event);
                        timeboxparent.trigger('scroll_element.xdsoft_scroller', [(startTop - (coord.y - start.y)) / (height - parentHeight)]);
                    }
                });

                timeboxparent.on('touchend touchcancel', function () {
                    start = false;
                    startTop = 0;
                });
            }
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
        });
    };

    $.fn.datetimepicker = function (opt, opt2) {
        var result = this,
            KEY0 = 48,
            KEY9 = 57,
            _KEY0 = 96,
            _KEY9 = 105,
            CTRLKEY = 17,
            DEL = 46,
            ENTER = 13,
            ESC = 27,
            BACKSPACE = 8,
            ARROWLEFT = 37,
            ARROWUP = 38,
            ARROWRIGHT = 39,
            ARROWDOWN = 40,
            TAB = 9,
            F5 = 116,
            AKEY = 65,
            CKEY = 67,
            VKEY = 86,
            ZKEY = 90,
            YKEY = 89,
            ctrlDown = false,
            options = $.isPlainObject(opt) || !opt ? $.extend(true, {}, default_options, opt) : $.extend(true, {}, default_options),
            lazyInitTimer = 0,
            createDateTimePicker,
            destroyDateTimePicker,
            lazyInit = function lazyInit(input) {
            input.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function initOnActionCallback() {
                if (input.is(':disabled') || input.data('xdsoft_datetimepicker')) {
                    return;
                }
                clearTimeout(lazyInitTimer);
                lazyInitTimer = setTimeout(function () {

                    if (!input.data('xdsoft_datetimepicker')) {
                        createDateTimePicker(input);
                    }
                    input.off('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', initOnActionCallback).trigger('open.xdsoft');
                }, 100);
            });
        };

        createDateTimePicker = function createDateTimePicker(input) {
            var datetimepicker = $('<div class="xdsoft_datetimepicker xdsoft_noselect"></div>'),
                xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
                datepicker = $('<div class="xdsoft_datepicker active"></div>'),
                mounth_picker = $('<div class="xdsoft_mounthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button>' + '<div class="xdsoft_label xdsoft_month"><span></span><i></i></div>' + '<div class="xdsoft_label xdsoft_year"><span></span><i></i></div>' + '<button type="button" class="xdsoft_next"></button></div>'),
                calendar = $('<div class="xdsoft_calendar"></div>'),
                timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
                timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
                timebox = $('<div class="xdsoft_time_variant"></div>'),
                applyButton = $('<button type="button" class="xdsoft_save_selected blue-gradient-button">Save Selected</button>'),
                monthselect = $('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
                yearselect = $('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>'),
                triggerAfterOpen = false,
                XDSoft_datetime,
                xchangeTimer,
                timerclick,
                current_time_index,
                setPos,
                timer = 0,
                _xdsoft_datetime,
                forEachAncestorOf;

            if (options.id) {
                datetimepicker.attr('id', options.id);
            }
            if (options.style) {
                datetimepicker.attr('style', options.style);
            }
            if (options.weeks) {
                datetimepicker.addClass('xdsoft_showweeks');
            }
            if (options.rtl) {
                datetimepicker.addClass('xdsoft_rtl');
            }

            datetimepicker.addClass('xdsoft_' + options.theme);
            datetimepicker.addClass(options.className);

            mounth_picker.find('.xdsoft_month span').after(monthselect);
            mounth_picker.find('.xdsoft_year span').after(yearselect);

            mounth_picker.find('.xdsoft_month,.xdsoft_year').on('touchstart mousedown.xdsoft', function (event) {
                var select = $(this).find('.xdsoft_select').eq(0),
                    val = 0,
                    top = 0,
                    visible = select.is(':visible'),
                    items,
                    i;

                mounth_picker.find('.xdsoft_select').hide();
                if (_xdsoft_datetime.currentTime) {
                    val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month') ? 'getMonth' : 'getFullYear']();
                }

                select[visible ? 'hide' : 'show']();
                for (items = select.find('div.xdsoft_option'), i = 0; i < items.length; i += 1) {
                    if (items.eq(i).data('value') === val) {
                        break;
                    } else {
                        top += items[0].offsetHeight;
                    }
                }

                select.xdsoftScroller(top / (select.children()[0].offsetHeight - select[0].clientHeight));
                event.stopPropagation();
                return false;
            });

            mounth_picker.find('.xdsoft_select').xdsoftScroller().on('touchstart mousedown.xdsoft', function (event) {
                event.stopPropagation();
                event.preventDefault();
            }).on('touchstart mousedown.xdsoft', '.xdsoft_option', function () {
                if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
                    _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                }

                var year = _xdsoft_datetime.currentTime.getFullYear();
                if (_xdsoft_datetime && _xdsoft_datetime.currentTime) {
                    _xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect') ? 'setMonth' : 'setFullYear']($(this).data('value'));
                }

                $(this).parent().parent().hide();

                datetimepicker.trigger('xchange.xdsoft');
                if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
                    options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                }

                if (year !== _xdsoft_datetime.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
                    options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                }
            });

            datetimepicker.getValue = function () {
                return _xdsoft_datetime.getCurrentTime();
            };

            datetimepicker.setOptions = function (_options) {
                var highlightedDates = {};

                options = $.extend(true, {}, options, _options);

                if (_options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length) {
                    options.allowTimes = $.extend(true, [], _options.allowTimes);
                }

                if (_options.weekends && $.isArray(_options.weekends) && _options.weekends.length) {
                    options.weekends = $.extend(true, [], _options.weekends);
                }

                if (_options.allowDates && $.isArray(_options.allowDates) && _options.allowDates.length) {
                    options.allowDates = $.extend(true, [], _options.allowDates);
                }

                if (_options.allowDateRe && Object.prototype.toString.call(_options.allowDateRe) === "[object String]") {
                    options.allowDateRe = new RegExp(_options.allowDateRe);
                }

                if (_options.highlightedDates && $.isArray(_options.highlightedDates) && _options.highlightedDates.length) {
                    $.each(_options.highlightedDates, function (index, value) {
                        var splitData = $.map(value.split(','), $.trim),
                            exDesc,
                            hDate = new HighlightedDate(dateHelper.parseDate(splitData[0], options.formatDate), splitData[1], splitData[2]),
                            // date, desc, style
                        keyDate = dateHelper.formatDate(hDate.date, options.formatDate);
                        if (highlightedDates[keyDate] !== undefined) {
                            exDesc = highlightedDates[keyDate].desc;
                            if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                                highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
                            }
                        } else {
                            highlightedDates[keyDate] = hDate;
                        }
                    });

                    options.highlightedDates = $.extend(true, [], highlightedDates);
                }

                if (_options.highlightedPeriods && $.isArray(_options.highlightedPeriods) && _options.highlightedPeriods.length) {
                    highlightedDates = $.extend(true, [], options.highlightedDates);
                    $.each(_options.highlightedPeriods, function (index, value) {
                        var dateTest, // start date
                        dateEnd, desc, hDate, keyDate, exDesc, style;
                        if ($.isArray(value)) {
                            dateTest = value[0];
                            dateEnd = value[1];
                            desc = value[2];
                            style = value[3];
                        } else {
                            var splitData = $.map(value.split(','), $.trim);
                            dateTest = dateHelper.parseDate(splitData[0], options.formatDate);
                            dateEnd = dateHelper.parseDate(splitData[1], options.formatDate);
                            desc = splitData[2];
                            style = splitData[3];
                        }

                        while (dateTest <= dateEnd) {
                            hDate = new HighlightedDate(dateTest, desc, style);
                            keyDate = dateHelper.formatDate(dateTest, options.formatDate);
                            dateTest.setDate(dateTest.getDate() + 1);
                            if (highlightedDates[keyDate] !== undefined) {
                                exDesc = highlightedDates[keyDate].desc;
                                if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                                    highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
                                }
                            } else {
                                highlightedDates[keyDate] = hDate;
                            }
                        }
                    });

                    options.highlightedDates = $.extend(true, [], highlightedDates);
                }

                if (_options.disabledDates && $.isArray(_options.disabledDates) && _options.disabledDates.length) {
                    options.disabledDates = $.extend(true, [], _options.disabledDates);
                }

                if (_options.disabledWeekDays && $.isArray(_options.disabledWeekDays) && _options.disabledWeekDays.length) {
                    options.disabledWeekDays = $.extend(true, [], _options.disabledWeekDays);
                }

                if ((options.open || options.opened) && !options.inline) {
                    input.trigger('open.xdsoft');
                }

                if (options.inline) {
                    triggerAfterOpen = true;
                    datetimepicker.addClass('xdsoft_inline');
                    input.after(datetimepicker).hide();
                }

                if (options.inverseButton) {
                    options.next = 'xdsoft_prev';
                    options.prev = 'xdsoft_next';
                }

                if (options.datepicker) {
                    datepicker.addClass('active');
                } else {
                    datepicker.removeClass('active');
                }

                if (options.timepicker) {
                    timepicker.addClass('active');
                } else {
                    timepicker.removeClass('active');
                }

                if (options.value) {
                    _xdsoft_datetime.setCurrentTime(options.value);
                    if (input && input.val) {
                        input.val(_xdsoft_datetime.str);
                    }
                }

                if (isNaN(options.dayOfWeekStart)) {
                    options.dayOfWeekStart = 0;
                } else {
                    options.dayOfWeekStart = parseInt(options.dayOfWeekStart, 10) % 7;
                }

                if (!options.timepickerScrollbar) {
                    timeboxparent.xdsoftScroller('hide');
                }

                if (options.minDate && /^[\+\-](.*)$/.test(options.minDate)) {
                    options.minDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.minDate), options.formatDate);
                }

                if (options.maxDate && /^[\+\-](.*)$/.test(options.maxDate)) {
                    options.maxDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.maxDate), options.formatDate);
                }

                applyButton.toggle(options.showApplyButton);

                mounth_picker.find('.xdsoft_today_button').css('visibility', !options.todayButton ? 'hidden' : 'visible');

                mounth_picker.find('.' + options.prev).css('visibility', !options.prevButton ? 'hidden' : 'visible');

                mounth_picker.find('.' + options.next).css('visibility', !options.nextButton ? 'hidden' : 'visible');

                setMask(options);

                if (options.validateOnBlur) {
                    input.off('blur.xdsoft').on('blur.xdsoft', function () {
                        if (options.allowBlank && (!$.trim($(this).val()).length || typeof options.mask == "string" && $.trim($(this).val()) === options.mask.replace(/[0-9]/g, '_'))) {
                            $(this).val(null);
                            datetimepicker.data('xdsoft_datetime').empty();
                        } else if (!dateHelper.parseDate($(this).val(), options.format)) {
                            var splittedHours = +[$(this).val()[0], $(this).val()[1]].join(''),
                                splittedMinutes = +[$(this).val()[2], $(this).val()[3]].join('');

                            // parse the numbers as 0312 => 03:12
                            if (!options.datepicker && options.timepicker && splittedHours >= 0 && splittedHours < 24 && splittedMinutes >= 0 && splittedMinutes < 60) {
                                $(this).val([splittedHours, splittedMinutes].map(function (item) {
                                    return item > 9 ? item : '0' + item;
                                }).join(':'));
                            } else {
                                $(this).val(dateHelper.formatDate(_xdsoft_datetime.now(), options.format));
                            }

                            datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
                        } else {
                            datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
                        }

                        datetimepicker.trigger('changedatetime.xdsoft');
                        datetimepicker.trigger('close.xdsoft');
                    });
                }
                options.dayOfWeekStartPrev = options.dayOfWeekStart === 0 ? 6 : options.dayOfWeekStart - 1;

                datetimepicker.trigger('xchange.xdsoft').trigger('afterOpen.xdsoft');
            };

            datetimepicker.data('options', options).on('touchstart mousedown.xdsoft', function (event) {
                event.stopPropagation();
                event.preventDefault();
                yearselect.hide();
                monthselect.hide();
                return false;
            });

            //scroll_element = timepicker.find('.xdsoft_time_box');
            timeboxparent.append(timebox);
            timeboxparent.xdsoftScroller();

            datetimepicker.on('afterOpen.xdsoft', function () {
                timeboxparent.xdsoftScroller();
            });

            datetimepicker.append(datepicker).append(timepicker);

            if (options.withoutCopyright !== true) {
                datetimepicker.append(xdsoft_copyright);
            }

            datepicker.append(mounth_picker).append(calendar).append(applyButton);

            $(options.parentID).append(datetimepicker);

            XDSoft_datetime = function XDSoft_datetime() {
                var _this = this;
                _this.now = function (norecursion) {
                    var d = new Date(),
                        date,
                        time;

                    if (!norecursion && options.defaultDate) {
                        date = _this.strToDateTime(options.defaultDate);
                        d.setFullYear(date.getFullYear());
                        d.setMonth(date.getMonth());
                        d.setDate(date.getDate());
                    }

                    if (options.yearOffset) {
                        d.setFullYear(d.getFullYear() + options.yearOffset);
                    }

                    if (!norecursion && options.defaultTime) {
                        time = _this.strtotime(options.defaultTime);
                        d.setHours(time.getHours());
                        d.setMinutes(time.getMinutes());
                    }
                    return d;
                };

                _this.isValidDate = function (d) {
                    if (Object.prototype.toString.call(d) !== "[object Date]") {
                        return false;
                    }
                    return !isNaN(d.getTime());
                };

                _this.setCurrentTime = function (dTime) {
                    _this.currentTime = typeof dTime === 'string' ? _this.strToDateTime(dTime) : _this.isValidDate(dTime) ? dTime : _this.now();
                    datetimepicker.trigger('xchange.xdsoft');
                };

                _this.empty = function () {
                    _this.currentTime = null;
                };

                _this.getCurrentTime = function (dTime) {
                    return _this.currentTime;
                };

                _this.nextMonth = function () {

                    if (_this.currentTime === undefined || _this.currentTime === null) {
                        _this.currentTime = _this.now();
                    }

                    var month = _this.currentTime.getMonth() + 1,
                        year;
                    if (month === 12) {
                        _this.currentTime.setFullYear(_this.currentTime.getFullYear() + 1);
                        month = 0;
                    }

                    year = _this.currentTime.getFullYear();

                    _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));
                    _this.currentTime.setMonth(month);

                    if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
                        options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }

                    if (year !== _this.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
                        options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }

                    datetimepicker.trigger('xchange.xdsoft');
                    return month;
                };

                _this.prevMonth = function () {

                    if (_this.currentTime === undefined || _this.currentTime === null) {
                        _this.currentTime = _this.now();
                    }

                    var month = _this.currentTime.getMonth() - 1;
                    if (month === -1) {
                        _this.currentTime.setFullYear(_this.currentTime.getFullYear() - 1);
                        month = 11;
                    }
                    _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));
                    _this.currentTime.setMonth(month);
                    if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
                        options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }
                    datetimepicker.trigger('xchange.xdsoft');
                    return month;
                };

                _this.getWeekOfYear = function (datetime) {
                    if (options.onGetWeekOfYear && $.isFunction(options.onGetWeekOfYear)) {
                        var week = options.onGetWeekOfYear.call(datetimepicker, datetime);
                        if (typeof week !== 'undefined') {
                            return week;
                        }
                    }
                    var onejan = new Date(datetime.getFullYear(), 0, 1);
                    //First week of the year is th one with the first Thursday according to ISO8601
                    if (onejan.getDay() != 4) onejan.setMonth(0, 1 + (4 - onejan.getDay() + 7) % 7);
                    return Math.ceil(((datetime - onejan) / 86400000 + onejan.getDay() + 1) / 7);
                };

                _this.strToDateTime = function (sDateTime) {
                    var tmpDate = [],
                        timeOffset,
                        currentTime;

                    if (sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime)) {
                        return sDateTime;
                    }

                    tmpDate = /^(\+|\-)(.*)$/.exec(sDateTime);
                    if (tmpDate) {
                        tmpDate[2] = dateHelper.parseDate(tmpDate[2], options.formatDate);
                    }
                    if (tmpDate && tmpDate[2]) {
                        timeOffset = tmpDate[2].getTime() - tmpDate[2].getTimezoneOffset() * 60000;
                        currentTime = new Date(_this.now(true).getTime() + parseInt(tmpDate[1] + '1', 10) * timeOffset);
                    } else {
                        currentTime = sDateTime ? dateHelper.parseDate(sDateTime, options.format) : _this.now();
                    }

                    if (!_this.isValidDate(currentTime)) {
                        currentTime = _this.now();
                    }

                    return currentTime;
                };

                _this.strToDate = function (sDate) {
                    if (sDate && sDate instanceof Date && _this.isValidDate(sDate)) {
                        return sDate;
                    }

                    var currentTime = sDate ? dateHelper.parseDate(sDate, options.formatDate) : _this.now(true);
                    if (!_this.isValidDate(currentTime)) {
                        currentTime = _this.now(true);
                    }
                    return currentTime;
                };

                _this.strtotime = function (sTime) {
                    if (sTime && sTime instanceof Date && _this.isValidDate(sTime)) {
                        return sTime;
                    }
                    var currentTime = sTime ? dateHelper.parseDate(sTime, options.formatTime) : _this.now(true);
                    if (!_this.isValidDate(currentTime)) {
                        currentTime = _this.now(true);
                    }
                    return currentTime;
                };

                _this.str = function () {
                    return dateHelper.formatDate(_this.currentTime, options.format);
                };
                _this.currentTime = this.now();
            };

            _xdsoft_datetime = new XDSoft_datetime();

            applyButton.on('touchend click', function (e) {
                //pathbrite
                e.preventDefault();
                datetimepicker.data('changed', true);
                _xdsoft_datetime.setCurrentTime(getCurrentValue());
                input.val(_xdsoft_datetime.str());
                datetimepicker.trigger('close.xdsoft');
            });
            mounth_picker.find('.xdsoft_today_button').on('touchend mousedown.xdsoft', function () {
                datetimepicker.data('changed', true);
                _xdsoft_datetime.setCurrentTime(0);
                datetimepicker.trigger('afterOpen.xdsoft');
            }).on('dblclick.xdsoft', function () {
                var currentDate = _xdsoft_datetime.getCurrentTime(),
                    minDate,
                    maxDate;
                currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                minDate = _xdsoft_datetime.strToDate(options.minDate);
                minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
                if (currentDate < minDate) {
                    return;
                }
                maxDate = _xdsoft_datetime.strToDate(options.maxDate);
                maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
                if (currentDate > maxDate) {
                    return;
                }
                input.val(_xdsoft_datetime.str());
                input.trigger('change');
                datetimepicker.trigger('close.xdsoft');
            });
            mounth_picker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
                var $this = $(this),
                    timer = 0,
                    stop = false;

                (function arguments_callee1(v) {
                    if ($this.hasClass(options.next)) {
                        _xdsoft_datetime.nextMonth();
                    } else if ($this.hasClass(options.prev)) {
                        _xdsoft_datetime.prevMonth();
                    }
                    if (options.monthChangeSpinner) {
                        if (!stop) {
                            timer = setTimeout(arguments_callee1, v || 100);
                        }
                    }
                })(500);

                $([document.body, window]).on('touchend mouseup.xdsoft', function arguments_callee2() {
                    clearTimeout(timer);
                    stop = true;
                    $([document.body, window]).off('touchend mouseup.xdsoft', arguments_callee2);
                });
            });

            timepicker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
                var $this = $(this),
                    timer = 0,
                    stop = false,
                    period = 110;
                (function arguments_callee4(v) {
                    var pheight = timeboxparent[0].clientHeight,
                        height = timebox[0].offsetHeight,
                        top = Math.abs(parseInt(timebox.css('marginTop'), 10));
                    if ($this.hasClass(options.next) && height - pheight - options.timeHeightInTimePicker >= top) {
                        timebox.css('marginTop', '-' + (top + options.timeHeightInTimePicker) + 'px');
                    } else if ($this.hasClass(options.prev) && top - options.timeHeightInTimePicker >= 0) {
                        timebox.css('marginTop', '-' + (top - options.timeHeightInTimePicker) + 'px');
                    }
                    /**
                     * Fixed bug:
                     * When using css3 transition, it will cause a bug that you cannot scroll the timepicker list.
                     * The reason is that the transition-duration time, if you set it to 0, all things fine, otherwise, this
                     * would cause a bug when you use jquery.css method.
                     * Let's say: * { transition: all .5s ease; }
                     * jquery timebox.css('marginTop') will return the original value which is before you clicking the next/prev button,
                     * meanwhile the timebox[0].style.marginTop will return the right value which is after you clicking the
                     * next/prev button.
                     *
                     * What we should do:
                     * Replace timebox.css('marginTop') with timebox[0].style.marginTop.
                     */
                    timeboxparent.trigger('scroll_element.xdsoft_scroller', [Math.abs(parseInt(timebox[0].style.marginTop, 10) / (height - pheight))]);
                    period = period > 10 ? 10 : period - 10;
                    if (!stop) {
                        timer = setTimeout(arguments_callee4, v || period);
                    }
                })(500);
                $([document.body, window]).on('touchend mouseup.xdsoft', function arguments_callee5() {
                    clearTimeout(timer);
                    stop = true;
                    $([document.body, window]).off('touchend mouseup.xdsoft', arguments_callee5);
                });
            });

            xchangeTimer = 0;
            // base handler - generating a calendar and timepicker
            datetimepicker.on('xchange.xdsoft', function (event) {
                clearTimeout(xchangeTimer);
                xchangeTimer = setTimeout(function () {

                    if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
                        _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                    }

                    var table = '',
                        start = new Date(_xdsoft_datetime.currentTime.getFullYear(), _xdsoft_datetime.currentTime.getMonth(), 1, 12, 0, 0),
                        i = 0,
                        j,
                        today = _xdsoft_datetime.now(),
                        maxDate = false,
                        minDate = false,
                        hDate,
                        day,
                        d,
                        y,
                        m,
                        w,
                        classes = [],
                        customDateSettings,
                        newRow = true,
                        time = '',
                        h = '',
                        line_time,
                        description;

                    while (start.getDay() !== options.dayOfWeekStart) {
                        start.setDate(start.getDate() - 1);
                    }

                    table += '<table><thead><tr>';

                    if (options.weeks) {
                        table += '<th></th>';
                    }

                    for (j = 0; j < 7; j += 1) {
                        table += '<th>' + options.i18n[globalLocale].dayOfWeekShort[(j + options.dayOfWeekStart) % 7] + '</th>';
                    }

                    table += '</tr></thead>';
                    table += '<tbody>';

                    if (options.maxDate !== false) {
                        maxDate = _xdsoft_datetime.strToDate(options.maxDate);
                        maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate(), 23, 59, 59, 999);
                    }

                    if (options.minDate !== false) {
                        minDate = _xdsoft_datetime.strToDate(options.minDate);
                        minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
                    }

                    while (i < _xdsoft_datetime.currentTime.countDaysInMonth() || start.getDay() !== options.dayOfWeekStart || _xdsoft_datetime.currentTime.getMonth() === start.getMonth()) {
                        classes = [];
                        i += 1;

                        day = start.getDay();
                        d = start.getDate();
                        y = start.getFullYear();
                        m = start.getMonth();
                        w = _xdsoft_datetime.getWeekOfYear(start);
                        description = '';

                        classes.push('xdsoft_date');

                        if (options.beforeShowDay && $.isFunction(options.beforeShowDay.call)) {
                            customDateSettings = options.beforeShowDay.call(datetimepicker, start);
                        } else {
                            customDateSettings = null;
                        }

                        if (options.allowDateRe && Object.prototype.toString.call(options.allowDateRe) === "[object RegExp]") {
                            if (!options.allowDateRe.test(dateHelper.formatDate(start, options.formatDate))) {
                                classes.push('xdsoft_disabled');
                            }
                        } else if (options.allowDates && options.allowDates.length > 0) {
                            if (options.allowDates.indexOf(dateHelper.formatDate(start, options.formatDate)) === -1) {
                                classes.push('xdsoft_disabled');
                            }
                        } else if (maxDate !== false && start > maxDate || minDate !== false && start < minDate || customDateSettings && customDateSettings[0] === false) {
                            classes.push('xdsoft_disabled');
                        } else if (options.disabledDates.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
                            classes.push('xdsoft_disabled');
                        } else if (options.disabledWeekDays.indexOf(day) !== -1) {
                            classes.push('xdsoft_disabled');
                        } else if (input.is('[readonly]')) {
                            classes.push('xdsoft_disabled');
                        }

                        if (customDateSettings && customDateSettings[1] !== "") {
                            classes.push(customDateSettings[1]);
                        }

                        if (_xdsoft_datetime.currentTime.getMonth() !== m) {
                            classes.push('xdsoft_other_month');
                        }

                        if ((options.defaultSelect || datetimepicker.data('changed')) && dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
                            classes.push('xdsoft_current');
                        }

                        if (dateHelper.formatDate(today, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
                            classes.push('xdsoft_today');
                        }

                        if (start.getDay() === 0 || start.getDay() === 6 || options.weekends.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
                            classes.push('xdsoft_weekend');
                        }

                        if (options.highlightedDates[dateHelper.formatDate(start, options.formatDate)] !== undefined) {
                            hDate = options.highlightedDates[dateHelper.formatDate(start, options.formatDate)];
                            classes.push(hDate.style === undefined ? 'xdsoft_highlighted_default' : hDate.style);
                            description = hDate.desc === undefined ? '' : hDate.desc;
                        }

                        if (options.beforeShowDay && $.isFunction(options.beforeShowDay)) {
                            classes.push(options.beforeShowDay(start));
                        }

                        if (newRow) {
                            table += '<tr>';
                            newRow = false;
                            if (options.weeks) {
                                table += '<th>' + w + '</th>';
                            }
                        }

                        table += '<td data-date="' + d + '" data-month="' + m + '" data-year="' + y + '"' + ' class="xdsoft_date xdsoft_day_of_week' + start.getDay() + ' ' + classes.join(' ') + '" title="' + description + '">' + '<div>' + d + '</div>' + '</td>';

                        if (start.getDay() === options.dayOfWeekStartPrev) {
                            table += '</tr>';
                            newRow = true;
                        }

                        start.setDate(d + 1);
                    }
                    table += '</tbody></table>';

                    calendar.html(table);

                    mounth_picker.find('.xdsoft_label span').eq(0).text(options.i18n[globalLocale].months[_xdsoft_datetime.currentTime.getMonth()]);
                    mounth_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear());

                    // generate timebox
                    time = '';
                    h = '';
                    m = '';

                    line_time = function line_time(h, m) {
                        var now = _xdsoft_datetime.now(),
                            optionDateTime,
                            current_time,
                            isALlowTimesInit = options.allowTimes && $.isArray(options.allowTimes) && options.allowTimes.length;
                        now.setHours(h);
                        h = parseInt(now.getHours(), 10);
                        now.setMinutes(m);
                        m = parseInt(now.getMinutes(), 10);
                        optionDateTime = new Date(_xdsoft_datetime.currentTime);
                        optionDateTime.setHours(h);
                        optionDateTime.setMinutes(m);
                        classes = [];
                        if (options.minDateTime !== false && options.minDateTime > optionDateTime || options.maxTime !== false && _xdsoft_datetime.strtotime(options.maxTime).getTime() < now.getTime() || options.minTime !== false && _xdsoft_datetime.strtotime(options.minTime).getTime() > now.getTime()) {
                            classes.push('xdsoft_disabled');
                        } else if (options.minDateTime !== false && options.minDateTime > optionDateTime || options.disabledMinTime !== false && now.getTime() > _xdsoft_datetime.strtotime(options.disabledMinTime).getTime() && options.disabledMaxTime !== false && now.getTime() < _xdsoft_datetime.strtotime(options.disabledMaxTime).getTime()) {
                            classes.push('xdsoft_disabled');
                        } else if (input.is('[readonly]')) {
                            classes.push('xdsoft_disabled');
                        }

                        current_time = new Date(_xdsoft_datetime.currentTime);
                        current_time.setHours(parseInt(_xdsoft_datetime.currentTime.getHours(), 10));

                        if (!isALlowTimesInit) {
                            current_time.setMinutes(Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes() / options.step) * options.step);
                        }

                        if ((options.initTime || options.defaultSelect || datetimepicker.data('changed')) && current_time.getHours() === parseInt(h, 10) && (!isALlowTimesInit && options.step > 59 || current_time.getMinutes() === parseInt(m, 10))) {
                            if (options.defaultSelect || datetimepicker.data('changed')) {
                                classes.push('xdsoft_current');
                            } else if (options.initTime) {
                                classes.push('xdsoft_init_time');
                            }
                        }
                        if (parseInt(today.getHours(), 10) === parseInt(h, 10) && parseInt(today.getMinutes(), 10) === parseInt(m, 10)) {
                            classes.push('xdsoft_today');
                        }
                        time += '<div class="xdsoft_time ' + classes.join(' ') + '" data-hour="' + h + '" data-minute="' + m + '">' + dateHelper.formatDate(now, options.formatTime) + '</div>';
                    };

                    if (!options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length) {
                        for (i = 0, j = 0; i < (options.hours12 ? 12 : 24); i += 1) {
                            for (j = 0; j < 60; j += options.step) {
                                h = (i < 10 ? '0' : '') + i;
                                m = (j < 10 ? '0' : '') + j;
                                line_time(h, m);
                            }
                        }
                    } else {
                        for (i = 0; i < options.allowTimes.length; i += 1) {
                            h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
                            m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
                            line_time(h, m);
                        }
                    }

                    timebox.html(time);

                    opt = '';
                    i = 0;

                    for (i = parseInt(options.yearStart, 10) + options.yearOffset; i <= parseInt(options.yearEnd, 10) + options.yearOffset; i += 1) {
                        opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getFullYear() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + i + '</div>';
                    }
                    yearselect.children().eq(0).html(opt);

                    for (i = parseInt(options.monthStart, 10), opt = ''; i <= parseInt(options.monthEnd, 10); i += 1) {
                        opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getMonth() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + options.i18n[globalLocale].months[i] + '</div>';
                    }
                    monthselect.children().eq(0).html(opt);
                    $(datetimepicker).trigger('generate.xdsoft');
                }, 10);
                event.stopPropagation();
            }).on('afterOpen.xdsoft', function () {
                if (options.timepicker) {
                    var classType, pheight, height, top;
                    if (timebox.find('.xdsoft_current').length) {
                        classType = '.xdsoft_current';
                    } else if (timebox.find('.xdsoft_init_time').length) {
                        classType = '.xdsoft_init_time';
                    }
                    if (classType) {
                        pheight = timeboxparent[0].clientHeight;
                        height = timebox[0].offsetHeight;
                        top = timebox.find(classType).index() * options.timeHeightInTimePicker + 1;
                        if (height - pheight < top) {
                            top = height - pheight;
                        }
                        timeboxparent.trigger('scroll_element.xdsoft_scroller', [parseInt(top, 10) / (height - pheight)]);
                    } else {
                        timeboxparent.trigger('scroll_element.xdsoft_scroller', [0]);
                    }
                }
            });

            timerclick = 0;
            calendar.on('touchend click.xdsoft', 'td', function (xdevent) {
                xdevent.stopPropagation(); // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap
                timerclick += 1;
                var $this = $(this),
                    currentTime = _xdsoft_datetime.currentTime;

                if (currentTime === undefined || currentTime === null) {
                    _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                    currentTime = _xdsoft_datetime.currentTime;
                }

                if ($this.hasClass('xdsoft_disabled')) {
                    return false;
                }

                currentTime.setDate(1);
                currentTime.setFullYear($this.data('year'));
                currentTime.setMonth($this.data('month'));
                currentTime.setDate($this.data('date'));

                datetimepicker.trigger('select.xdsoft', [currentTime]);

                input.val(_xdsoft_datetime.str());

                if (options.onSelectDate && $.isFunction(options.onSelectDate)) {
                    options.onSelectDate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
                }

                datetimepicker.data('changed', true);
                datetimepicker.trigger('xchange.xdsoft');
                datetimepicker.trigger('changedatetime.xdsoft');
                if ((timerclick > 1 || options.closeOnDateSelect === true || options.closeOnDateSelect === false && !options.timepicker) && !options.inline) {
                    datetimepicker.trigger('close.xdsoft');
                }
                setTimeout(function () {
                    timerclick = 0;
                }, 200);
            });

            timebox.on('touchend click.xdsoft', 'div', function (xdevent) {
                xdevent.stopPropagation();
                var $this = $(this),
                    currentTime = _xdsoft_datetime.currentTime;

                if (currentTime === undefined || currentTime === null) {
                    _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                    currentTime = _xdsoft_datetime.currentTime;
                }

                if ($this.hasClass('xdsoft_disabled')) {
                    return false;
                }
                currentTime.setHours($this.data('hour'));
                currentTime.setMinutes($this.data('minute'));
                datetimepicker.trigger('select.xdsoft', [currentTime]);

                datetimepicker.data('input').val(_xdsoft_datetime.str());

                if (options.onSelectTime && $.isFunction(options.onSelectTime)) {
                    options.onSelectTime.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
                }
                datetimepicker.data('changed', true);
                datetimepicker.trigger('xchange.xdsoft');
                datetimepicker.trigger('changedatetime.xdsoft');
                if (options.inline !== true && options.closeOnTimeSelect === true) {
                    datetimepicker.trigger('close.xdsoft');
                }
            });

            datepicker.on('mousewheel.xdsoft', function (event) {
                if (!options.scrollMonth) {
                    return true;
                }
                if (event.deltaY < 0) {
                    _xdsoft_datetime.nextMonth();
                } else {
                    _xdsoft_datetime.prevMonth();
                }
                return false;
            });

            input.on('mousewheel.xdsoft', function (event) {
                if (!options.scrollInput) {
                    return true;
                }
                if (!options.datepicker && options.timepicker) {
                    current_time_index = timebox.find('.xdsoft_current').length ? timebox.find('.xdsoft_current').eq(0).index() : 0;
                    if (current_time_index + event.deltaY >= 0 && current_time_index + event.deltaY < timebox.children().length) {
                        current_time_index += event.deltaY;
                    }
                    if (timebox.children().eq(current_time_index).length) {
                        timebox.children().eq(current_time_index).trigger('mousedown');
                    }
                    return false;
                }
                if (options.datepicker && !options.timepicker) {
                    datepicker.trigger(event, [event.deltaY, event.deltaX, event.deltaY]);
                    if (input.val) {
                        input.val(_xdsoft_datetime.str());
                    }
                    datetimepicker.trigger('changedatetime.xdsoft');
                    return false;
                }
            });

            datetimepicker.on('changedatetime.xdsoft', function (event) {
                if (options.onChangeDateTime && $.isFunction(options.onChangeDateTime)) {
                    var $input = datetimepicker.data('input');
                    options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input, event);
                    delete options.value;
                    $input.trigger('change');
                }
            }).on('generate.xdsoft', function () {
                if (options.onGenerate && $.isFunction(options.onGenerate)) {
                    options.onGenerate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                }
                if (triggerAfterOpen) {
                    datetimepicker.trigger('afterOpen.xdsoft');
                    triggerAfterOpen = false;
                }
            }).on('click.xdsoft', function (xdevent) {
                xdevent.stopPropagation();
            });

            current_time_index = 0;

            /**
             * Runs the callback for each of the specified node's ancestors.
             *
             * Return FALSE from the callback to stop ascending.
             *
             * @param {DOMNode} node
             * @param {Function} callback
             * @returns {undefined}
             */
            forEachAncestorOf = function forEachAncestorOf(node, callback) {
                do {
                    node = node.parentNode;

                    if (callback(node) === false) {
                        break;
                    }
                } while (node.nodeName !== 'HTML');
            };

            /**
             * Sets the position of the picker.
             *
             * @returns {undefined}
             */
            setPos = function setPos() {
                var dateInputOffset, dateInputElem, verticalPosition, left, position, datetimepickerElem, dateInputHasFixedAncestor, $dateInput, windowWidth, verticalAnchorEdge, datetimepickerCss, windowHeight, windowScrollTop;

                $dateInput = datetimepicker.data('input');
                dateInputOffset = $dateInput.offset();
                dateInputElem = $dateInput[0];

                verticalAnchorEdge = 'top';
                verticalPosition = dateInputOffset.top + dateInputElem.offsetHeight - 1;
                left = dateInputOffset.left;
                position = "absolute";

                windowWidth = $(window).width();
                windowHeight = $(window).height();
                windowScrollTop = $(window).scrollTop();

                if (document.documentElement.clientWidth - dateInputOffset.left < datepicker.parent().outerWidth(true)) {
                    var diff = datepicker.parent().outerWidth(true) - dateInputElem.offsetWidth;
                    left = left - diff;
                }

                if ($dateInput.parent().css('direction') === 'rtl') {
                    left -= datetimepicker.outerWidth() - $dateInput.outerWidth();
                }

                if (options.fixed) {
                    verticalPosition -= windowScrollTop;
                    left -= $(window).scrollLeft();
                    position = "fixed";
                } else {
                    dateInputHasFixedAncestor = false;

                    forEachAncestorOf(dateInputElem, function (ancestorNode) {
                        if (window.getComputedStyle(ancestorNode).getPropertyValue('position') === 'fixed') {
                            dateInputHasFixedAncestor = true;
                            return false;
                        }
                    });

                    if (dateInputHasFixedAncestor) {
                        position = 'fixed';

                        //If the picker won't fit entirely within the viewport then display it above the date input.
                        if (verticalPosition + datetimepicker.outerHeight() > windowHeight + windowScrollTop) {
                            verticalAnchorEdge = 'bottom';
                            verticalPosition = windowHeight + windowScrollTop - dateInputOffset.top;
                        } else {
                            verticalPosition -= windowScrollTop;
                        }
                    } else {
                        if (verticalPosition + dateInputElem.offsetHeight > windowHeight + windowScrollTop) {
                            verticalPosition = dateInputOffset.top - dateInputElem.offsetHeight + 1;
                        }
                    }

                    if (verticalPosition < 0) {
                        verticalPosition = 0;
                    }

                    if (left + dateInputElem.offsetWidth > windowWidth) {
                        left = windowWidth - dateInputElem.offsetWidth;
                    }
                }

                datetimepickerElem = datetimepicker[0];

                forEachAncestorOf(datetimepickerElem, function (ancestorNode) {
                    var ancestorNodePosition;

                    ancestorNodePosition = window.getComputedStyle(ancestorNode).getPropertyValue('position');

                    if (ancestorNodePosition === 'relative' && windowWidth >= ancestorNode.offsetWidth) {
                        left = left - (windowWidth - ancestorNode.offsetWidth) / 2;
                        return false;
                    }
                });

                datetimepickerCss = {
                    position: position,
                    left: left,
                    top: '', //Initialize to prevent previous values interfering with new ones.
                    bottom: '' //Initialize to prevent previous values interfering with new ones.
                };

                datetimepickerCss[verticalAnchorEdge] = verticalPosition;

                datetimepicker.css(datetimepickerCss);
            };

            datetimepicker.on('open.xdsoft', function (event) {
                var onShow = true;
                if (options.onShow && $.isFunction(options.onShow)) {
                    onShow = options.onShow.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
                }
                if (onShow !== false) {
                    datetimepicker.show();
                    setPos();
                    $(window).off('resize.xdsoft', setPos).on('resize.xdsoft', setPos);

                    if (options.closeOnWithoutClick) {
                        $([document.body, window]).on('touchstart mousedown.xdsoft', function arguments_callee6() {
                            datetimepicker.trigger('close.xdsoft');
                            $([document.body, window]).off('touchstart mousedown.xdsoft', arguments_callee6);
                        });
                    }
                }
            }).on('close.xdsoft', function (event) {
                var onClose = true;
                mounth_picker.find('.xdsoft_month,.xdsoft_year').find('.xdsoft_select').hide();
                if (options.onClose && $.isFunction(options.onClose)) {
                    onClose = options.onClose.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
                }
                if (onClose !== false && !options.opened && !options.inline) {
                    datetimepicker.hide();
                }
                event.stopPropagation();
            }).on('toggle.xdsoft', function () {
                if (datetimepicker.is(':visible')) {
                    datetimepicker.trigger('close.xdsoft');
                } else {
                    datetimepicker.trigger('open.xdsoft');
                }
            }).data('input', input);

            timer = 0;

            datetimepicker.data('xdsoft_datetime', _xdsoft_datetime);
            datetimepicker.setOptions(options);

            function getCurrentValue() {
                var ct = false,
                    time;

                if (options.startDate) {
                    ct = _xdsoft_datetime.strToDate(options.startDate);
                } else {
                    ct = options.value || (input && input.val && input.val() ? input.val() : '');
                    if (ct) {
                        ct = _xdsoft_datetime.strToDateTime(ct);
                    } else if (options.defaultDate) {
                        ct = _xdsoft_datetime.strToDateTime(options.defaultDate);
                        if (options.defaultTime) {
                            time = _xdsoft_datetime.strtotime(options.defaultTime);
                            ct.setHours(time.getHours());
                            ct.setMinutes(time.getMinutes());
                        }
                    }
                }

                if (ct && _xdsoft_datetime.isValidDate(ct)) {
                    datetimepicker.data('changed', true);
                } else {
                    ct = '';
                }

                return ct || 0;
            }

            function setMask(options) {

                var isValidValue = function isValidValue(mask, value) {
                    var reg = mask.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, '\\$1').replace(/_/g, '{digit+}').replace(/([0-9]{1})/g, '{digit$1}').replace(/\{digit([0-9]{1})\}/g, '[0-$1_]{1}').replace(/\{digit[\+]\}/g, '[0-9_]{1}');
                    return new RegExp(reg).test(value);
                },
                    getCaretPos = function getCaretPos(input) {
                    try {
                        if (document.selection && document.selection.createRange) {
                            var range = document.selection.createRange();
                            return range.getBookmark().charCodeAt(2) - 2;
                        }
                        if (input.setSelectionRange) {
                            return input.selectionStart;
                        }
                    } catch (e) {
                        return 0;
                    }
                },
                    setCaretPos = function setCaretPos(node, pos) {
                    node = typeof node === "string" || node instanceof String ? document.getElementById(node) : node;
                    if (!node) {
                        return false;
                    }
                    if (node.createTextRange) {
                        var textRange = node.createTextRange();
                        textRange.collapse(true);
                        textRange.moveEnd('character', pos);
                        textRange.moveStart('character', pos);
                        textRange.select();
                        return true;
                    }
                    if (node.setSelectionRange) {
                        node.setSelectionRange(pos, pos);
                        return true;
                    }
                    return false;
                };
                if (options.mask) {
                    input.off('keydown.xdsoft');
                }
                if (options.mask === true) {
                    if (typeof moment != 'undefined') {
                        options.mask = options.format.replace(/Y{4}/g, '9999').replace(/Y{2}/g, '99').replace(/M{2}/g, '19').replace(/D{2}/g, '39').replace(/H{2}/g, '29').replace(/m{2}/g, '59').replace(/s{2}/g, '59');
                    } else {
                        options.mask = options.format.replace(/Y/g, '9999').replace(/F/g, '9999').replace(/m/g, '19').replace(/d/g, '39').replace(/H/g, '29').replace(/i/g, '59').replace(/s/g, '59');
                    }
                }

                if ($.type(options.mask) === 'string') {
                    if (!isValidValue(options.mask, input.val())) {
                        input.val(options.mask.replace(/[0-9]/g, '_'));
                        setCaretPos(input[0], 0);
                    }

                    input.on('keydown.xdsoft', function (event) {
                        var val = this.value,
                            key = event.which,
                            pos,
                            digit;

                        if (key >= KEY0 && key <= KEY9 || key >= _KEY0 && key <= _KEY9 || key === BACKSPACE || key === DEL) {
                            pos = getCaretPos(this);
                            digit = key !== BACKSPACE && key !== DEL ? String.fromCharCode(_KEY0 <= key && key <= _KEY9 ? key - KEY0 : key) : '_';

                            if ((key === BACKSPACE || key === DEL) && pos) {
                                pos -= 1;
                                digit = '_';
                            }

                            while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
                                pos += key === BACKSPACE || key === DEL ? -1 : 1;
                            }

                            val = val.substr(0, pos) + digit + val.substr(pos + 1);
                            if ($.trim(val) === '') {
                                val = options.mask.replace(/[0-9]/g, '_');
                            } else {
                                if (pos === options.mask.length) {
                                    event.preventDefault();
                                    return false;
                                }
                            }

                            pos += key === BACKSPACE || key === DEL ? 0 : 1;
                            while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
                                pos += key === BACKSPACE || key === DEL ? -1 : 1;
                            }

                            if (isValidValue(options.mask, val)) {
                                this.value = val;
                                setCaretPos(this, pos);
                            } else if ($.trim(val) === '') {
                                this.value = options.mask.replace(/[0-9]/g, '_');
                            } else {
                                input.trigger('error_input.xdsoft');
                            }
                        } else {
                            if ([AKEY, CKEY, VKEY, ZKEY, YKEY].indexOf(key) !== -1 && ctrlDown || [ESC, ARROWUP, ARROWDOWN, ARROWLEFT, ARROWRIGHT, F5, CTRLKEY, TAB, ENTER].indexOf(key) !== -1) {
                                return true;
                            }
                        }

                        event.preventDefault();
                        return false;
                    });
                }
            }

            _xdsoft_datetime.setCurrentTime(getCurrentValue());

            input.data('xdsoft_datetimepicker', datetimepicker).on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function () {
                if (input.is(':disabled') || input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick) {
                    return;
                }
                clearTimeout(timer);
                timer = setTimeout(function () {
                    if (input.is(':disabled')) {
                        return;
                    }

                    triggerAfterOpen = true;
                    _xdsoft_datetime.setCurrentTime(getCurrentValue());
                    if (options.mask) {
                        setMask(options);
                    }
                    datetimepicker.trigger('open.xdsoft');
                }, 100);
            }).on('keydown.xdsoft', function (event) {
                var elementSelector,
                    key = event.which;
                if ([ENTER].indexOf(key) !== -1 && options.enterLikeTab) {
                    elementSelector = $("input:visible,textarea:visible,button:visible,a:visible");
                    datetimepicker.trigger('close.xdsoft');
                    elementSelector.eq(elementSelector.index(this) + 1).focus();
                    return false;
                }
                if ([TAB].indexOf(key) !== -1) {
                    datetimepicker.trigger('close.xdsoft');
                    return true;
                }
            }).on('blur.xdsoft', function () {
                datetimepicker.trigger('close.xdsoft');
            });
        };
        destroyDateTimePicker = function destroyDateTimePicker(input) {
            var datetimepicker = input.data('xdsoft_datetimepicker');
            if (datetimepicker) {
                datetimepicker.data('xdsoft_datetime', null);
                datetimepicker.remove();
                input.data('xdsoft_datetimepicker', null).off('.xdsoft');
                $(window).off('resize.xdsoft');
                $([window, document.body]).off('mousedown.xdsoft touchstart');
                if (input.unmousewheel) {
                    input.unmousewheel();
                }
            }
        };
        $(document).off('keydown.xdsoftctrl keyup.xdsoftctrl').on('keydown.xdsoftctrl', function (e) {
            if (e.keyCode === CTRLKEY) {
                ctrlDown = true;
            }
        }).on('keyup.xdsoftctrl', function (e) {
            if (e.keyCode === CTRLKEY) {
                ctrlDown = false;
            }
        });

        this.each(function () {
            var datetimepicker = $(this).data('xdsoft_datetimepicker'),
                $input;
            if (datetimepicker) {
                if ($.type(opt) === 'string') {
                    switch (opt) {
                        case 'show':
                            $(this).select().focus();
                            datetimepicker.trigger('open.xdsoft');
                            break;
                        case 'hide':
                            datetimepicker.trigger('close.xdsoft');
                            break;
                        case 'toggle':
                            datetimepicker.trigger('toggle.xdsoft');
                            break;
                        case 'destroy':
                            destroyDateTimePicker($(this));
                            break;
                        case 'reset':
                            this.value = this.defaultValue;
                            if (!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(dateHelper.parseDate(this.value, options.format))) {
                                datetimepicker.data('changed', false);
                            }
                            datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
                            break;
                        case 'validate':
                            $input = datetimepicker.data('input');
                            $input.trigger('blur.xdsoft');
                            break;
                        default:
                            if (datetimepicker[opt] && $.isFunction(datetimepicker[opt])) {
                                result = datetimepicker[opt](opt2);
                            }
                    }
                } else {
                    datetimepicker.setOptions(opt);
                }
                return 0;
            }
            if ($.type(opt) !== 'string') {
                if (!options.lazyInit || options.open || options.inline) {
                    createDateTimePicker($(this));
                } else {
                    lazyInit($(this));
                }
            }
        });

        return result;
    };

    $.fn.datetimepicker.defaults = default_options;

    function HighlightedDate(date, desc, style) {
        "use strict";

        this.date = date;
        this.desc = desc;
        this.style = style;
    }
});
/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice = Array.prototype.slice,
        nullLowestDeltaTimeout,
        lowestDelta;

    if ($.event.fixHooks) {
        for (var i = toFix.length; i;) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function setup() {
            if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function teardown() {
            if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function getLineHeight(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function getPageHeight(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function mousewheel(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function unmousewheel(fn) {
            return this.unbind('mousewheel', fn);
        }
    });

    function handler(event) {
        var orgEvent = event || window.event,
            args = slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            offsetX = 0,
            offsetY = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ('detail' in orgEvent) {
            deltaY = orgEvent.detail * -1;
        }
        if ('wheelDelta' in orgEvent) {
            deltaY = orgEvent.wheelDelta;
        }
        if ('wheelDeltaY' in orgEvent) {
            deltaY = orgEvent.wheelDeltaY;
        }
        if ('wheelDeltaX' in orgEvent) {
            deltaX = orgEvent.wheelDeltaX * -1;
        }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ('deltaY' in orgEvent) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ('deltaX' in orgEvent) {
            deltaX = orgEvent.deltaX;
            if (deltaY === 0) {
                delta = deltaX * -1;
            }
        }

        // No change actually happened, no reason to go any further
        if (deltaY === 0 && deltaX === 0) {
            return;
        }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if (orgEvent.deltaMode === 1) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            // Divide all the things by 40!
            delta /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if (special.settings.normalizeOffset && this.getBoundingClientRect) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) {
            clearTimeout(nullLowestDeltaTimeout);
        }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }
});

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright 2015 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */
!function (a) {
   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (a),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? module.exports = a : a(jQuery);
}(function (a) {
  function b(b) {
    var g = b || window.event,
        h = i.call(arguments, 1),
        j = 0,
        l = 0,
        m = 0,
        n = 0,
        o = 0,
        p = 0;if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
      if (1 === g.deltaMode) {
        var q = a.data(this, "mousewheel-line-height");j *= q, m *= q, l *= q;
      } else if (2 === g.deltaMode) {
        var r = a.data(this, "mousewheel-page-height");j *= r, m *= r, l *= r;
      }if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
        var s = this.getBoundingClientRect();o = b.clientX - s.left, p = b.clientY - s.top;
      }return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h);
    }
  }function c() {
    f = null;
  }function d(a, b) {
    return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0;
  }var e,
      f,
      g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
      h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
      i = Array.prototype.slice;if (a.event.fixHooks) for (var j = g.length; j;) {
    a.event.fixHooks[g[--j]] = a.event.mouseHooks;
  }var k = a.event.special.mousewheel = { version: "3.1.12", setup: function setup() {
      if (this.addEventListener) for (var c = h.length; c;) {
        this.addEventListener(h[--c], b, !1);
      } else this.onmousewheel = b;a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this));
    }, teardown: function teardown() {
      if (this.removeEventListener) for (var c = h.length; c;) {
        this.removeEventListener(h[--c], b, !1);
      } else this.onmousewheel = null;a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height");
    }, getLineHeight: function getLineHeight(b) {
      var c = a(b),
          d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16;
    }, getPageHeight: function getPageHeight(b) {
      return a(b).height();
    }, settings: { adjustOldDeltas: !0, normalizeOffset: !0 } };a.fn.extend({ mousewheel: function mousewheel(a) {
      return a ? this.bind("mousewheel", a) : this.trigger("mousewheel");
    }, unmousewheel: function unmousewheel(a) {
      return this.unbind("mousewheel", a);
    } });
});

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Awesomplete - Lea Verou - MIT license
(function () {
  function h(a) {
    a = Array.isArray(a) ? { label: a[0], value: a[1] } : "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "label" in a && "value" in a ? a : { label: a, value: a };this.label = a.label || a.value;this.value = a.value;
  }function n(a, b, d) {
    for (var g in b) {
      var f = b[g],
          c = a.input.getAttribute("data-" + g.toLowerCase());a[g] = "number" === typeof f ? parseInt(c) : !1 === f ? null !== c : f instanceof Function ? null : c;a[g] || 0 === a[g] || (a[g] = g in d ? d[g] : f);
    }
  }function c(a, b) {
    return "string" === typeof a ? (b || document).querySelector(a) : a || null;
  }function k(a, b) {
    return l.call((b || document).querySelectorAll(a));
  }function m() {
    k("input.awesomplete").forEach(function (a) {
      new e(a);
    });
  }var e = function e(a, b) {
    var d = this;this.input = c(a);this.input.setAttribute("autocomplete", "off");this.input.setAttribute("aria-autocomplete", "list");b = b || {};n(this, { minChars: 2, maxItems: 10, autoFirst: !1, data: e.DATA, filter: e.FILTER_CONTAINS, sort: e.SORT_BYLENGTH, item: e.ITEM, replace: e.REPLACE }, b);this.index = -1;this.container = c.create("div", { className: "awesomplete", around: a });this.ul = c.create("ul", { hidden: "hidden",
      inside: this.container });this.status = c.create("span", { className: "visually-hidden", role: "status", "aria-live": "assertive", "aria-relevant": "additions", inside: this.container });c.bind(this.input, { input: this.evaluate.bind(this), blur: this.close.bind(this), keydown: function keydown(a) {
        var b = a.keyCode;if (d.opened) if (13 === b && d.selected) a.preventDefault(), d.select();else if (27 === b) d.close();else if (38 === b || 40 === b) a.preventDefault(), d[38 === b ? "previous" : "next"]();
      } });c.bind(this.input.form, { submit: this.close.bind(this) });
    c.bind(this.ul, { mousedown: function mousedown(a) {
        var b = a.target;if (b !== this) {
          for (; b && !/li/i.test(b.nodeName);) {
            b = b.parentNode;
          }b && 0 === a.button && (a.preventDefault(), d.select(b, a.target));
        }
      } });this.input.hasAttribute("list") ? (this.list = "#" + this.input.getAttribute("list"), this.input.removeAttribute("list")) : this.list = this.input.getAttribute("data-list") || b.list || [];e.all.push(this);
  };e.prototype = { set list(a) {
      if (Array.isArray(a)) this._list = a;else if ("string" === typeof a && -1 < a.indexOf(",")) this._list = a.split(/\s*,\s*/);else if ((a = c(a)) && a.children) {
        var b = [];l.apply(a.children).forEach(function (a) {
          if (!a.disabled) {
            var c = a.textContent.trim(),
                f = a.value || c;a = a.label || c;"" !== f && b.push({ label: a, value: f });
          }
        });this._list = b;
      }document.activeElement === this.input && this.evaluate();
    }, get selected() {
      return -1 < this.index;
    }, get opened() {
      return !this.ul.hasAttribute("hidden");
    }, close: function close() {
      this.ul.setAttribute("hidden", "");this.index = -1;c.fire(this.input, "awesomplete-close");
    }, open: function open() {
      this.ul.removeAttribute("hidden");this.autoFirst && -1 === this.index && this["goto"](0);c.fire(this.input, "awesomplete-open");
    }, next: function next() {
      this["goto"](this.index < this.ul.children.length - 1 ? this.index + 1 : -1);
    }, previous: function previous() {
      var a = this.ul.children.length;this["goto"](this.selected ? this.index - 1 : a - 1);
    }, "goto": function goto(a) {
      var b = this.ul.children;this.selected && b[this.index].setAttribute("aria-selected", "false");this.index = a;-1 < a && 0 < b.length && (b[a].setAttribute("aria-selected", "true"), this.status.textContent = b[a].textContent, c.fire(this.input, "awesomplete-highlight", { text: this.suggestions[this.index] }));
    }, select: function select(a, b) {
      a ? this.index = c.siblingIndex(a) : a = this.ul.children[this.index];if (a) {
        var d = this.suggestions[this.index];c.fire(this.input, "awesomplete-select", { text: d, origin: b || a }) && (this.replace(d), this.close(), c.fire(this.input, "awesomplete-selectcomplete", { text: d }));
      }
    }, evaluate: function evaluate() {
      var a = this,
          b = this.input.value;b.length >= this.minChars && 0 < this._list.length ? (this.index = -1, this.ul.innerHTML = "", this.suggestions = this._list.map(function (d) {
        return new h(a.data(d, b));
      }).filter(function (d) {
        return a.filter(d, b);
      }).sort(this.sort).slice(0, this.maxItems), this.suggestions.forEach(function (d) {
        a.ul.appendChild(a.item(d, b));
      }), 0 === this.ul.children.length ? this.close() : this.open()) : this.close();
    } };e.all = [];e.FILTER_CONTAINS = function (a, b) {
    return RegExp(c.regExpEscape(b.trim()), "i").test(a);
  };e.FILTER_STARTSWITH = function (a, b) {
    return RegExp("^" + c.regExpEscape(b.trim()), "i").test(a);
  };e.SORT_BYLENGTH = function (a, b) {
    return a.length !== b.length ? a.length - b.length : a < b ? -1 : 1;
  };e.ITEM = function (a, b) {
    var d = "" === b ? a : a.replace(RegExp(c.regExpEscape(b.trim()), "gi"), "<mark>$&</mark>");return c.create("li", { innerHTML: d, "aria-selected": "false" });
  };e.REPLACE = function (a) {
    this.input.value = a.value;
  };e.DATA = function (a) {
    return a;
  };Object.defineProperty(h.prototype = Object.create(String.prototype), "length", { get: function get() {
      return this.label.length;
    } });h.prototype.toString = h.prototype.valueOf = function () {
    return "" + this.label;
  };var l = Array.prototype.slice;c.create = function (a, b) {
    var d = document.createElement(a),
        g;for (g in b) {
      var f = b[g];"inside" === g ? c(f).appendChild(d) : "around" === g ? (f = c(f), f.parentNode.insertBefore(d, f), d.appendChild(f)) : g in d ? d[g] = f : d.setAttribute(g, f);
    }return d;
  };c.bind = function (a, b) {
    if (a) for (var d in b) {
      var c = b[d];d.split(/\s+/).forEach(function (b) {
        a.addEventListener(b, c);
      });
    }
  };c.fire = function (a, b, c) {
    var e = document.createEvent("HTMLEvents");e.initEvent(b, !0, !0);for (var f in c) {
      e[f] = c[f];
    }return a.dispatchEvent(e);
  };c.regExpEscape = function (a) {
    return a.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
  };
  c.siblingIndex = function (a) {
    for (var b = 0; a = a.previousElementSibling; b++) {}return b;
  };"undefined" !== typeof Document && ("loading" !== document.readyState ? m() : document.addEventListener("DOMContentLoaded", m));e.$ = c;e.$$ = k;"undefined" !== typeof self && (self.Awesomplete = e);"object" === ( false ? "undefined" : _typeof(module)) && module.exports && (module.exports = e);return e;
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  if (( false ? "undefined" : _typeof(exports)) == "object" && ( false ? "undefined" : _typeof(module)) == "object") // CommonJS
    mod(__webpack_require__(27));else if (true) // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(27)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("yaml", function () {

    var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];
    var keywordRegex = new RegExp("\\b((" + cons.join(")|(") + "))$", 'i');

    return {
      token: function token(stream, state) {
        var ch = stream.peek();
        var esc = state.escaped;
        state.escaped = false;
        /* comments */
        if (ch == "#" && (stream.pos == 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
          stream.skipToEnd();
          return "comment";
        }

        if (stream.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/)) return "string";

        if (state.literal && stream.indentation() > state.keyCol) {
          stream.skipToEnd();return "string";
        } else if (state.literal) {
          state.literal = false;
        }
        if (stream.sol()) {
          state.keyCol = 0;
          state.pair = false;
          state.pairStart = false;
          /* document start */
          if (stream.match(/---/)) {
            return "def";
          }
          /* document end */
          if (stream.match(/\.\.\./)) {
            return "def";
          }
          /* array list item */
          if (stream.match(/\s*-\s+/)) {
            return 'meta';
          }
        }
        /* inline pairs/lists */
        if (stream.match(/^(\{|\}|\[|\])/)) {
          if (ch == '{') state.inlinePairs++;else if (ch == '}') state.inlinePairs--;else if (ch == '[') state.inlineList++;else state.inlineList--;
          return 'meta';
        }

        /* list seperator */
        if (state.inlineList > 0 && !esc && ch == ',') {
          stream.next();
          return 'meta';
        }
        /* pairs seperator */
        if (state.inlinePairs > 0 && !esc && ch == ',') {
          state.keyCol = 0;
          state.pair = false;
          state.pairStart = false;
          stream.next();
          return 'meta';
        }

        /* start of value of a pair */
        if (state.pairStart) {
          /* block literals */
          if (stream.match(/^\s*(\||\>)\s*/)) {
            state.literal = true;return 'meta';
          };
          /* references */
          if (stream.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i)) {
            return 'variable-2';
          }
          /* numbers */
          if (state.inlinePairs == 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) {
            return 'number';
          }
          if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/)) {
            return 'number';
          }
          /* keywords */
          if (stream.match(keywordRegex)) {
            return 'keyword';
          }
        }

        /* pairs (associative arrays) -> key */
        if (!state.pair && stream.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/)) {
          state.pair = true;
          state.keyCol = stream.indentation();
          return "atom";
        }
        if (state.pair && stream.match(/^:\s*/)) {
          state.pairStart = true;return 'meta';
        }

        /* nothing found, continue */
        state.pairStart = false;
        state.escaped = ch == '\\';
        stream.next();
        return null;
      },
      startState: function startState() {
        return {
          pair: false,
          pairStart: false,
          keyCol: 0,
          inlinePairs: 0,
          inlineList: 0,
          literal: false,
          escaped: false
        };
      }
    };
  });

  CodeMirror.defineMIME("text/x-yaml", "yaml");
  CodeMirror.defineMIME("text/yaml", "yaml");
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, Msg) {

    /**
     * Module encapsulating a toolbox popup for a frame
     * @type {{}}
     */
    var Module = {};

    /**
     * List of all toolboxes that are currently present (hidden or visible)
     * @type {Array}
     * @private
     */
    Module._list = [];

    Module.create = function (icon, rootControl) {
        var toolBox = {};
        toolBox._id = AXMUtils.getUniqueID();
        toolBox._frame = null;
        toolBox._icon = icon;
        toolBox._rootControl = rootControl;
        toolBox._isActive = false;

        toolBox.getIcon = function () {
            return toolBox._icon;
        };

        toolBox._getStart$El = function () {
            return toolBox._frame.getRoot$El().find('.ToolBoxStart');
        };

        toolBox.start = function () {
            if (!toolBox._frame) AXMUtils.reportBug("Toolbox not attached to frame");

            var toolBoxStart = DOM.Div({});
            toolBoxStart.addCssClass("ToolBoxStart");
            //toolBoxStart.addStyle("top", "4px");
            toolBoxStart.addElem('<div class="ToolBoxStartIcon">' + toolBox.getIcon().renderHtml() + '</div>');
            toolBox._frame.getRoot$El().append(toolBoxStart.toString());

            var rootDiv = DOM.Div({ id: toolBox._id });
            rootDiv.addCssClass("ToolBoxContainer");
            rootDiv.addElem(toolBox._rootControl.createHtml());

            $('.AXMContainer').append(rootDiv.toString());
            toolBox._$ElContainer = $('#' + toolBox._id);

            toolBox._getStart$El().click(toolBox.onClickStart);
            toolBox._rootControl.attachEventHandlers();

            Module._list.push(toolBox);
        };

        toolBox.close = function () {
            toolBox._getStart$El().unbind('click');
            toolBox._rootControl.detachEventHandlers();
            toolBox._$ElContainer.remove();
            var idx = -1;
            $.each(Module._list, function (i, item) {
                if (item === toolBox) idx = i;
            });
            if (idx >= 0) Module._list.splice(idx, 1);
        };

        toolBox.onClickStart = function () {
            if (toolBox._isActive) return;
            toolBox._$ElContainer.css("z-index", AXMUtils.getCurrentZIndex() + 100);
            toolBox._$ElContainer.css("visibility", "visible");
            var browserSize = AXMUtils.getBrowserSize();

            var boxW = toolBox._$ElContainer.outerWidth();
            var boxH = toolBox._$ElContainer.outerHeight();

            var left = toolBox._getStart$El().offset().left - boxW;
            if (left < 0) left = 0;
            var top = toolBox._getStart$El().offset().top - 1;
            if (top + boxH > browserSize.sizeY - 2) top = browserSize.sizeY - 2 - boxH;
            if (top < 0) top = 0;

            toolBox._$ElContainer.offset({
                top: top,
                left: left
            });

            toolBox._isActive = true;

            setTimeout(function () {
                $(document).bind("mouseup.toolbox", toolBox._onDocClicked);
            }, 100);
        };

        toolBox.hide = function () {
            if (toolBox._isActive) {
                toolBox._$ElContainer.css("visibility", "hidden");
                setTimeout(function () {
                    toolBox._isActive = false;
                }, 50); // introducing a delay to make sure that clicking the toolbox start element does not immediately reactives it
                $(document).unbind("mouseup.toolbox");
            }
        };

        toolBox._onDocClicked = function (ev) {
            if (ev.target) {
                var clicked$El = $(ev.target);
                if (clicked$El.length < 1) return;
                if (toolBox._$ElContainer[0] != clicked$El[0] && !$.contains(toolBox._$ElContainer[0], clicked$El[0])) {
                    toolBox.hide();
                }
            }
        };

        return toolBox;
    };

    Msg.listen(null, "CloseTransientPopups", function () {
        $.each(Module._list, function (idx, box) {
            box.hide();
        });
    });

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(19), __webpack_require__(20), __webpack_require__(2), __webpack_require__(4), __webpack_require__(3), __webpack_require__(10), __webpack_require__(13), __webpack_require__(7), __webpack_require__(5), __webpack_require__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Blob, FileSaver, AXMUtils, DOM, Controls, Frame, PanelBase, Msg, SimplePopups, TableInfo) {

    /**
     * Module encapsulating a panel that contains a  table
     * @type {{}}
     */
    var Module = {};

    /**
     * Implements a panel that contains a table
     * @param {string} id - panel type id
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.create = function (typeId) {
        var panel = PanelBase.create(typeId);

        panel._columns = [];
        panel._rows = [];
        panel._activeControls = [];

        panel.addColumn = function (colId, colName, colControl) {
            panel._columns.push({
                colId: colId,
                colName: colName,
                colControl: colControl
            });
        };

        panel.addRow = function (rowInfo) {
            $.each(panel._columns, function (idx, column) {
                if (rowInfo[column.colId]) AXMUtils.Test.checkIsType(rowInfo[column.colId], '@Control');
            });
            panel._rows.push(rowInfo);
        };

        panel.resetColumns = function () {
            panel._columns = [];
        };

        panel.resetRows = function () {
            panel._rows = [];
            panel._clearActiveControls();
        };

        panel._clearActiveControls = function () {
            $.each(panel._activeControls, function (idx, control) {
                control.tearDown();
            });
            panel._activeControls = [];
        };

        /**
         * Returns the html implementing the panel
         * @returns {string}
         */
        panel.createHtml = function () {

            var divRoot = DOM.Div({ id: 'rt' + panel._id }).addStyle('width', '100%').addStyle('height', '100%')
            //.addStyle('overflow-x', 'scroll')
            .addStyle('position', 'relative');
            //.addStyle('background-color', 'yellow')

            //divRoot.addElem(panel.createHtmlBody());

            var divRoot = DOM.Div({ id: 'tb' + panel._id, parent: divRoot })
            //.addStyle('width', '100%')
            .addStyle('height', 'calc(100% - 20px)').addStyle('margin-top', '20px').addStyle('overflow-x', 'scroll').addStyle('overflow-y', 'scroll').addStyle('white-space', 'nowrap');
            //.addStyle('position', 'relative')
            //.addStyle('background-color', 'yellow')

            //divRoot.addElem(panel.createHtmlBody());

            return divRoot.toString();
        };

        panel.render = function () {
            panel._clearActiveControls();

            var content = '<table style="padding-top:0px" class="FHTable">';

            content += '<tr style="">';
            $.each(panel._columns, function (idx, column) {
                content += '<th><div style="padding:6px;padding-top:10px;padding-bottom:10px">';
                if (column.colControl) {
                    content += column.colControl.createHtml();
                    panel._activeControls.push(column.colControl);
                } else content += column.colName;
                content += "</div></th>";
            });
            content += '</tr>';

            $.each(panel._rows, function (idx, row) {
                content += '<tr>';
                $.each(panel._columns, function (idx, column) {
                    content += '<td style="padding:6px;padding-top:10px;padding-bottom:10px">';
                    if (row[column.colId]) {
                        content += row[column.colId].createHtml();
                        panel._activeControls.push(row[column.colId]);
                    }
                    content += "</td>";
                });
                content += '</tr>';
            });

            content += "</table>";

            $('#tb' + panel._id).html(content);

            $.each(panel._columns, function (idx, column) {
                if (column.colControl) content += column.colControl.attachEventHandlers();
            });

            $.each(panel._rows, function (idx, row) {
                $.each(panel._columns, function (idx, column) {
                    if (row[column.colId]) row[column.colId].attachEventHandlers();
                });
            });
        };

        /**
        * Attached the html event handlers after DOM insertion
        */
        panel.attachEventHandlers = function () {};

        /**
         * Detach the html event handlers
         */
        panel.detachEventHandlers = function () {};

        /**
         * Resizes the panel
         * @param {int} xl - new x size
         * @param {int} yl - new y size
         */
        panel.resize = function (xl, yl) {
            AXMUtils.Test.checkIsNumber(xl, yl);
            panel._availableWidth = xl;
        };

        //Remove own object on closing
        panel.addTearDownHandler(function () {
            panel._clearActiveControls();
            panel = null;
        });

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, PanelBase) {

    /**
     * Module encapsulating a panel that contains a list
     * @type {{}}
     */
    var Module = {};

    /**
     * Implements a panel that contains a list
     * @param {string} id - panel id
     * @returns {id}
     */
    Module.create = function (id) {
        var panel = PanelBase.create(id);

        panel._itemMap = {};
        panel._itemList = [];
        panel._activeItemId = null;
        panel._notificationHandlers = [];

        /**
         * Adds a new item to the list
         * @param {string} id - unique id of the list item
         * @param {string} content - displayed content
         */
        panel.addItem = function (id, content) {
            if (panel._itemMap[id]) AXMUtils.Test.reportBug("List item already present: " + id);
            var item = {
                id: id,
                content: content
            };
            panel._itemList.push(item);
            panel._itemMap[id] = item;
            if (panel.isRendered()) {
                var itemDiv = DOM.Div({ id: panel.getItemElementId(item.id) });
                itemDiv.addCssClass("AXMPanelListItem");
                itemDiv.addElem(item.content);
                panel.get$El().append(itemDiv.toString());
            }
        };

        panel.clearItems = function (sendNotification) {
            panel.setActiveListItemId(null, sendNotification);
            panel._itemList = [];
            panel._itemMap = {};
            if (panel.isRendered()) {
                panel.get$El().empty();
            }
        };

        /**
         * Sets an item as being active
         * @param {string} itemId
         */
        panel.setActiveListItemId = function (itemId, sendNotification) {
            if (itemId === panel._activeItemId) return;
            if (panel._itemMap[id] && itemId) AXMUtils.Test.reportBug("List item not present: " + id);
            panel._activeItemId = itemId;
            if (panel.isRendered()) panel._updateSelection();
            if (sendNotification !== false) panel._notify("ActiveItemModified");
        };

        /**
         * Changes the content of an item
         * @param {string} itemId
         * @param {string} newContent
         */
        panel.modifyItemContent = function (itemId, newContent) {
            if (!panel._itemMap[itemId]) return;
            panel._itemMap[itemId].content = newContent;
            if (panel.isRendered()) $('#' + panel.getItemElementId(itemId)).html(newContent);
        };

        /**
         * Returns the id of the currently active item
         * @returns {null|string}
         */
        panel.getActiveListItemId = function () {
            return panel._activeItemId;
        };

        /**
         * Adds a handler function that is called when the status of the panel changes
         * @param {function} handlerFunc - callback
         * @returns {Object} - self
         */
        panel.addNotificationHandler = function (handlerFunc) {
            panel._notificationHandlers.push(handlerFunc);
            return panel;
        };

        /**
         * Enables a vertical scroll bar for the panel
         * @returns {Object} - self
         */
        panel.enableVScrollBar = function () {
            panel._scrollbarV = true;
            return panel;
        };

        /**
         * Notifies event handlers about an event that occurred
         * @param {string} eventType - event type identifier
         * @private
         */
        panel._notify = function (eventType) {
            $.each(panel._notificationHandlers, function (idx, handler) {
                handler(eventType);
            });
        };

        /**
         * Returns the jquery element of the html content
         * @returns {jQuery}
         */
        panel.get$El = function () {
            return $('#' + panel.getId() + '_content');
        };

        /**
         * Determines if the panel is live in the DOM tree
         * @returns {boolean}
         */
        panel.isRendered = function () {
            return panel.get$El().length > 0;
        };

        /**
         * Returns the ID of the element with the content
         * @returns {string}
         */
        panel.getContentElementId = function () {
            return panel.getId() + '_content';
        };

        /**
         * Returns the html ID of the element containing a list item
         * @param item
         * @returns {string}
         */
        panel.getItemElementId = function (itemId) {
            return panel.getId() + '_it_' + itemId;
        };

        /**
         * Returns the html implementing the panel
         * @returns {string}
         */
        panel.createHtml = function () {
            var rootDiv = DOM.Div({ id: panel.getId() + '_content' });
            rootDiv.addCssClass('AXMHtmlPanelBody');
            rootDiv.addStyle('width', '100%');
            rootDiv.addStyle('height', '100%');
            rootDiv.addStyle('overflow', 'hidden');
            if (panel._scrollbarV) rootDiv.addStyle('overflow-y', 'scroll');else rootDiv.addStyle('overflow-y', 'auto');

            $.each(panel._itemList, function (idx, item) {
                var itemDiv = DOM.Div({ id: panel.getItemElementId(item.id), parent: rootDiv });
                itemDiv.addCssClass("AXMPanelListItem");
                itemDiv.addElem(item.content);
            });

            return rootDiv.toString();
        };

        panel._updateSelection = function () {
            panel.get$El().children().removeClass("AXMPanelListItemSelected");
            if (panel._activeItemId) panel.get$El().find('#' + panel.getItemElementId(panel._activeItemId)).addClass("AXMPanelListItemSelected");
        };

        /**
         * Attaches the html event handlers after DOM insertion
         */
        panel.attachEventHandlers = function () {
            panel._updateSelection();
            panel.get$El().click(panel._onClick);
        };

        /**
         * Detaches the html event handlers
         */
        panel.detachEventHandlers = function () {
            panel._notificationHandlers = [];
            panel.get$El().unbind('click');
        };

        panel._onClick = function (ev) {
            if (event.target) {
                var clicked$El = $(event.target);
                if (clicked$El.length < 1) AXMUtils.Test.reportBug('Unable to obtain click target');
                var newActiveItemId = null;
                $.each(panel._itemList, function (idx, item) {
                    var listItem$El = $("#" + panel.getItemElementId(item.id));
                    if (listItem$El[0] == clicked$El[0] || $.contains(listItem$El[0], clicked$El[0])) {
                        newActiveItemId = item.id;
                    }
                });
                if (newActiveItemId !== null && newActiveItemId != panel._activeItemId) {
                    panel.setActiveListItemId(newActiveItemId);
                }
            }
        };

        panel.resize = function (xl, yl) {};

        return panel;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(13), __webpack_require__(10), __webpack_require__(52), __webpack_require__(21), __webpack_require__(8), __webpack_require__(14), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM, PanelBase, Frame, Canvas, DrawUtils, Color, Icon, Controls) {

    /**
     * Module encapsulating a panel with a html5 canvas element
     * @type {{}}
     */
    var Module = {};

    Module._trackOffsetLeft = 20;
    Module._trackOffsetRight = 0;
    Module._leftRightOffsetMarginH = 1;
    Module._trackMarginV = 2;
    Module._scrollYArrowSize = 20;

    Module.Track = function (settings) {
        var track = AXMUtils.object('@TrackViewTrack');
        track._id = AXMUtils.getUniqueID();
        track._visible = settings.defaultVisible || false;
        track._canHide = settings.canHide || false;
        track._name = settings.name || "Track";
        track._width = 1;
        track._fixedHeight = -1;
        track.cnvs = Canvas.create(track._id, ['main', 'selection']);

        track._offsetY = 0;
        track._toolTipInfo = { ID: null };

        track.getOffsetY = function () {
            return track._offsetY;
        };

        track.setName = function (name) {
            track._name = name;
        };

        track.getName = function () {
            return track._name;
        };

        track.canHide = function () {
            return track._canHide;
        };

        track.isVisible = function () {
            return track._visible;
        };

        /**
         * Returns the Y range for vertical scrolling. To be overridden
         * @returns {number}
         */
        track.getYRange = function () {
            return 0;
        };

        /**
         * Returns tooltip information for a location
         * Optionally to be implemented in a direved class
         * @param {int} px - x position
         * @param {int} py - y position
         * @returns {{ID, px, py, content}} - tooltip info (may be null if no tooltip is to be shown)
         */
        track.getToolTipInfo = function (px, py) {
            return null;
        };

        /**
         * Optionally to be implemented by a derived class to be notified about clicks
         * @param {{}} ev - event
         * @param {{}} info - additional info
         * @param {int} info.x - mouse x position
         * @param {int} info.y - mouse y position
         * @param {int} info.pageX - mouse x full page position
         * @param {int} info.pageY - mouse y full page position
         */
        track.onMouseClick = function (ev, info) {};

        track.setOffsetY = function (newVal, donotUpdate) {
            track._offsetY = newVal;
            if (!donotUpdate) track.render();
        };

        track.shiftOffsetY = function (shft, donotUpdate) {
            track._offsetY += shft;
            track._offsetY = Math.max(track._offsetY, 0);
            track._offsetY = Math.min(track._offsetY, track.getYRange());
            if (!donotUpdate) track.render();
        };

        track.getId = function () {
            return track._id;
        };

        track.setViewerPanel = function (panel) {
            track._panel = panel;
        };

        track.getViewerPanel = function () {
            if (!track._panel) AXMUtils.Test.reportBug("Track panel not assigned");
            return track._panel;
        };

        track.setFixedHeight = function (h) {
            track._fixedHeight = h;
        };

        track.hasFixedHeight = function () {
            return track._fixedHeight > 0;
        };

        track.getFixedHeight = function () {
            if (track._fixedHeight < 0) AXMUtils.Test.reportBug("Track does not have fixed height");
            return track._fixedHeight;
        };

        track.getWidth = function () {
            return track._width;
        };

        track.getHeight = function () {
            return track._height;
        };

        track.createHtml = function () {
            var rootDiv = DOM.Div({ id: 'track_' + track.getId() });
            if (!track.isVisible()) rootDiv.addStyle("display", "none");
            //rootDiv.addStyle('width', '100%');
            rootDiv.addStyle('height', track._fixedHeight + "px");
            rootDiv.addStyle('border-bottom', "{w}px solid rgb(220,220,220)".AXMInterpolate({ w: Module._trackMarginV }));
            //rootDiv.addStyle('background-color', "rgb(240,240,240)");
            rootDiv.addStyle('white-space', "nowrap");
            rootDiv.addStyle('vertical-align', "top");

            var leftDiv = DOM.Div({ parent: rootDiv });
            leftDiv.addStyle("display", "inline-block");
            leftDiv.addStyle('vertical-align', "top");
            leftDiv.addStyle("width", Module._trackOffsetLeft - 1 + "px");
            leftDiv.addStyle("height", "100%");
            leftDiv.addStyle("border-right", "1px solid rgb(220,220,220)");

            var centerDiv = DOM.Div({ parent: rootDiv });
            centerDiv.addCssClass("TrackCenter");
            centerDiv.addStyle("display", "inline-block");
            centerDiv.addStyle('vertical-align', "top");
            centerDiv.addStyle('position', 'relative');
            centerDiv.addElem(track.cnvs.createHtml());

            var rightDiv = DOM.Div({ parent: rootDiv });
            rightDiv.addStyle("display", "inline-block");
            rightDiv.addStyle('vertical-align', "top");
            rightDiv.addStyle("width", Module._trackOffsetRight - 1 + "px");
            rightDiv.addStyle("border-left", "1px solid rgb(220,220,220)");
            rightDiv.addStyle("height", "100%");

            return rootDiv.toString();
        };

        track.setVisible = function (status) {
            track._visible = status;
            var $El = $('#track_' + track.getId());
            if (!status) $El.hide();else $El.show();
            if (track.__ctrl_visible) {
                track.__ctrl_visible.setValue(status, true);
            }
        };

        /**
         * Display a tooltip
         * @param tooltipInfo
         * @private
         */
        track._showToolTip = function (tooltipInfo) {
            track._hideToolTip();
            track._toolTipInfo = tooltipInfo;
            if (tooltipInfo && tooltipInfo.content) {
                AXMReq(tooltipInfo.ID);
                AXMReq(tooltipInfo.px);
                AXMReq(tooltipInfo.py);
                var tooltip = DOM.Div();
                tooltip.addCssClass("AXMToolTip");
                tooltip.addStyle("position", "absolute");
                var screenX = track.cnvs.posXCanvas2Screen(track._toolTipInfo.px);
                var screenY = track.cnvs.posYCanvas2Screen(track._toolTipInfo.py);
                tooltip.addStyle("left", screenX + 10 + 'px');
                tooltip.addStyle("top", screenY + 10 + 'px');
                tooltip.addStyle("z-index", '9999999');
                tooltip.addElem(track._toolTipInfo.content);
                $('.AXMContainer').append(tooltip.toString());
            }
        };

        /**
         * Hides a displayed tooltip, if any
         * @private
         */
        track._hideToolTip = function () {
            track._toolTipInfo.ID = null;
            $('.AXMContainer').find('.AXMToolTip').remove();
        };

        /**
         * Attached the html event handlers after DOM insertion
         */
        track.attachEventHandlers = function () {
            var clickLayer$El = track.cnvs.getCanvas$El('selection');
            var viewerPanel = track.getViewerPanel();
            AXMUtils.create$ElScrollHandler(clickLayer$El, function (params) {
                viewerPanel._handleScrolled(params, track);
            }, true);
            AXMUtils.create$ElDragHandler(clickLayer$El, track._panningStart, track._panningDo, track._panningStop);
            clickLayer$El.mousemove(track._onMouseMove);
            clickLayer$El.click(track._onClick);

            clickLayer$El.mouseleave(function () {
                track._hideToolTip();
            });
        };

        /**
         * Detach the html event handlers
         */
        track.detachEventHandlers = function () {
            var clickLayer$El = track.cnvs.getCanvas$El('selection');
            AXMUtils.remove$ElScrollHandler(clickLayer$El);
            AXMUtils.remove$ElDragHandler(clickLayer$El);
            clickLayer$El.unbind('mousemove');
            clickLayer$El.unbind('click');
            clickLayer$El.unbind('mouseleave');
        };

        track.resize = function (xl, yl, params) {
            track._width = xl;
            track._height = yl;
            if (track.hasFixedHeight()) track._height = track._fixedHeight;

            var centerWidth = xl - Module._trackOffsetLeft - Module._trackOffsetRight - 2 * Module._leftRightOffsetMarginH;

            var root$El = $('#track_' + track.getId());
            root$El.height(track._height);
            root$El.children(".TrackCenter").width(centerWidth);

            track.cnvs.resize(centerWidth, track._height, params);
        };

        track.render = function () {
            track._maxOffsetY = track.getYRange() - track.cnvs.getHeight();
            track._offsetY = Math.max(Math.min(track._offsetY, track._maxOffsetY), 0);
            track.cnvs.render();
        };

        track.renderLayer = function (layerId) {
            track._maxOffsetY = track.getYRange() - track.cnvs.getHeight();
            track._offsetY = Math.max(Math.min(track._offsetY, track._maxOffsetY), 0);
            track.cnvs.renderLayer(layerId);
        };

        track.DrawTicks = function (drawInfo) {
            var viewerPanel = track.getViewerPanel();
            var zoomFactor = viewerPanel.getZoomFactor();
            var XPosLogic2Display = viewerPanel.XPosLogic2Display;
            var ctx = drawInfo.ctx;
            var sizeX = drawInfo.sizeX;
            var sizeY = drawInfo.sizeY;
            var plotLimitXMin = viewerPanel.clipToRange(viewerPanel.XDisplay2Logic(0 - 50));
            var plotLimitXMax = viewerPanel.clipToRange(viewerPanel.XDisplay2Logic(sizeX + 50));

            var scale = viewerPanel.getXScale();

            var ticks = [];
            scale.Jump1 = Math.max(viewerPanel._minScaleUnit, scale.Jump1);
            scale.Jump2 = Math.max(viewerPanel._minScaleUnit, scale.Jump2);
            for (var i = Math.ceil(plotLimitXMin / scale.Jump1); i <= Math.floor(plotLimitXMax / scale.Jump1); i++) {
                var tick = {};
                tick.value = i * scale.Jump1;
                if (i % scale.JumpReduc == 0) {
                    tick.label = scale.value2String(tick.value);
                }
                ticks.push(tick);
            }
            ctx.strokeStyle = "rgba(0,0,0,0.04)";
            $.each(ticks, function (idx, tick) {
                if (tick.value >= plotLimitXMin && tick.value <= plotLimitXMax) {
                    var px = Math.round(XPosLogic2Display(tick.value)) - 0.5;
                    //if (tick.label) {
                    //}
                    //else {
                    //    ctx.strokeStyle = "rgba(0,0,0,0.05)";
                    //}
                    ctx.beginPath();
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px, sizeY);
                    ctx.stroke();
                }
            });
        };

        /**
         * Draws the main view of the track - to be overridden
         * @param drawInfo
         */
        track.drawMain = function (drawInfo) {
            drawInfo.ctx.fillStyle = "#FFFFFF";
            drawInfo.ctx.fillRect(0, 0, drawInfo.sizeX, drawInfo.sizeY);
            drawInfo.ctx.beginPath();
            drawInfo.ctx.moveTo(0, 0);
            drawInfo.ctx.lineTo(drawInfo.sizeX / 2, drawInfo.sizeY);
            drawInfo.ctx.stroke();
        };

        /**d
         * Draws the selection the track
         * @param drawInfo
         */
        track.drawSelection = function (drawInfo) {
            var viewerPanel = track.getViewerPanel();
            var zoomFactor = viewerPanel.getZoomFactor();
            var XPosLogic2Display = viewerPanel.XPosLogic2Display;
            var ctx = drawInfo.ctx;
            var sizeX = drawInfo.sizeX;
            var sizeY = drawInfo.sizeY;
            ctx.clearRect(0, 0, drawInfo.sizeX, drawInfo.sizeY);

            ctx.font = "11px Arial";
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillRect(0, 0, ctx.measureText(track._name).width + 10, 15);
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.textAlign = 'left';
            ctx.fillText(track._name, 5, 10);

            if (viewerPanel._selEnd >= viewerPanel._selStart) {
                var x1 = XPosLogic2Display(viewerPanel._selStart);
                var x2 = XPosLogic2Display(viewerPanel._selEnd + 1);
                ctx.fillStyle = "rgba(0,128,255,0.3)";
                ctx.fillRect(x1, 0, 1, sizeY);
                ctx.fillRect(x2, 0, 1, sizeY);
            }
        };

        track.drawYScrollArrows = function (drawInfo) {
            var ctx = drawInfo.ctx;
            var sizeX = drawInfo.sizeX;
            var sizeY = drawInfo.sizeY;
            track._arrowScrollYCenterX = sizeX / 2;
            var sz = Module._scrollYArrowSize;
            track._hasArrowScrollYDown = false;
            track._hasArrowScrollYUp = false;
            ctx.fillStyle = AXMBaseStyling.color1.changeOpacity(0.4).toStringCanvas();
            ctx.strokeStyle = Color.Color(0, 0, 0).changeOpacity(0.1).toStringCanvas();
            if (track._offsetY > 0) {
                track._hasArrowScrollYDown = true;
                ctx.beginPath();
                ctx.moveTo(track._arrowScrollYCenterX, sizeY);
                ctx.lineTo(track._arrowScrollYCenterX + sz, sizeY - sz);
                ctx.lineTo(track._arrowScrollYCenterX - sz, sizeY - sz);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            if (track._offsetY < track._maxOffsetY) {
                track._hasArrowScrollYUp = true;
                ctx.beginPath();
                ctx.moveTo(track._arrowScrollYCenterX, 0);
                ctx.lineTo(track._arrowScrollYCenterX + sz, 0 + sz);
                ctx.lineTo(track._arrowScrollYCenterX - sz, 0 + sz);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            if (track._maxOffsetY > 0) {
                ctx.fillRect(sizeX - 7, sizeY - sizeY * (track._offsetY + sizeY) * 1.0 / (track._maxOffsetY + sizeY), 7, sizeY * sizeY * 1.0 / (track._maxOffsetY + sizeY));
            }
        };

        track.cnvs.draw = function (drawInfo) {
            track._drawSizeY = drawInfo.sizeY;
            if (drawInfo.layerId == "main") {
                track.drawMain(drawInfo);
                track.drawYScrollArrows(drawInfo);
            }
            if (drawInfo.layerId == "selection") {
                track.drawSelection(drawInfo);
            }
        };

        track._getEventPos = function (ev) {
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            return {
                x: ev1.pageX - track.cnvs.getCanvas$El('main').offset().left,
                y: ev1.pageY - track.cnvs.getCanvas$El('main').offset().top
            };
        };

        track._isInsidescrollYArrowUp = function (posit) {
            if (!track._hasArrowScrollYUp) return false;
            if (Math.abs(posit.x - track._arrowScrollYCenterX) > Module._scrollYArrowSize) return false;
            if (posit.y > Module._scrollYArrowSize) return false;
            return posit.y >= Math.abs(posit.x - track._arrowScrollYCenterX);
        };

        track._isInsidescrollYArrowDown = function (posit) {
            if (!track._hasArrowScrollYDown) return false;
            if (Math.abs(posit.x - track._arrowScrollYCenterX) > Module._scrollYArrowSize) return false;
            if (posit.y < track._drawSizeY - Module._scrollYArrowSize) return false;
            return posit.y <= track._drawSizeY - Math.abs(posit.x - track._arrowScrollYCenterX);
        };

        track._panningStart = function (params) {
            track._hideToolTip();
            var posit = track._getEventPos(params.event);

            track.clickScrollingYUp = false;
            track.clickScrollingYDown = false;

            if (track._isInsidescrollYArrowUp(posit)) {
                track.clickScrollingYUp = true;
                var _repeater = function _repeater() {
                    if (!track.clickScrollingYUp) return;
                    track.shiftOffsetY(30);
                    setTimeout(_repeater, 25);
                };
                _repeater();
            }

            if (track._isInsidescrollYArrowDown(posit)) {
                track.clickScrollingYDown = true;
                var _repeater = function _repeater() {
                    if (!track.clickScrollingYDown) return;
                    track.shiftOffsetY(-30);
                    setTimeout(_repeater, 50);
                };
                _repeater();
            }

            if (!track.clickScrollingYUp && !track.clickScrollingYDown) {
                var viewerPanel = track.getViewerPanel();
                viewerPanel._panningStart(params, track);
            }
        };

        track._panningDo = function (params) {
            if (!track.clickScrollingYUp && !track.clickScrollingYDown) {
                var viewerPanel = track.getViewerPanel();
                viewerPanel._panningDo(params);
            }
        };

        track._panningStop = function (params) {
            track.clickScrollingYUp = false;
            track.clickScrollingYDown = false;
            if (!track.clickScrollingYUp && !track.clickScrollingYDown) {
                var viewerPanel = track.getViewerPanel();
                viewerPanel._panningStop(params);
            }
        };

        track._onMouseMove = function (ev) {
            var viewerPanel = track.getViewerPanel();
            if (_AXM_HasTransientPopups && _AXM_HasTransientPopups()) {
                track._hideToolTip();
                return;
            }
            if (viewerPanel.isPanning()) {
                track._hideToolTip();
                return;
            }
            var posit = track._getEventPos(ev);
            var showPointer = false;
            if (track._isInsidescrollYArrowUp(posit) || track._isInsidescrollYArrowDown(posit)) {
                track._hideToolTip();
                showPointer = true;
            } else {
                var newToolTipInfo = track.getToolTipInfo(posit.x, posit.y);
                if (newToolTipInfo) {
                    if (newToolTipInfo.showPointer) showPointer = true;
                    if (track._toolTipInfo.ID != AXMReq(newToolTipInfo.ID)) track._showToolTip(newToolTipInfo);
                } else track._hideToolTip();
            }
            var pointerType = showPointer ? "pointer" : "auto";
            track.cnvs.getCanvas$El('main').css('cursor', pointerType);
            track.cnvs.getCanvas$El('selection').css('cursor', pointerType);
        };

        track._onClick = function (ev) {
            var viewerPanel = track.getViewerPanel();
            if (viewerPanel.hasDragged()) return;
            var posit = track._getEventPos(ev);
            if (track._isInsidescrollYArrowUp(posit)) return;
            if (track._isInsidescrollYArrowDown(posit)) return;
            track.onMouseClick(ev, {
                x: posit.x,
                y: posit.y,
                pageX: ev.pageX,
                pageY: ev.pageY
            });
        };

        track.drawMessage = function (drawInfo, content) {
            var ctx = drawInfo.ctx;
            ctx.save();
            ctx.font = "18px Arial";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(content, drawInfo.sizeX / 2, drawInfo.sizeY / 2);

            ctx.restore();
        };

        return track;
    };

    Module.Track_Position = function () {
        var track = Module.Track({ canHide: true, defaultVisible: true, name: "Position" });
        track.setFixedHeight(20);
        track._customLabelConvertor = null;

        track.setCustomLabelConvertor = function (handler) {
            track._customLabelConvertor = handler;
        };

        track.drawMain = function (drawInfo) {
            var viewerPanel = track.getViewerPanel();
            var zoomFactor = viewerPanel.getZoomFactor();
            var XPosLogic2Display = viewerPanel.XPosLogic2Display;
            var ctx = drawInfo.ctx;
            var sizeX = drawInfo.sizeX;
            var sizeY = drawInfo.sizeY;

            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, sizeX, sizeY);

            var plotLimitXMin = viewerPanel.clipToRange(viewerPanel.XDisplay2Logic(0 - 50));
            var plotLimitXMax = viewerPanel.clipToRange(viewerPanel.XDisplay2Logic(sizeX + 50));

            var scale = viewerPanel.getXScale();

            ctx.save();
            ctx.font = "10px Arial";
            ctx.fillStyle = "rgb(0,0,0)";
            ctx.textAlign = 'center';
            var ticks = [];
            scale.Jump1 = Math.max(viewerPanel._minScaleUnit, scale.Jump1);
            scale.Jump2 = Math.max(viewerPanel._minScaleUnit, scale.Jump2);
            for (var i = Math.ceil(plotLimitXMin / scale.Jump1); i <= Math.floor(plotLimitXMax / scale.Jump1); i++) {
                var tick = {};
                tick.value = i * scale.Jump1;
                if (i % scale.JumpReduc == 0) {
                    tick.label = scale.value2String(tick.value);
                }
                ticks.push(tick);
            }
            $.each(ticks, function (idx, tick) {
                if (tick.value >= plotLimitXMin && tick.value <= plotLimitXMax) {
                    var px = Math.round(XPosLogic2Display(tick.value)) - 0.5;
                    if (tick.label) {
                        if (track._customLabelConvertor) tick.label = track._customLabelConvertor(tick.value);
                        ctx.fillText(tick.label, px, 4 + 13);
                        //if (tick.label2)
                        //    ctx.fillText(tick.label2, px, drawInfo.sizeY - panel.scaleMarginY + 23);
                        ctx.strokeStyle = "rgba(0,0,0,0.3)";
                        var ticklen = 7;
                    } else {
                        ctx.strokeStyle = "rgba(0,0,0,0.2)";
                        var ticklen = 4;
                    }
                    ctx.beginPath();
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px, ticklen);
                    ctx.stroke();
                }
            });
            ctx.restore();
        };

        return track;
    };

    /**
     * Implements a panel that contains a html5 canvas element
     * @param {string} id - panel type id
     * @returns {Object} - panel instance
     * @constructor
     */
    Module.PanelTrackViewer = function (id) {
        var panel = PanelBase.create(id);

        panel._offset = 0;
        panel._selStart = -1;
        panel._selEnd = -2;
        panel._zoomfactor = 1.0;
        panel._rangeMin = 0.0;
        panel._rangeMax = 1.0;
        panel._tracks = [];
        panel._minScaleUnit = 0;
        panel._maxZoomFactor = 1.0e99;
        panel._isrunning = false;
        panel._canScrollY = false;

        panel._notificationHandlersPositionChanged = [];
        panel._notificationHandlersSelectionChanged = [];

        panel.getCenterPosition = function () {
            var displayWidth = panel._width - Module._trackOffsetLeft - Module._trackOffsetRight;
            return -panel._offset + displayWidth / 2 / panel._zoomfactor;
        };

        panel.setViewPosition = function (position, zoomFactor) {
            panel._zoomfactor = Math.min(zoomFactor, panel._maxZoomFactor);
            if (!panel._isrunning) AXMUtils.Test.reportBug("Unable to set track viewer position: not initialised");
            var displayWidth = panel._width - Module._trackOffsetLeft - Module._trackOffsetRight;
            panel._offset = -position + displayWidth / 2 / panel._zoomfactor;
            panel._restrictViewToRange();
            panel.render();
            panel._notifyPosChanged();
        };

        panel.setOffsetAndZoom = function (offset, zoomFactor) {
            panel._offset = offset;
            panel._zoomfactor = zoomFactor;
            panel.render();
        };

        panel.setSelection = function (posStart, posEnd) {
            if (panel._selStart != posStart || panel._selEnd != posEnd) {
                panel._selStart = posStart;
                panel._selEnd = posEnd;
                panel.renderLayer('selection');
                panel._notifySelectionChanged();
            }
        };

        /**
         * Sets the minimum size of a single scale unit, in logical coordinates
         * @param {value} minSize
         */
        panel.setMinScaleUnit = function (minSize) {
            panel._minScaleUnit = minSize;
        };

        /**
         * Sets the maximum horizontal zoom factor
         * @param {value} fact
         */
        panel.setMaxZoomFactor = function (fact) {
            panel._maxZoomFactor = fact;
        };

        panel.addNotificationHandlersPositionChanged = function (handler) {
            panel._notificationHandlersPositionChanged.push(handler);
        };

        panel.addNotificationHandlersSelectionChanged = function (handler) {
            panel._notificationHandlersSelectionChanged.push(handler);
        };

        /**
         * Call the function to enable vertical scrolling of tracks if height becomes larger than the viewport
         */
        panel.enableScrollY = function () {
            if (panel._isrunning) AXMUtils.Test.reportBug("Cannot perform this action when viewer is running");
            panel._canScrollY = true;
        };

        /**
         * Sets the X range of the viewer
         * @param {value} rangeMin
         * @param {value} rangeMax
         */
        panel.setRange = function (rangeMin, rangeMax) {
            panel._rangeMin = rangeMin;
            panel._rangeMax = rangeMax;
            panel._restrictViewToRange();
            panel.render();
        };

        panel.addTrack = function (itrack) {
            AXMUtils.Test.checkIsType(itrack, '@TrackViewTrack');
            itrack.setViewerPanel(panel);
            panel._tracks.push(itrack);
        };

        panel.getRangeMin = function () {
            return panel._rangeMin;
        };

        panel.getRangeMax = function () {
            return panel._rangeMax;
        };

        /**
         * Clips a x position to the viewer range
         * @param {number} xval - logical x position
         * @returns {number} - clipped value
         */
        panel.clipToRange = function (xval) {
            return Math.max(panel._rangeMin, Math.min(panel._rangeMax, xval));
        };

        panel.getOffset = function () {
            return panel._offset;
        };

        panel.getZoomFactor = function () {
            return panel._zoomfactor;
        };

        panel.XDisplay2Logic = function (xdisp) {
            return xdisp / panel._zoomfactor - panel._offset;
        };

        panel.XPosLogic2Display = function (xposlogic) {
            return (xposlogic + panel._offset) * panel._zoomfactor;
        };

        panel.XLenLogic2Display = function (xlenlogic) {
            return xlenlogic * panel._zoomfactor;
        };

        panel.getXScale = function () {
            return DrawUtils.getScaleJump(30 / panel.getZoomFactor());
        };

        /**
         * Returns the html implementing the panel
         * @returns {string}
         */
        panel.createHtml = function () {
            var rootDiv = DOM.Div({ id: panel.getId() + '_content' });
            rootDiv.addCssClass('AXMHtmlPanelBody');
            rootDiv.addStyle('width', '100%');
            rootDiv.addStyle('height', '100%');
            rootDiv.addStyle('overflow-x', 'hidden');
            if (panel._canScrollY) rootDiv.addStyle('overflow-y', 'scroll');else rootDiv.addStyle('overflow-y', 'hidden');

            $.each(panel._tracks, function (idx, track) {
                rootDiv.addElem(track.createHtml());
            });

            return rootDiv.toString();
        };

        /**
         * Attached html event handlers after DOM insertion
         */
        panel.attachEventHandlers = function () {
            panel._isrunning = true;
            $.each(panel._tracks, function (idx, track) {
                track.attachEventHandlers();
            });
        };

        /**
         * Detach html event handlers
         */
        panel.detachEventHandlers = function () {
            $.each(panel._tracks, function (idx, track) {
                track.detachEventHandlers();
            });
        };

        /**
         * Resizes the panel
         * @param {int} xl - new x dimension
         * @param {int} yl - new y dimension
         * @param params
         */
        panel.resize = function (xl, yl, params) {
            panel._width = xl;
            panel._height = yl;
            panel._restrictViewToRange();
            panel.rescale(params);
        };

        panel.rescale = function (params) {
            var fixedPortionH = 0;
            var variablePortionBudget = 0;
            var hasVariableHeightTracks = false;
            $.each(panel._tracks, function (idx, track) {
                if (track.isVisible()) {
                    fixedPortionH += Module._trackMarginV;
                    if (track.hasFixedHeight()) fixedPortionH += track.getFixedHeight();else {
                        hasVariableHeightTracks = true;
                        variablePortionBudget += 1;
                    }
                }
            });
            if (panel._canScrollY && hasVariableHeightTracks) AXMUtils.Test.reportBug("Vertical scroll on track viewer is not compatible with auo scalable tracks");

            $.each(panel._tracks, function (idx, track) {
                var tyl = null;
                if (!track.hasFixedHeight()) tyl = (panel._height - fixedPortionH) * 1.0 / variablePortionBudget;
                track.resize(panel._width, tyl, params);
            });
            panel.render();
        };

        panel.render = function () {
            if (!panel._isrunning) return;
            $.each(panel._tracks, function (idx, track) {
                if (track.isVisible()) {
                    track.render();
                }
            });
        };

        panel.renderLayer = function (layerId) {
            if (!panel._isrunning) return;
            $.each(panel._tracks, function (idx, track) {
                if (track.isVisible()) {
                    track.renderLayer(layerId);
                }
            });
        };

        /**
         * Modifies zoom & offset in order to fit it into the view range
         * @private
         */
        panel._restrictViewToRange = function () {
            if (!panel._isrunning || panel._width < 5) return;
            var displayWidth = panel._width - Module._trackOffsetLeft - Module._trackOffsetRight;
            panel._zoomfactor = Math.max(panel._zoomfactor, displayWidth / 1.1 / (panel._rangeMax - panel._rangeMin));

            panel._offset = Math.max(panel._offset, -panel._rangeMax + displayWidth * 29.0 / 30.0 / panel._zoomfactor);

            panel._offset = Math.min(panel._offset, -panel._rangeMin + displayWidth / 30.0 / panel._zoomfactor);
        };

        panel._handleZoom = function (scaleFactor, centralPx) {
            var z1 = panel._zoomfactor;
            var z2 = panel._zoomfactor * scaleFactor;
            z2 = Math.min(z2, panel._maxZoomFactor);
            panel._zoomfactor = z2;
            panel._offset = panel._offset + (1.0 / z2 - 1.0 / z1) * centralPx;
            panel._restrictViewToRange();
            panel.render();
            panel._notifyPosChanged();
        };

        panel._handleMoveX = function (offsetDiff, donotUpdate) {
            panel._offset += offsetDiff;
            panel._restrictViewToRange();
            if (!donotUpdate) {
                panel.render();
                panel._notifyPosChanged();
            }
        };

        /**
         * Returns the X position contained in a html event object
         * @param {{}} ev - html event object
         * @returns {number} - returns the X position
         */
        panel._getEventPosX = function (ev) {
            //todo: improve (a bit of a hack right now)
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            return ev1.pageX - panel._tracks[0].cnvs.getCanvas$El('main').offset().left;
        };

        panel._handleScrolled = function (params, track) {
            var deltaY = params.deltaY;
            if (!params.controlPressed) {
                // Scroll action used for zoom
                if (deltaY != 0) {
                    if (deltaY < 0) //zoom out
                        var scaleFactor = 1.0 / (1.0 + 0.2 * Math.abs(deltaY));else //zoom in
                        var scaleFactor = 1.0 + 0.2 * Math.abs(deltaY);
                    var px = panel._getEventPosX(params.event);
                    panel._handleZoom(scaleFactor, px);
                }
                var deltaX = params.deltaX;
                if (deltaX != 0) {
                    panel._handleMoveX(deltaX * 30 / panel._zoomfactor);
                }
            } else {
                // Scroll action used for vertical scrolling
                track.shiftOffsetY(deltaY * 20);
            }
        };

        panel._panningStart = function (params, panningTrack) {
            panel._hasDragged = false;
            panel._hasPannedX = false;
            panel._hasPannedY = false;
            panel._panning_x0 = 0;
            panel._panning_y0 = 0;
            panel._panningTrack = panningTrack;
        };

        panel._panningDo = function (dragInfo) {
            var movedY = false;
            var movedX = false;
            if (Math.abs(dragInfo.diffTotalX) > 5) panel._hasPannedX = true;
            if (Math.abs(dragInfo.diffTotalY) > 5) panel._hasPannedY = true;
            if (panel._hasPannedY) {
                panel._panningTrack.shiftOffsetY(dragInfo.diffTotalY - panel._panning_y0, false);
                panel._panning_y0 = dragInfo.diffTotalY;
                movedY = true;
            }
            if (panel._hasPannedX) {
                panel._handleMoveX((dragInfo.diffTotalX - panel._panning_x0) / panel._zoomfactor, false);
                panel._panning_x0 = dragInfo.diffTotalX;
                movedX = true;
            }
            if (movedY || movedX) //we need to render explicitly in this case
                panel.render();
            if (panel._hasPannedX || panel._hasPannedY) panel._hasDragged = true;
        };

        panel._panningStop = function () {
            panel._hasPannedX = false;
            panel._hasPannedY = false;
            setTimeout(function () {
                panel._hasDragged = false;
            }, 250);
        };

        panel.isPanning = function () {
            return panel._hasPannedX || panel._hasPannedY;
        };

        panel.hasDragged = function () {
            return !!panel._hasDragged;
        };

        panel._notifyPosChanged = function () {
            $.each(panel._notificationHandlersPositionChanged, function (idx, handler) {
                handler();
            });
        };

        panel._notifySelectionChanged = function () {
            $.each(panel._notificationHandlersSelectionChanged, function (idx, handler) {
                handler();
            });
        };

        return panel;
    };

    Module.FrameTrackViewer = function (toolBoxWidth) {
        var thePanel = Module.PanelTrackViewer();
        var theFrame = Frame.FrameFinalCommands(thePanel);

        theFrame.trackControlsGroup = Controls.Compound.GroupVert({ separator: 3 });
        theFrame._popupMenuExtraControlsGroup = Controls.Compound.GroupVert({ separator: 3 });

        var toolBox = Frame.ToolBox.create(Icon.createFA('fa-bars'), Controls.Compound.FixedWidth(Controls.Compound.StandardMargin(Controls.Compound.GroupVert({ separator: 10 }, [theFrame.trackControlsGroup, theFrame._popupMenuExtraControlsGroup])), toolBoxWidth));

        theFrame.setToolBox(toolBox);

        theFrame.getPanel = function () {
            return thePanel;
        };

        theFrame.addCommandSpacer(40);

        theFrame.addCommand({
            icon: Icon.createFA("fa-search-plus").addDecorator('fa-arrows-h', 'left', 0, 'bottom', -7, 0.6),
            hint: _TRL("Zoom in")
        }, function () {
            var displayWidth = thePanel._width - Module._trackOffsetLeft - Module._trackOffsetRight;
            thePanel._handleZoom(1.2, displayWidth / 2);
        });

        theFrame.addCommand({
            icon: Icon.createFA("fa-search-minus").addDecorator('fa-arrows-h', 'left', 0, 'bottom', -7, 0.6),
            hint: _TRL("Zoom out")
        }, function () {
            var displayWidth = thePanel._width - Module._trackOffsetLeft - Module._trackOffsetRight;
            thePanel._handleZoom(0.8, displayWidth / 2);
        });

        theFrame.addExtraPopupMenuControl = function (ctrl) {
            theFrame._popupMenuExtraControlsGroup.add(ctrl);
        };

        theFrame.addTrack = function (track) {
            var $El = $('#' + thePanel.getId() + '_content');
            var isLive = thePanel._isrunning;
            thePanel.addTrack(track);

            if (isLive) {
                $El.append(track.createHtml());
                track.attachEventHandlers();
            }

            if (track.canHide()) {
                track.__ctrl_visible = Controls.Check({ text: track.getName(), checked: track.isVisible() });
                theFrame.trackControlsGroup.add(track.__ctrl_visible);
                theFrame.trackControlsGroup.liveUpdate();
                track.__ctrl_visible.addNotificationHandler(function () {
                    track.setVisible(track.__ctrl_visible.getValue());
                    thePanel.rescale({ resizing: false });
                });
            }
            if (isLive) {
                thePanel.rescale({ resizing: false });
            }
        };

        return theFrame;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, DOM) {

    var Module = {};

    /**
     * Creates an object that encapsulates a layered canvas element
     * @param {string} id - unique id of the canvas element
     * @param [] layers - list of layer ids
     * @returns {{}} - canvas object instance
     * @constructor
     */
    Module.create = function (id, layers) {
        var cnvs = AXMUtils.object('@Canvas');

        cnvs._id = id;
        cnvs._canvasLayerIds = layers;
        cnvs._baseLayerId = layers[0];
        cnvs.canvasBaseId = 'CNV_' + cnvs._id + '_';
        cnvs._canvasLayerMap = {};
        $.each(cnvs._canvasLayerIds, function (idx, id) {
            cnvs._canvasLayerMap[id] = {};
        });

        /**
         * Returns the html element id of a canvas associated with a specific layer
         * @param {string} layerid - layer identifier
         * @returns {string} - html id
         */
        cnvs.getCanvasID = function (layerid) {
            if (!(layerid in cnvs._canvasLayerMap)) AXMUtils.Test.reportBug('Invalid canvas id: ' + layerid);
            return cnvs.canvasBaseId + layerid;
        };

        /**
         * Returns the jquery element of a canvas associated with a specific layer
         * @param {string} layerid - layer identifier
         * @returns {jQuery} - jquery element
         */
        cnvs.getCanvas$El = function (layerid) {
            return $("#" + cnvs.getCanvasID(layerid));
        };

        /**
         * Returns the html element of a canvas associated with a specific layer
         * @param {string} layerid - layer identifier
         * @returns {htmlElement} - html element
         */
        cnvs.getCanvasElement = function (layerid) {
            return cnvs.getCanvas$El(layerid)[0];
        };

        /**
         * Returns the html implementing the panel
         * @returns {string}
         */
        cnvs.createHtml = function () {
            var rootDiv = DOM.Div({ id: "cnvs_" + cnvs._id + '_content' });
            rootDiv.addStyle('width', '100%');
            rootDiv.addStyle('height', '100%');
            rootDiv.addStyle('overflow', 'hidden');

            $.each(cnvs._canvasLayerIds, function (idx, layerid) {
                var cnv = DOM.Create('canvas', { id: cnvs.getCanvasID(layerid), parent: rootDiv });
                cnv.addStyle("position", "absolute");
                cnv.addStyle("left", "0");
                cnv.addStyle("top", "0");
            });

            return rootDiv.toString();
        };

        /**
         * Resizes the panel
         * @param {int} xl - new x dimension
         * @param {int} yl - new y dimension
         * @param params
         */
        cnvs.resize = function (xl, yl, params) {
            cnvs._cnvWidth = xl;
            cnvs._cnvHeight = yl;

            var context = cnvs.getCanvasElement(cnvs._baseLayerId).getContext("2d");
            cnvs.devicePixelRatio = window.devicePixelRatio || 1;
            cnvs.backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

            cnvs.ratio = cnvs.devicePixelRatio / cnvs.backingStoreRatio;

            $.each(cnvs._canvasLayerIds, function (idx, layerid) {
                var $El = cnvs.getCanvas$El(layerid);
                $El.width(cnvs._cnvWidth + 'px');
                $El.height(cnvs._cnvHeight + 'px');
            });

            if (!params.resizing) {
                $.each(cnvs._canvasLayerIds, function (idx, layerid) {
                    var canvasElement = cnvs.getCanvasElement(layerid);
                    if (canvasElement) {
                        canvasElement.width = cnvs._cnvWidth * cnvs.ratio;
                        canvasElement.height = cnvs._cnvHeight * cnvs.ratio;
                    }
                });
            }
        };

        cnvs.getHeight = function () {
            return cnvs._cnvHeight;
        };

        cnvs.getRenderContext = function (layerId) {
            var ctx = cnvs.getCanvasElement(layerId).getContext("2d");
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(cnvs.ratio, cnvs.ratio);
            return ctx;
        };

        /**
         * Renders the drawing in the canvas element
         */
        cnvs.render_exec = function (layerid) {
            var ctx = cnvs.getRenderContext(layerid);
            //ctx.fillStyle="#FFFFFF";
            //ctx.fillRect(0, 0, cnvs._cnvWidth,cnvs._cnvHeight);
            var drawInfo = {
                ctx: ctx,
                sizeX: cnvs._cnvWidth,
                sizeY: cnvs._cnvHeight,
                layerId: layerid
            };
            cnvs.draw(drawInfo);
        };

        /**
         * Renders the drawing in the canvas element for all layers
         */
        cnvs.render = function () {
            $.each(cnvs._canvasLayerIds, function (idx, layerId) {
                cnvs.render_exec(layerId);
            });
        };

        /**
         * Renders the drawing in the canvas element for a specific layer
         */
        cnvs.renderLayer = function (layerId) {
            cnvs.render_exec(layerId);
        };

        /**
         * Implements the drawing to the canvas element (to be overriden in derived classes)
         * @param {{}} drawInfo - drawing info
         * @param {} drawInfo.ctx - drawing context
         * @param {int} drawInfo.sizeX - X size
         * @param {int} drawInfo.sizeY - Y size
         * @param {string} drawInfo.layerId - layer ID
         */
        cnvs.draw = function (drawInfo) {
            drawInfo.ctx.beginPath();
            drawInfo.ctx.moveTo(0, 0);
            drawInfo.ctx.lineTo(drawInfo.sizeX, drawInfo.sizeY);
            drawInfo.ctx.stroke();
        };

        /**
         * Returns the X position contained in a html event object
         * @param {{}} ev - html event object
         * @returns {number} - returns the X position
         */
        cnvs.getEventPosX = function (ev) {
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            return ev1.pageX - cnvs.getCanvas$El(cnvs._baseLayerId).offset().left;
        };

        /**
         * Returns the Y position contained in a html event object
         * @param {{}} ev - html event object
         * @returns {number} - returns the Y position
         */
        cnvs.getEventPosY = function (ev) {
            var ev1 = ev;
            if (ev.originalEvent) ev1 = ev.originalEvent;
            return ev1.pageY - cnvs.getCanvas$El(cnvs._baseLayerId).offset().top;
        };

        /**
         * Converts a canvas X position to browser x position
         * @param {int} px - x position
         * @returns {int}
         */
        cnvs.posXCanvas2Screen = function (px) {
            return px + cnvs.getCanvas$El(cnvs._baseLayerId).offset().left;
        };

        /**
         * Converts a canvas Y position to browser y position
         * @param {int} py - y position
         * @returns {int}
         */
        cnvs.posYCanvas2Screen = function (py) {
            return py + cnvs.getCanvas$El(cnvs._baseLayerId).offset().top;
        };

        /**
         * Saves the canvas element content to a data url
         */
        cnvs.save = function () {
            var dataUrl = cnvs.getCanvasElement(cnvs._baseLayerId).toDataURL('image/png');
            window.open(dataUrl, '_blank');
        };

        return cnvs;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(12), __webpack_require__(6), __webpack_require__(10), __webpack_require__(11), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Utils, Test, Popupwin, Frame, PanelHtml, Controls) {

    /**
     * Module encapsulating a popup window that is displaying a structured log file
     * @type {{}}
     */
    var Module = {};

    /**
     * Creates a list of log lines for a dictionary without timestamps
     * @param {object} metaDict - target dict
     */
    Module.dictToLogText = function (metaDict) {
        var logContent = '';

        $.each(metaDict, function (key, value) {
            if (Utils.isString(value)) {
                var valueContent = value;
                while (valueContent.indexOf('$|$') >= 0) {
                    valueContent = valueContent.replace('$|$', '<br>');
                }logContent += '<div class="AXMLogLine"><b>' + key + ': </b>' + valueContent + '</div>';
            }
        });

        return logContent;
    };

    /**
     * Creates a list of log lines without timestamps or other layout
     * @param {object} logLines - target lines
     */
    Module.baseLogText = function (logLines) {
        var logContent = '';

        $.each(logLines, function (idx, logLine) {
            logContent += '<div class="AXMLogLine">' + logLine + '</div>';
        });

        return logContent;
    };

    /**
     * Parse the log lines
     * @param {array} logLines - array of log lines
     */
    Module.parseLogLines = function (logLines) {
        var fmtLogContent = '';
        var sectionStack = [];

        $.each(logLines, function (idx, logLine) {

            var timeStamp = logLine.substring(0, 19);
            logLine = logLine.substring(20);
            if (logLine.substring(0, 2) == '#@') {
                logLine = logLine.substring(2);
                if (logLine.indexOf('>SECT>') == 0) {
                    fmtLogContent += '<div class="reportunit">';
                    var sectionTitle = logLine.substring('>SECT>'.length);
                    sectionStack.push({
                        tme: new Date(timeStamp.replace(/-/g, "/")).getTime(),
                        title: sectionTitle
                    });
                    var sectionLevel = sectionStack.length;
                    var headerLine = '<div class="reportheader"><h{levela}>{title}</h{levelb}></div>'.AXMInterpolate({ levela: sectionLevel, levelb: sectionLevel, title: sectionTitle });
                    fmtLogContent += headerLine;
                    fmtLogContent += '<div class="reportbody">';
                }
                if (logLine.indexOf('<SECT<') == 0) {
                    var tme = new Date(timeStamp.replace(/-/g, "/")).getTime();
                    if (sectionStack.length == 0) Utils.reportBug('Closing section is not matched by opening section on line ' + idx);
                    var sectionInfo = sectionStack.pop();
                    var timeDiff = (tme - sectionInfo.tme) / 1000;
                    var timeDiffStr = timeDiff % 60 + 's';
                    timeDiff = Math.floor(timeDiff / 60);
                    if (timeDiff > 0) {
                        timeDiffStr = timeDiff % 60 + 'm' + timeDiffStr;
                        timeDiff = Math.floor(timeDiff / 60);
                        if (timeDiff > 0) {
                            timeDiffStr = timeDiff % 60 + 'h' + timeDiffStr;
                        }
                    }
                    fmtLogContent += '<div class="AXMLogElapsedInfo">{title} elapsed {str}</div>'.AXMInterpolate({ title: sectionInfo.title, str: timeDiffStr });
                    fmtLogContent += '</div></div>';
                }
                if (logLine.indexOf('>WARNING>') == 0) {
                    fmtLogContent += '<div class="AXMLogWarning">';
                }
                if (logLine.indexOf('<WARNING<') == 0) {
                    fmtLogContent += '</div>';
                }
                if (logLine.indexOf('>ERROR>') == 0) {
                    fmtLogContent += '<div class="AXMLogError">';
                }
                if (logLine.indexOf('<ERROR<') == 0) {
                    fmtLogContent += '</div>';
                }
            } else {
                while (logLine.indexOf('$|$') >= 0) {
                    logLine = logLine.replace('$|$', '<br>');
                }fmtLogContent += '<div class="AXMLogLine"><span class="AXMLogTimeStamp">' + timeStamp + '</span> ' + logLine + '</div>';
            }
        });

        while (sectionStack.length > 0) {
            var sectionInfo = sectionStack.pop();
            fmtLogContent += '<div class="AXMLogElapsedInfo" style="color: orangered">{title} busy</div>'.AXMInterpolate({ title: sectionInfo.title });
            fmtLogContent += '</div></div>';
        }

        return fmtLogContent;
    };

    /**
     * Creates a popup window that is displaying a structured log file
     * @param {string} title - popup title
     * @param {string} logContent - structured log content
     * @param {object} settings - meta information about the log containing additional settings
     * @constructor
     */
    Module.create = function (title, logContent, settings) {

        var fmtLogContent = '';
        var logLines = logContent.split('\n');

        if (settings.meta) {
            fmtLogContent += '<div class="reportunit">';
            fmtLogContent += '<div class="reportheader"><h1>Information</h1></div>';
            fmtLogContent += '<div class="reportbody">';
            fmtLogContent += Module.dictToLogText(settings.meta);
            fmtLogContent += '</div></div>';
        }

        if (settings.warning) fmtLogContent += '<div class="AXMLogWarning">';
        if (settings.error) fmtLogContent += '<div class="AXMLogError">';

        fmtLogContent += '<div class="reportunit">';
        fmtLogContent += '<div class="reportheader"><h1>Content</h1></div>';
        fmtLogContent += '<div class="reportbody">';
        fmtLogContent += Module.parseLogLines(logLines);
        fmtLogContent += '</div></div>';

        if (settings.stackTrace) {
            fmtLogContent += '<div class="reportunit">';
            fmtLogContent += '<div class="reportheader"><h1>Stack trace</h1></div>';
            fmtLogContent += '<div class="reportbody">';
            fmtLogContent += Module.baseLogText(settings.stackTrace.split('\n'));
            fmtLogContent += '</div></div>';
        }

        if (settings.warning) fmtLogContent += '</div>';
        if (settings.error) fmtLogContent += '</div>';

        var win = Popupwin.create({
            title: title,
            autoCenter: true,
            closeOnEscape: true,
            sizeX: 700,
            sizeY: 500
        });

        /**
         * Initialises the popup
         */
        win.init = function () {

            win.panelHtml = PanelHtml.create('intro');
            win.panelHtml.enableVScrollBar().enableHScrollBar();
            var rootFrame = Frame.FrameFinalCommands(win.panelHtml);

            var bt_noWrap = rootFrame.addCommand({
                icon: "fa-align-left",
                hint: "Do not wrap log lines"
            }, function () {
                win.noWrap = !win.noWrap;
                bt_noWrap.setChecked(win.noWrap);
                if (win.noWrap) win.panelHtml.get$El().find('.AXMLogLine').addClass('AXMLogLineNoWrap');else win.panelHtml.get$El().find('.AXMLogLine').removeClass('AXMLogLineNoWrap');
            });

            win.panelHtml.setContent(fmtLogContent);

            win.setRootFrame(rootFrame);
            win.start();

            win.panelHtml.get$El().find('.reportheader').click(function (ev) {
                $(this).parent().children('.reportbody').slideToggle(300);
            });
        };

        win.init();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(19), __webpack_require__(20), __webpack_require__(2), __webpack_require__(8), __webpack_require__(21), __webpack_require__(7), __webpack_require__(3), __webpack_require__(10), __webpack_require__(6), __webpack_require__(11), __webpack_require__(9), __webpack_require__(55), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, Blob, FileSaver, AXMUtils, Color, DrawUtils, Msg, Controls, Frame, PopupWindow, PanelHtml, DataTypes, PromptPlot, Table) {

    var Module = {};

    Module.DataTypes = DataTypes;

    Module._objectTypes = {};

    Module.extraTokenDelimiter = '==';

    Module.property = function (propId, propDispName, propType, settings) {
        var property = {
            _propId: propId,
            _propCat: '',
            _propDispName: propDispName,
            _propDispNamePart: propDispName,
            _propType: propType,
            data: []
        };

        var tokens = propDispName.split(': ');
        if (tokens.length == 2) {
            property._propCat = tokens[0];
            property._propDispNamePart = tokens[1];
        }

        property._isCategorical = propType.isCategorical();
        if (property._isCategorical) property._category2ColorMapper = AXMUtils.PersistentAssociator(Color.standardColors.length);

        property.clone = function () {
            var prop = Module.property(property._propId, property._propDispName, property._propType, {});
            return prop;
        };

        property.getId = function () {
            return property._propId;
        };

        property.getCategory = function () {
            return property._propCat;
        };

        property.getDispName = function () {
            return property._propDispName;
        };

        property.getDispNamePart = function () {
            return property._propDispNamePart;
        };

        property.getDataType = function () {
            return property._propType;
        };

        property.getValueRange = function () {
            if (!property.getDataType().includes(DataTypes.typeFloat)) AXMUtils.Test.reportBug(_TRL('Property is not numerical'));
            var minValue = +1.0E99;
            var maxValue = -1.0E99;
            var data = property.data;
            for (var rowNr = 0; rowNr < data.length; rowNr++) {
                var val = data[rowNr];
                if (val !== null) {
                    if (val < minValue) minValue = val;
                    if (val > maxValue) maxValue = val;
                }
            }
            return AXMUtils.valueRange(minValue, maxValue);
        };

        // Returns a color legend
        property.mapColors = function (valList) {
            var colorLegend = [];
            if (property._isCategorical) {
                var uniqueCatMap = {};
                var uniqueCats = [];
                for (var i = 0; i < valList.length; i++) {
                    if (!uniqueCatMap[valList[i]]) {
                        uniqueCatMap[valList[i]] = true;
                        uniqueCats.push(valList[i]);
                    }
                }
                if (uniqueCats.length > 25) //can't do anything good here...
                    return colorLegend;
                property._category2ColorMapper.map(uniqueCats);
                $.each(uniqueCats, function (idx, catStr) {
                    colorLegend.push({
                        content: property.content2DisplayString(catStr),
                        color: property.getSingleColor(catStr)
                    });
                });
            }
            if (DataTypes.typeFloat.includes(property.getDataType())) {
                var range = property.getValueRange();
                property._colorRangeMin = range.getMin();
                property._colorRangeMax = range.getMax();
                property._colorRange = range.getMax() - range.getMin();

                var scale = DrawUtils.getScaleJump(property._colorRange / 20);
                for (var i = Math.ceil(property._colorRangeMin / scale.Jump1); i <= Math.floor(property._colorRangeMax / scale.Jump1); i++) {
                    if (i % scale.JumpReduc == 0) {
                        var value = i * scale.Jump1;
                        var fr = (value - property._colorRangeMin) / property._colorRange;
                        colorLegend.push({
                            content: scale.value2String(value),
                            color: Color.HSL2Color(0.5 - fr * 0.75, 0.6, 0.5)
                        });
                    }
                }
            }
            return colorLegend;
        };

        property.getSingleColor = function (val) {
            if (property._isCategorical) {
                var idx = property._category2ColorMapper.get(val);
                if (idx >= 0) return Color.standardColors[idx];
                return Color.Color(0.5, 0.5, 0.5);
            }
            if (DataTypes.typeFloat.includes(property.getDataType())) {
                var fr = (val - property._colorRangeMin) / property._colorRange;
                return Color.HSL2Color(0.5 - fr * 0.75, 0.6, 0.5);
            }
            return Color.Color(0, 0, 0);
        };

        property.content2DisplayString = function (val) {
            if (val === null) return '';
            return String(val);
        };

        if (propType.getId() == 'typeBoolean') {
            property.content2DisplayString = function (val) {
                if (val === true) return 'True';
                if (val === false) return 'False';
                return '';
            };
        }

        return property;
    };

    Module.createObjectType = function (typeId, primKey) {
        if (Module._objectTypes[typeId]) AXMUtils.Test.reportBug(_TRL('Dataframe object type already exists: ') + typeId);
        var objectType = {
            typeId: typeId,
            primKey: primKey,
            _defaultTooltip: primKey
        };
        objectType._properties = [];
        objectType._mapProperties = {};

        objectType._selectedRowIds = {};

        objectType.getTypeId = function () {
            return objectType.typeId;
        };

        objectType.setPrimKey = function (colId) {
            objectType.primKey = colId;
        };

        objectType.getPrimKey = function () {
            return objectType.primKey;
        };

        objectType.hasProperty = function (propId) {
            return !!objectType._mapProperties[propId];
        };

        objectType.getProperty = function (propId) {
            var prop = objectType._mapProperties[propId];
            if (!prop) AXMUtils.Test.reportBug(_TRL('Invalid objectType property id: ') + propId);
            return prop;
        };

        objectType.addProperty = function (property) {
            if (objectType._mapProperties[property.getId()]) AXMUtils.Test.reportBug(_TRL('Duplicate objectType property id: ') + property.getId());
            objectType._properties.push(property);
            objectType._mapProperties[property.getId()] = property;
        };

        objectType.setDefaultTooltip = function (propId) {
            objectType._defaultTooltip = propId;
        };

        objectType.getDefaultTooltip = function () {
            return objectType._defaultTooltip;
        };

        objectType.setOpenHandler = function (handler) {
            //AXMUtils.Test.isFunction(handler);
            objectType._onOpenHandler = handler;
        };

        objectType.getOpenHandler = function () {
            return objectType._onOpenHandler;
        };

        objectType.rowSelClear = function () {
            objectType._selectedRowIds = {};
        };

        objectType.rowSelSet = function (rowId, status) {
            objectType._selectedRowIds[rowId] = status;
        };

        objectType.rowSelGet = function (rowId) {
            return !!objectType._selectedRowIds[rowId];
        };

        objectType.rowSelGetList = function () {
            var lst = [];
            $.each(objectType._selectedRowIds, function (key, val) {
                lst.push(key);
            });
            return lst;
        };

        objectType.rowSelNotifyChanged = function () {
            Msg.broadcast('DataFrameRowSelChanged', objectType.typeId);
        };

        Module._objectTypes[typeId] = objectType;
        return objectType;
    };

    // Create a new data frame
    Module.createDataFrame = function (objectTypeId, name) {
        var dataFrame = {};
        dataFrame.id = AXMUtils.getUniqueID();
        dataFrame.objectType = Module._objectTypes[objectTypeId];
        if (!dataFrame.objectType) {
            dataFrame.objectType = Module.createObjectType(objectTypeId, 'id');
        }
        dataFrame._rowCount = 0;
        dataFrame._extraTokens = {};
        dataFrame._properties = [];
        dataFrame._mapProperties = {};
        dataFrame._name = name;

        dataFrame._rowOpenHandlers = [];

        dataFrame.getObjectType = function () {
            return dataFrame.objectType;
        };

        dataFrame.getRowOpenHandlerList = function () {
            return dataFrame._rowOpenHandlers;
        };

        dataFrame.addExtraToken = function (key, value) {
            dataFrame._extraTokens[key] = value;
        };

        dataFrame.addRowOpenHandler = function (name, handler) {
            dataFrame._rowOpenHandlers.push({
                name: name,
                handler: handler
            });
        };

        dataFrame.addProperty = function (propId, propDispName, propType, settings) {
            if (dataFrame._mapProperties[propId]) AXMUtils.Test.reportBug(_TRL('Duplicate dataframe property id: ' + propId));
            if (!dataFrame.objectType.hasProperty(propId)) {
                var propInfo = Module.property(propId, propDispName, propType, settings);
                dataFrame.objectType.addProperty(propInfo);
            }
            var propInfo = dataFrame.objectType.getProperty(propId).clone();
            dataFrame._properties.push(propInfo);
            for (var i = 0; i < dataFrame._rowCount; i++) {
                propInfo.data.push(null);
            }dataFrame._mapProperties[propId] = propInfo;
            return propInfo;
        };

        dataFrame.getName = function () {
            return dataFrame._name;
        };

        dataFrame.setName = function (name) {
            return dataFrame._name = name;
        };

        dataFrame.getProperties = function () {
            return dataFrame._properties;
        };

        dataFrame.hasProperty = function (propId) {
            return !!dataFrame._mapProperties[propId];
        };

        dataFrame.getProperty = function (propId) {
            var prop = dataFrame._mapProperties[propId];
            if (!prop) AXMUtils.Test.reportBug(_TRL('Dataframe does not have property ') + propId);
            return prop;
        };

        dataFrame.getPrimKeyProperty = function () {
            return dataFrame.getProperty(dataFrame.objectType.primKey);
        };

        dataFrame.getRowCount = function () {
            return dataFrame._rowCount;
        };

        dataFrame.getRowInfo = function (rowNr) {
            var rowInfo = {};
            $.each(dataFrame._properties, function (idx, prop) {
                rowInfo[prop.getId()] = prop.data[rowNr];
            });
            return rowInfo;
        };

        dataFrame.addRow = function (rowInfo) {
            dataFrame._rowCount += 1;
            $.each(dataFrame._properties, function (idx, prop) {
                var cell = rowInfo[prop.getId()];
                //if (!cell)
                //    cell = null;
                prop.data.push(cell);
            });
        };

        dataFrame.append = function (sourceDataFrame) {
            for (var rowNr = 0; rowNr < sourceDataFrame.getRowCount(); rowNr++) {
                dataFrame.addRow(sourceDataFrame.getRowInfo(rowNr));
            }
        };

        dataFrame.copyProperty = function (sourceDataFrame, srcPropId, destPropId, mergePropId, srcMergePropId) {
            if (!destPropId) destPropId = AXMUtils.getUniqueID();
            var propInfo = sourceDataFrame.getProperty(srcPropId);
            var newProp = dataFrame.addProperty(destPropId, sourceDataFrame.getName() + ': ' + propInfo.getDispName(), propInfo.getDataType(), {});
            var mergeProperty = dataFrame.getProperty(mergePropId);
            var sourceMergeProperty = sourceDataFrame.getProperty(srcMergePropId);
            var sourceMap = {};
            for (var rowNr = 0; rowNr < sourceDataFrame.getRowCount(); rowNr++) {
                sourceMap[sourceMergeProperty.data[rowNr]] = rowNr;
            }for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var newVal = null;
                var ID = mergeProperty.data[rowNr];
                if (ID in sourceMap) newVal = propInfo.data[sourceMap[ID]];
                newProp.data[rowNr] = newVal;
            }
        };

        dataFrame.calculateProperty = function (destPropId, dataType, expression) {
            if (!destPropId) destPropId = AXMUtils.getUniqueID();
            var newProp = dataFrame.addProperty(destPropId, destPropId, DataTypes.typesMap[dataType], {});
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var newVal = null;
                try {
                    var pt = {};
                    $.each(dataFrame.getProperties(), function (idx, property) {
                        pt[property.getId()] = property.data[rowNr];
                    });
                    newVal = eval(expression);
                } catch (err) {}
                newProp.data[rowNr] = newVal;
            }
        };

        dataFrame.createSelectedRowsDataFrame = function () {
            var subFrame = Module.createDataFrame(dataFrame.objectType.typeId);
            $.each(dataFrame.getProperties(), function (idx, propInfo) {
                subFrame.addProperty(propInfo.getId());
            });
            $.each(dataFrame._extraTokens, function (key, value) {
                subFrame.addExtraToken(key, value);
            });
            var rowSelGet = dataFrame.objectType.rowSelGet;
            var dataPrimKey = dataFrame.getPrimKeyProperty().data;
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                if (rowSelGet(dataPrimKey[rowNr])) {
                    var rowInfo = dataFrame.getRowInfo(rowNr);
                    subFrame.addRow(rowInfo);
                }
            }
            return subFrame;
        };

        dataFrame.groupBy = function (objectTypeID, groupByProperties, outputProperties) {

            var getAggregator_Any = function getAggregator_Any() {
                var aggr = {
                    value: null
                };
                aggr.add = function (value) {
                    aggr.value = value;
                };
                aggr.finish = function () {
                    return aggr.value;
                };
                return aggr;
            };

            var getAggregator_Average = function getAggregator_Average() {
                var aggr = {
                    count: 0,
                    sum: 0
                };
                aggr.add = function (value) {
                    aggr.count += 1;
                    aggr.sum += value;
                };
                aggr.finish = function () {
                    if (aggr.count > 0) return aggr.sum * 1.0 / aggr.count;else return null;
                };
                return aggr;
            };

            var getAggregator_StandardDeviation = function getAggregator_StandardDeviation() {
                var aggr = {
                    n: 0.0,
                    mean: 0.0,
                    M2: 0.0
                };
                aggr.add = function (x) {
                    aggr.n += 1.0;
                    var delta = x - aggr.mean;
                    aggr.mean += delta / aggr.n;
                    aggr.M2 += delta * (x - aggr.mean);
                };
                aggr.finish = function () {
                    if (aggr.n > 1) return Math.sqrt(aggr.M2 / aggr.n);else return null;
                };
                return aggr;
            };

            var getAggregator_Count = function getAggregator_Count() {
                var aggr = {
                    count: 0
                };
                aggr.add = function (value) {
                    aggr.count += 1;
                };
                aggr.finish = function () {
                    return aggr.count;
                };
                return aggr;
            };

            var getAggregator_Enumerate = function getAggregator_Enumerate() {
                var aggr = {
                    lst: {}
                };
                aggr.add = function (value) {
                    aggr.lst[value] = true;
                };
                aggr.finish = function () {
                    var lst = [];
                    $.each(aggr.lst, function (key, val) {
                        lst.push(key);
                    });
                    return lst.join(';');
                };
                return aggr;
            };

            var aggregatorGenerators = {
                Any: getAggregator_Any,
                Average: getAggregator_Average,
                StandardDeviation: getAggregator_StandardDeviation,
                Count: getAggregator_Count,
                Enumerate: getAggregator_Enumerate
            };

            var outputFrame = Module.createDataFrame(objectTypeID);
            var newProperties = [];
            var dataFrameGroupByProperties = [];

            var propPrimKey = outputFrame.addProperty('id', 'ID', DataTypes.typeString, {});
            propPrimKey.__sourceID = null;
            propPrimKey.__aggregator = null;

            $.each(groupByProperties, function (idx, propID) {
                if (!dataFrame.hasProperty(propID)) throw "Invalid Source Property: " + propID;
                if (outputFrame.hasProperty(propID)) throw "Duplicate property: " + propID;
                var newProp = outputFrame.addProperty(propID, dataFrame.getProperty(propID).getDispName(), dataFrame.getProperty(propID).getDataType(), {});
                newProp.__sourceID = propID;
                newProp.__aggregator = aggregatorGenerators['Any'];
                newProperties.push(newProp);
                dataFrameGroupByProperties.push(dataFrame.getProperty(propID));
            });
            $.each(outputProperties, function (idx, outputInfo) {
                try {
                    if (!outputInfo.DestID) throw "Missing DestID";
                    if (!outputInfo.DestName) throw "Missing SourceName";
                    if (!outputInfo.SourceID) throw "Missing SourceID";
                    if (!dataFrame.hasProperty(outputInfo.SourceID)) throw "Invalid Source Property: " + outputInfo.SourceID;
                    if (!aggregatorGenerators[outputInfo.Aggregator]) throw "Invalid Aggregator: " + outputInfo.Aggregator;
                    if (outputFrame.hasProperty(outputInfo.DestID)) throw "Duplicate property: " + outputInfo.DestID;
                    var newProp = outputFrame.addProperty(outputInfo.DestID, outputInfo.DestName, dataFrame.getProperty(outputInfo.SourceID).getDataType(), {});
                    newProp.__sourceID = outputInfo.SourceID;
                    newProp.__aggregator = aggregatorGenerators[outputInfo.Aggregator];
                    newProperties.push(newProp);
                } catch (err) {
                    throw "Error in Group By output property:\n" + err;
                }
            });
            var propCount = outputFrame.addProperty('__count__', 'Count', DataTypes.typeFloat, {});
            propCount.__sourceID = groupByProperties[0]; //any will do...
            propCount.__aggregator = aggregatorGenerators['Count'];
            newProperties.push(propCount);

            var newRows = [];
            var newRowsMap = {};
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var signature = "";
                $.each(dataFrameGroupByProperties, function (idx, property) {
                    signature += '__' + property.data[rowNr];
                });
                if (!newRowsMap[signature]) {
                    var newRow = {};
                    newRow.__signature = signature;
                    $.each(newProperties, function (idx, newProperty) {
                        newRow[newProperty.getId()] = newProperty.__aggregator();
                    });
                    newRows.push(newRow);
                    newRowsMap[signature] = newRow;
                } else var newRow = newRowsMap[signature];
                $.each(newProperties, function (idx, newProperty) {
                    newRow[newProperty.getId()].add(dataFrame.getProperty(newProperty.__sourceID).data[rowNr]);
                });
            }
            $.each(newRows, function (idx, newRow) {
                var rowInfo = {};
                $.each(newProperties, function (idx, newProperty) {
                    rowInfo[propPrimKey.getId()] = newRow.__signature;
                    rowInfo[newProperty.getId()] = newRow[newProperty.getId()].finish();
                });
                outputFrame.addRow(rowInfo);
            });

            return outputFrame;
        };

        dataFrame.sortByProperty = function (sortPropID, sortInv) {
            var sortIdx = [];
            for (var i = 0; i < dataFrame.getRowCount(); i++) {
                sortIdx.push(i);
            }var sortVals = [];
            for (var i = 0; i < dataFrame.getRowCount(); i++) {
                sortVals.push(dataFrame.getRowInfo(i)[sortPropID]);
            }sortIdx.sort(function (idx1, idx2) {
                var val1 = sortVals[idx1];
                var val2 = sortVals[idx2];
                var discr = val1 < val2 ? -1 : val1 > val2 ? 1 : 0;
                if (discr === 0) discr = idx1 - idx2;
                if (sortInv) discr = -discr;
                return discr;
            });
            $.each(dataFrame.getProperties(), function (idx, propInfo) {
                var sortedData = [];
                for (var i = 0; i < dataFrame.getRowCount(); i++) {
                    sortedData.push(propInfo.data[sortIdx[i]]);
                }propInfo.data = sortedData;
            });
        };

        dataFrame.filterRows = function (filterFunction) {
            var filteredIndexes = [];
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var rowInfo = dataFrame.getRowInfo(rowNr);
                if (filterFunction(rowInfo)) filteredIndexes.push(rowNr);
            }
            dataFrame._rowCount = filteredIndexes.length;
            $.each(dataFrame.getProperties(), function (idx, propInfo) {
                var filteredData = [];
                for (var i = 0; i < filteredIndexes.length; i++) {
                    filteredData.push(propInfo.data[filteredIndexes[i]]);
                }propInfo.data = filteredData;
            });
        };

        dataFrame.getContentString_Raw = function () {
            var str = '';
            str += '#RD_TEXT\n';
            str += '# datatype: {tpe}\n'.AXMInterpolate({ tpe: dataFrame.getObjectType().getTypeId() });
            str += '# key: {colid}\n'.AXMInterpolate({ colid: dataFrame.getObjectType().getPrimKey() });
            $.each(dataFrame._extraTokens, function (key, value) {
                str += '# extratoken: ' + key + Module.extraTokenDelimiter + value + '\n';
            });
            $.each(dataFrame.getProperties(), function (idx, propInfo) {
                str += '# column: ' + propInfo.getId() + '\t' + propInfo.getDispName() + '\t' + propInfo.getDataType().getId() + '\n';
            });
            $.each(dataFrame.getProperties(), function (idx, propInfo) {
                if (idx > 0) str += '\t';
                str += propInfo.getId();
            });
            str += '\n';

            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                $.each(dataFrame.getProperties(), function (idx, propInfo) {
                    if (idx > 0) str += '\t';
                    str += propInfo.data[rowNr];
                });
                str += '\n';
            }
            return str;
        };

        dataFrame.getContentString_Display = function () {
            var str = '';
            $.each(dataFrame.getProperties(), function (idx, propInfo) {
                if (idx > 0) str += '\t';
                str += propInfo.getDispName();
            });
            str += '\n';
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                $.each(dataFrame.getProperties(), function (idx, propInfo) {
                    if (idx > 0) str += '\t';
                    str += propInfo.content2DisplayString(propInfo.data[rowNr]);
                });
                str += '\n';
            }
            return str;
        };

        dataFrame.createPropertySelector = function (compatibleDataType, canHaveNone) {
            var picker = Controls.DropList({ width: 240 });
            if (canHaveNone) picker.addState('', "- None -", '');
            $.each(dataFrame.getProperties(), function (idx, prop) {
                if (compatibleDataType.includes(prop.getDataType())) picker.addState(prop.getId(), prop.getDispNamePart(), prop.getCategory());
            });
            return picker;
        };

        dataFrame.promptPlot = function () {
            PromptPlot.create(dataFrame);
        };

        dataFrame.showTable = function () {
            Table.create(dataFrame);
        };

        dataFrame.showData = function () {
            var win = PopupWindow.create({
                title: 'Data',
                sizeX: 650,
                sizeY: 500,
                autoCenter: true
            });
            var content = dataFrame.getContentString_Display(false);
            var form = PanelHtml.create();
            form.enableVScrollBar();
            form.setContent('<PRE>' + content + '</PRE>');
            var rootFrame = Frame.FrameFinalCommands(form);
            win.setRootFrame(rootFrame);

            rootFrame.addCommand({
                icon: "fa-external-link"
            }, function () {
                var blob = new Blob([content], { type: "text/plain;charset=utf-8" });
                FileSaver(blob, 'data.txt');
            });

            win.start();
        };

        dataFrame.saveLocalFile = function () {
            var content = dataFrame.getContentString_Raw(true);
            var blob = new Blob([content], { type: "text/plain;charset=utf-8" });
            FileSaver(blob, dataFrame.getName());
        };

        return dataFrame;
    };

    Module.loadFromText = function (name, sourceText, showAsTable) {
        var lines = sourceText.split(/\r\n|\r|\n/g);
        var dataTypeString = "# datatype: ";
        if (lines[0] != "#RD_TEXT" || lines.length < 2 || lines[1].indexOf(dataTypeString) < 0) {
            AXMUtils.reportBug('File type not supported for creating dataframe');
            return;
        }
        var dataFrame = Module.createDataFrame(lines[1].substr(dataTypeString.length), name);
        var columnOrder = null;
        $.each(lines, function (idx, line) {
            if (line.charAt(0) == '#') {
                // Header of file
                var keyString = "# key: ";
                if (line.indexOf(keyString) == 0) {
                    var primKeyColId = line.substr(keyString.length);
                    dataFrame.getObjectType().setPrimKey(primKeyColId);
                }
                var columnString = "# column: ";
                if (line.indexOf(columnString) == 0) {
                    var columnProperties = line.substr(columnString.length).split('\t');
                    if (columnProperties.length != 3) AXMUtils.reportBug(_TRL('RD file column header does not have exactly three properties: id, description, type'));
                    if (!DataTypes[columnProperties[2]]) AXMUtils.reportBug(_TRL('RD file column header type is not supported'));
                    dataFrame.addProperty(columnProperties[0], columnProperties[1], DataTypes[columnProperties[2]]);
                }
                var extraTokenString = "# extratoken: ";
                if (line.indexOf(extraTokenString) == 0) {
                    var extraToken = line.substr(extraTokenString.length);
                    var keyValue = extraToken.split(Module.extraTokenDelimiter);
                    dataFrame.addExtraToken(keyValue[0], keyValue[1]);
                }
            } else {
                // Body of file
                var fields = line.split('\t');
                if (!columnOrder) columnOrder = fields;else {
                    if (line.length > 0 && fields.length == columnOrder.length) {
                        var rowData = {};
                        $.each(columnOrder, function (colNr, propId) {
                            //if(!fields[colNr])
                            //    rowData[propId] = fields[colNr]
                            //else
                            rowData[propId] = dataFrame.getProperty(propId).getDataType().parseString(fields[colNr]);
                        });
                        dataFrame.addRow(rowData);
                    } else if (line.length > 0 && fields.length != columnOrder.length) AXMUtils.reportBug(_TRL('RD text file row cells differs from number of columns'));
                }
            }
        });
        var objectType = dataFrame.getObjectType();
        if (!objectType.hasProperty(objectType.getPrimKey())) {
            AXMUtils.reportBug(_TRL('Dataframe should have column key column "{key}"'.AXMInterpolate({ key: objectType.getPrimKey() })));
            return;
        }
        if (showAsTable) Table.create(dataFrame);
        return dataFrame;
    };

    Module.loadLocalFile = function () {

        var input = document.createElement('input');
        input.setAttribute('type', 'file');
        input.style.display = 'none';

        input.onchange = function (e) {
            if (input.files.length > 0) {
                var file = input.files[0];

                var reader = new FileReader();

                reader.addEventListener("load", function (event) {
                    var textFile = event.target;
                    var txt = textFile.result;
                    Module.loadFromText(file.name, txt, true);
                });

                reader.readAsText(file);
            }
        };

        input.focus();
        input.click();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(35), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, Controls, SimplePopups, Plots, Table) {

    var Module = {};

    Module.create = function (dataFrame) {

        var win = PopupWindow.create({
            title: _TRL('Create a view'),
            blocking: true,
            autoCenter: true
        });

        var grp = Controls.Compound.GroupVert({});
        //grp.add(Controls.Static({text: 'Test'}));

        $.each(Plots.plotTypes, function (idx, plotType) {
            var btPlot = Controls.Button({
                text: plotType.getPlotTypeName(),
                icon: plotType.getPlotTypeIcon(),
                width: 250
            }).addNotificationHandler(function () {
                win.close();
                Module._createPlotPropertyPicker(plotType, dataFrame);
            });
            grp.add(btPlot);
        });

        var btPlot = Controls.Button({
            text: _TRL('Table'),
            icon: 'fa-table',
            width: 250
        }).addNotificationHandler(function () {
            win.close();
            Table.create(dataFrame);
        });
        grp.add(btPlot);

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    Module._createPlotPropertyPicker = function (plotType, dataFrame) {
        var win = PopupWindow.create({
            title: _TRL('Create ') + plotType.getPlotTypeName(),
            blocking: true,
            autoCenter: true
        });

        var grp = Controls.Compound.Grid({});

        win._aspectPickerMap = {};
        $.each(plotType.getPlotAspects(), function (idx, aspect) {
            grp.setItem(idx, 0, aspect.getName() + ':');
            var picker = dataFrame.createPropertySelector(aspect.getDataType(), true);
            win._aspectPickerMap[aspect.getId()] = picker;
            //var picker = Controls.DropList({width: 200});
            //win._aspectPickerMap[aspect.getId()] = picker;
            //picker.addState('', "- None -");
            //$.each(dataFrame.getProperties(), function(idx, prop) {
            //    if (aspect.getDataType().includes(prop.getDataType()))
            //    picker.addState(prop.getId(), prop.getDispName());
            //});
            if (aspect.getId() == 'tooltip') picker.setValue(dataFrame.objectType.getDefaultTooltip());
            grp.setItem(idx, 1, picker);
        });

        var btOK = Controls.Button({
            text: _TRL('Create plot'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            var aspectMap = {};
            var missingList = [];
            $.each(plotType.getPlotAspects(), function (idx, aspect) {
                var value = win._aspectPickerMap[aspect.getId()].getValue();
                if (aspect.getRequired() && !value) missingList.push(aspect.getName());
                aspectMap[aspect.getId()] = value;
            });
            if (missingList.length > 0) {
                var error = _TRL('Please provide data for the following plot aspects:<br><br><b>') + missingList.join('<br>') + '</b>';
                SimplePopups.ErrorBox(error);
                return;
            }
            win.close();
            plotType.create(dataFrame, aspectMap);
        });
        //grp.add(btOK);

        win.setRootControl(Controls.Compound.StandardMargin(Controls.Compound.GroupVert({ separator: 8 }, [grp, btOK])));
        win.start();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(8), __webpack_require__(25), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(15), __webpack_require__(9), __webpack_require__(37), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Color, PanelCanvasXYPlot, PopupWindow, Controls, SimplePopups, _GenericPlot, DataTypes, ViewRow, Stats) {

    var PlotType = _GenericPlot.createPlotType('scatterplot', _TRL('Scatter plot'), 'fa-line-chart');
    PlotType.addPlotAspect('xvalue', _TRL('X Value'), DataTypes.typeFloat, true);
    PlotType.addPlotAspect('yvalue', _TRL('Y Value'), DataTypes.typeFloat, true);
    PlotType.addPlotAspect('color', _TRL('Color'), DataTypes.typeAny, false);
    PlotType.addPlotAspect('size', _TRL('Size'), DataTypes.typeFloat, false);
    PlotType.addPlotAspect('label', _TRL('Label'), DataTypes.typeAny, false);
    PlotType.addPlotAspect('tooltip', _TRL('Hover text'), DataTypes.typeAny, false);

    PlotType.create = function (dataFrame, aspectMap) {

        var win = PlotType.createGeneric(dataFrame, aspectMap);

        win.plot = PanelCanvasXYPlot.create('', {});
        win.plot._directRedraw = true; //might be changed
        win._opacity = 0.40;

        win._curves = [];

        win.setPlotCommands = function () {
            win.button_lassoSelection = win.addPlotCommand('fa-crosshairs', _TRL('Lasso selection'), function () {
                win.plot.doLassoSelection(win._hasLassoSelected);
                win.button_lassoSelection.setChecked(true);
                var infoTxt = _TRL("Double click to complete the lasso selection");
                win.setInfoText('<div style="width:100%;padding:2px;background-color: yellow;font-weight: bold">' + infoTxt + '</div>');
            });
        };

        win._createDisplayControls = function (dispGroup) {

            win.ctrl_Opacity = Controls.Slider({
                width: 160,
                minValue: 0.1,
                maxValue: 1,
                step: 0.01,
                value: Math.pow(win._opacity, 1 / 1.5),
                text: _TRL('Opacity')
            }).addNotificationHandler(function () {
                win._opacity = Math.pow(win.ctrl_Opacity.getValue(), 1.5);
                win.render();
            });
            dispGroup.add(win.ctrl_Opacity);

            win.ctrl_PointSize = Controls.Slider({
                width: 160,
                minValue: 0.5,
                maxValue: 5,
                step: 0.2,
                value: 2,
                text: _TRL('Point size')
            }).addNotificationHandler(function () {
                win.render();
            });
            dispGroup.add(win.ctrl_PointSize);

            win.ctrl_showOutline = Controls.Check({ text: _TRL('Point outline'), checked: false }).addNotificationHandler(function () {
                win.render();
            });
            dispGroup.add(win.ctrl_showOutline);

            win.colorLegendCtrl = Controls.Static({});
            dispGroup.add(win.colorLegendCtrl);

            win.corrCtrl = Controls.Static({});
            dispGroup.add(win.corrCtrl);

            win.corrSelectCtrl = Controls.Static({});
            dispGroup.add(win.corrSelectCtrl);

            var btLine = Controls.Button({
                text: _TRL('Add curve'),
                icon: 'fa-line-chart'
            }).addNotificationHandler(win.addCurve);
            dispGroup.add(btLine);

            var btSetRange = Controls.Button({
                text: _TRL('Set range')
                //icon: 'fa-line-chart'
            }).addNotificationHandler(win.setRange);
            dispGroup.add(btSetRange);
        };

        win._appendSelectionControls = function (selGroup) {
            var btLinearFit = Controls.Button({
                text: _TRL('Draw linear fit')
            }).addNotificationHandler(win.drawLinearFit);
            selGroup.add(btLinearFit);
        };

        win.render = function () {
            win.plot.render();
        };

        win.plot.getToolTipInfo = function (px, py) {
            var dataX = win.getAspectProperty('xvalue').data;
            var dataY = win.getAspectProperty('yvalue').data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            var propTooltip = null;
            if (win.hasAspectProperty('tooltip')) propTooltip = win.getAspectProperty('tooltip');

            var coordXLogic2Win = win.plot.coordXLogic2Win;
            var coordYLogic2Win = win.plot.coordYLogic2Win;
            var minDist = 7;
            var bestRowNr = null;
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var ptPx = coordXLogic2Win(dataX[rowNr]);
                var ptPy = coordYLogic2Win(dataY[rowNr]);
                var dist = Math.abs(ptPx - px) + Math.abs(ptPy - py);
                if (dist <= minDist) {
                    minDist = dist;
                    bestRowNr = rowNr;
                }
            }
            if (bestRowNr === null) return null;

            var content = null;
            if (propTooltip) content = propTooltip.content2DisplayString(propTooltip.data[bestRowNr]);

            return {
                px: coordXLogic2Win(dataX[bestRowNr]),
                py: coordYLogic2Win(dataY[bestRowNr]),
                ID: dataPrimKey[bestRowNr],
                rowNr: bestRowNr,
                content: content,
                showPointer: true
            };
        };

        win.plot.onMouseClick = function (ev, info) {
            var tooltip = win.plot.getToolTipInfo(info.x, info.y);
            if (tooltip) win.openPoint(tooltip.rowNr);
        };

        win.updateAspect = function (aspectId) {
            var all = !aspectId;
            if (aspectId == 'xvalue' || all) {
                var rangeX = win.getAspectProperty('xvalue').getValueRange();
                rangeX.extendFraction(0.1);
                win.plot.setXRange(rangeX.getMin(), rangeX.getMax());
                win.plot.setXLabel(win.getAspectProperty('xvalue').getDispName());
                win._curves = [];
            }
            if (aspectId == 'yvalue' || all) {
                var rangeY = win.getAspectProperty('yvalue').getValueRange();
                rangeY.extendFraction(0.1);
                win.plot.setYRange(rangeY.getMin(), rangeY.getMax());
                win.plot.setYLabel(win.getAspectProperty('yvalue').getDispName());
                win._curves = [];
            }
            if (aspectId == 'xvalue' || aspectId == 'yvalue' || all) {
                win.parseData();
            }
            if (aspectId == 'color' || all) win.updateColorLegend();
            win.render();
        };

        win.updateColorLegend = function () {
            var propColor = null;
            win.colorLegendCtrl.modifyText('');
            if (win.hasAspectProperty('color')) {
                propColor = win.getAspectProperty('color');
                var dataColor = propColor.data;
                var legendData = propColor.mapColors(dataColor);
                var legendHtml = '';
                $.each(legendData, function (idx, legendItem) {
                    legendHtml += '<span style="background-color: {col};">&nbsp;&nbsp;&nbsp;</span>&nbsp;'.AXMInterpolate({ col: legendItem.color.toString() });
                    legendHtml += legendItem.content;
                    legendHtml += '<br>';
                });
                win.colorLegendCtrl.modifyText(legendHtml);
            }
        };

        win._hasLassoSelected = function (points) {
            win.button_lassoSelection.setChecked(false);
            win.setInfoText('');

            function isPointInPoly(poly, pt) {
                for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {
                    (poly[i].y <= pt.y && pt.y < poly[j].y || poly[j].y <= pt.y && pt.y < poly[i].y) && pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x && (c = !c);
                }return c;
            }

            var dataX = win.getAspectProperty('xvalue').data;
            var dataY = win.getAspectProperty('yvalue').data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            var coordXLogic2Win = win.plot.coordXLogic2Win;
            var coordYLogic2Win = win.plot.coordYLogic2Win;
            var selList = [];
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var ptPx = coordXLogic2Win(dataX[rowNr]);
                var ptPy = coordYLogic2Win(dataY[rowNr]);
                if (isPointInPoly(points, { x: ptPx, y: ptPy })) selList.push(dataPrimKey[rowNr]);
            }
            win.performRowSelected(selList);
        };

        win.plot.drawPlot = function (drawInfo) {
            var plot = win.plot;
            var ctx = drawInfo.ctx;

            var propX = win.getAspectProperty('xvalue');
            var propY = win.getAspectProperty('yvalue');
            var dataX = propX.data;
            var dataY = propY.data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            var propColor = null;
            if (win.hasAspectProperty('color')) {
                propColor = win.getAspectProperty('color');
                var dataColor = propColor.data;
            }

            var propSize = null;
            if (win.hasAspectProperty('size')) {
                propSize = win.getAspectProperty('size');
                var dataSize = propSize.data;
            }

            var usedRowNrs = [];
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                if (dataX[rowNr] != null && dataY[rowNr] != null) if (propSize) {
                    if (dataSize[rowNr] != null) usedRowNrs.push(rowNr);
                } else usedRowNrs.push(rowNr);
            }
            var rowNr = null;

            if (propSize) {
                var minSizeVal = 1.0e99;
                var maxSizeVal = -1.0e99;
                for (var idx = 0; idx < usedRowNrs.length; idx++) {
                    rowNr = usedRowNrs[idx];
                    minSizeVal = Math.min(minSizeVal, dataSize[rowNr]);
                    maxSizeVal = Math.max(maxSizeVal, dataSize[rowNr]);
                }
            }

            if (propSize) {
                var order = [];
                for (var idx = 0; idx < usedRowNrs.length; idx++) {
                    rowNr = usedRowNrs[idx];
                    order.push(-dataSize[rowNr]);
                }
            } else {
                var random_seeded = function random_seeded() {
                    var x = Math.sin(seed++) * 10000;
                    return x - Math.floor(x);
                };

                //sort random
                var seed = 1;

                var order = [];
                for (var idx = 0; idx < usedRowNrs.length; idx++) {
                    order.push(random_seeded());
                }
            }

            usedRowNrs.sort(function (idx1, idx2) {
                var val1 = order[idx1];
                var val2 = order[idx2];
                var discr = val1 < val2 ? -1 : val1 > val2 ? 1 : 0;
                return discr;
            });

            drawInfo.ctx.fillStyle = Color.Color(0, 0, 0, 0.6).toStringCanvas();
            if (win.hasAspectProperty('label')) {
                var propLabel = win.getAspectProperty('label');
                var dataLabel = propLabel.data;
                for (var idx = 0; idx < usedRowNrs.length; idx++) {
                    rowNr = usedRowNrs[idx];
                    plot.drawLabel(drawInfo, dataX[rowNr], dataY[rowNr], 4, propLabel.content2DisplayString(dataLabel[rowNr]));
                }
            }

            var globalPointSize = win.ctrl_PointSize.getValue();
            var pointSize = globalPointSize;
            var drawOutline = win.ctrl_showOutline.getValue();
            drawInfo.ctx.fillStyle = Color.Color(0, 0, 255, win._opacity).toStringCanvas();
            ctx.strokeStyle = Color.Color(0, 0, 0, 0.7 * win._opacity).toStringCanvas();
            ctx.lineWidth = 1;
            for (var idx = 0; idx < usedRowNrs.length; idx++) {
                rowNr = usedRowNrs[idx];
                if (propColor) {
                    drawInfo.ctx.fillStyle = propColor.getSingleColor(dataColor[rowNr]).changeOpacity(win._opacity).toStringCanvas();
                }
                if (propSize) pointSize = globalPointSize * 3 * (0.1 + (dataSize[rowNr] - minSizeVal) / (maxSizeVal - minSizeVal));
                plot.drawPoint(drawInfo, dataX[rowNr], dataY[rowNr], pointSize, drawOutline);
            }

            pointSize = globalPointSize;
            var rowSelGet = win.dataFrame.objectType.rowSelGet;
            drawInfo.ctx.strokeStyle = Color.Color(255, 0, 0, 0.5).toStringCanvas();
            for (var idx = 0; idx < usedRowNrs.length; idx++) {
                rowNr = usedRowNrs[idx];
                if (rowSelGet(dataPrimKey[rowNr])) {
                    if (propSize) pointSize = globalPointSize * 3 * (0.1 + (dataSize[rowNr] - minSizeVal) / (maxSizeVal - minSizeVal));
                    plot.drawSel(drawInfo, dataX[rowNr], dataY[rowNr], pointSize + 2);
                }
            }

            ctx.strokeStyle = Color.Color(255, 0, 0, 0.5).toStringCanvas();
            ctx.lineWidth = 2;
            var plotLimitXMin = plot.xScaler.getMinVisibleRange();
            var plotLimitXMax = plot.xScaler.getMaxVisibleRange();
            var plotLimitYMin = plot.yScaler.getMinVisibleRange();
            var plotLimitYMax = plot.yScaler.getMaxVisibleRange();
            var x = 0,
                y = 0,
                px = 0,
                py = 0;
            $.each(win._curves, function (idx, expr) {
                ctx.beginPath();
                for (var ptNr = 0; ptNr <= 200; ptNr++) {
                    var match = false;
                    if (expr.indexOf('y=') == 0) {
                        x = plotLimitXMin + ptNr * 1.0 / 200 * (plotLimitXMax - plotLimitXMin);
                        y = eval(expr.substring(2));
                        match = true;
                    }
                    if (expr.indexOf('x=') == 0) {
                        y = plotLimitYMin + ptNr * 1.0 / 200 * (plotLimitYMax - plotLimitYMin);
                        x = eval(expr.substring(2));
                        match = true;
                    }
                    if (match) {
                        px = plot.coordXLogic2Win(x);
                        py = plot.coordYLogic2Win(y);
                        if (ptNr == 0) ctx.moveTo(px, py);else ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
            });
        };

        win.plot.handleRectSelection = function (pt1, pt2) {
            var xMin = win.plot.coordXWin2Logic(Math.min(pt1.x, pt2.x));
            var xMax = win.plot.coordXWin2Logic(Math.max(pt1.x, pt2.x));
            var yMin = win.plot.coordYWin2Logic(Math.max(pt1.y, pt2.y));
            var yMax = win.plot.coordYWin2Logic(Math.min(pt1.y, pt2.y));

            var dataX = win.getAspectProperty('xvalue').data;
            var dataY = win.getAspectProperty('yvalue').data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            var selList = [];
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                if (dataX[rowNr] >= xMin && dataX[rowNr] <= xMax && dataY[rowNr] >= yMin && dataY[rowNr] <= yMax) selList.push(dataPrimKey[rowNr]);
            }
            win.performRowSelected(selList);
        };

        win.openPoint = function (rowNr) {
            ViewRow.create(win.dataFrame, win.getPrimKeyProperty().data[rowNr], win);
        };

        win.addCurve = function () {
            SimplePopups.TextEditBox('', _TRL('Enter the curve expression<br>(may be "y=f(x)" or "x=f(y)")'), _TRL('Add curve'), {}, function (expr) {
                win.addCurveStr(expr);
            });
        };

        win.addCurveStr = function (expr) {
            win._curves.push(expr);
            win.render();
        };

        win.setRange = function () {
            var pwin = PopupWindow.create({
                title: 'Set range',
                blocking: true,
                autoCenter: true
            });

            var grp = Controls.Compound.GroupVert({ separator: 12 });

            var btOK = Controls.Button({
                text: _TRL('OK'),
                icon: 'fa-check'
            }).addNotificationHandler(function () {
                pwin.onOK();
            });

            var btCancel = Controls.Button({
                text: _TRL('Cancel'),
                icon: 'fa-times'
            }).addNotificationHandler(function () {
                pwin.close();
            });

            var grd = Controls.Compound.Grid({});

            pwin.ctrlXMin = Controls.Edit({ width: 80, value: win.plot.getXRangeMin() });
            pwin.ctrlXMax = Controls.Edit({ width: 80, value: win.plot.getXRangeMax() });
            pwin.ctrlYMin = Controls.Edit({ width: 80, value: win.plot.getYRangeMin() });
            pwin.ctrlYMax = Controls.Edit({ width: 80, value: win.plot.getYRangeMax() });

            grd.setItem(0, 1, '<b>Min</b>');
            grd.setItem(0, 2, '<b>Max</b>');

            grd.setItem(1, 0, '<b>X range</b>');
            grd.setItem(1, 1, pwin.ctrlXMin);
            grd.setItem(1, 2, pwin.ctrlXMax);

            grd.setItem(2, 0, '<b>Y range</b>');
            grd.setItem(2, 1, pwin.ctrlYMin);
            grd.setItem(2, 2, pwin.ctrlYMax);

            grp.add(grd);

            grp.add(Controls.Compound.GroupHor({}, [btOK, btCancel]));

            pwin.onOK = function () {
                win.plot.setXRange(parseFloat(pwin.ctrlXMin.getValue()), parseFloat(pwin.ctrlXMax.getValue()));
                win.plot.setYRange(parseFloat(pwin.ctrlYMin.getValue()), parseFloat(pwin.ctrlYMax.getValue()));
                pwin.close();
                win.render();
            };

            pwin.setRootControl(Controls.Compound.StandardMargin(grp));
            pwin.start();
            //SimplePopups.TextEditBox('', _TRL('Enter the curve expression<br>(may be "y=f(x)" or "x=f(y)")'), _TRL('Add curve'), {}, function(expr) {
            //    win._curves.push(expr);
            //    win.render();
            //});
        };

        win.modifySetting = function (settingKey, settingValue) {
            if (settingKey == "PointSize") {
                win.ctrl_PointSize.setValue(settingValue);
                return;
            }
            if (settingKey == "PointOpacity") {
                win.ctrl_Opacity.setValue(settingValue);
                return;
            }
            if (settingKey == "PointOutline") {
                win.ctrl_showOutline.setValue(settingValue);
                return;
            }
            throw "Invalid plot setting: " + settingKey;
        };

        win.setXRange = function (mn, mx) {
            win.plot.setXRange(mn, mx);
            win.render();
        };
        win.setYRange = function (mn, mx) {
            win.plot.setYRange(mn, mx);
            win.render();
        };

        win.initPlot = function () {
            win.updateColorLegend();
            win.parseData();
        };

        /**
         * Create text for display in info section of the plot
         * @param {[]} dataX: list of floats
         * @param {[]} dataY: list of floats
         * @returns {String}: info text to display
         * @private
         */
        win._infoText = function (dataX, dataY) {
            var correlation = Stats.correlationCoefficient(dataX, dataY);
            var slope_intercept = Stats.slopeIntercept(dataX, dataY);
            var slope = slope_intercept[0];
            var intercept = slope_intercept[1];
            var str = 'Correlation: ' + correlation + '<br>';
            str += 'Slope: ' + slope + '<br>';
            str += 'Intercept: ' + intercept + '<br>';
            return str;
        };

        /**
         * Parse data, calculate properties and display them in the Display section of the plot.
         */
        win.parseData = function () {
            var dataX = win.getAspectProperty('xvalue').data;
            var dataY = win.getAspectProperty('yvalue').data;
            var correlation = Stats.correlationCoefficient(dataX, dataY);
            var str = win._infoText(dataX, dataY);
            win.corrCtrl.modifyText(str);
            win.parseSelectedData();
        };

        /**
         * Parse selected data, calculate properties and display them in the Display section of the plot.
         */
        win.parseSelectedData = function () {
            var dataX = win.getAspectProperty('xvalue').data;
            var dataY = win.getAspectProperty('yvalue').data;
            var dataPrimKey = win.getPrimKeyProperty().data;
            var dataSelX = [];
            var dataSelY = [];
            var rowSelGet = win.dataFrame.objectType.rowSelGet;
            for (var rowNr = 0; rowNr < dataX.length; rowNr++) {
                if (rowSelGet(dataPrimKey[rowNr])) {
                    dataSelX.push(dataX[rowNr]);
                    dataSelY.push(dataY[rowNr]);
                }
            }
            var str = 'Selection: '.bold() + '<br>';
            str += win._infoText(dataSelX, dataSelY);
            win.corrSelectCtrl.modifyText(str);
        };

        /**
         * Draw a linear fit through the current selected data
         */
        win.drawLinearFit = function () {
            if (win.dataFrame.objectType.rowSelGetList().length > 0) {
                var dataX = win.getAspectProperty('xvalue').data;
                var dataY = win.getAspectProperty('yvalue').data;
                var dataPrimKey = win.getPrimKeyProperty().data;
                var dataSelX = [];
                var dataSelY = [];
                var rowSelGet = win.dataFrame.objectType.rowSelGet;
                var selCount = 0;
                for (var rowNr = 0; rowNr < dataX.length; rowNr++) {
                    if (rowSelGet(dataPrimKey[rowNr])) {
                        dataSelX.push(dataX[rowNr]);
                        dataSelY.push(dataY[rowNr]);
                    }
                }
                var slope_intercept = Stats.slopeIntercept(dataSelX, dataSelY);
                var slope = slope_intercept[0];
                var intercept = slope_intercept[1];
                if (!isNaN(slope)) {
                    var expr = 'y=' + slope.toString() + ' * x + ' + intercept.toString();
                    win._curves.push(expr);
                    win.render();
                } else SimplePopups.ErrorBox(_TRL('Fit could not be calculated for current selection.'));
            } else SimplePopups.ErrorBox(_TRL('No points are selected.'));
        };

        var propX = win.getAspectProperty('xvalue');
        var propY = win.getAspectProperty('yvalue');
        var rangeX = propX.getValueRange();
        var rangeY = propY.getValueRange();
        rangeX.extendFraction(0.1);
        rangeY.extendFraction(0.1);
        win.plot.setXLabel(propX.getDispName());
        win.plot.setYLabel(propY.getDispName());
        win.plot.setXRange(rangeX.getMin(), rangeX.getMax());
        win.plot.setYRange(rangeY.getMin(), rangeY.getMax());
        win.listen('DataFrameRowSelChanged', function (objectTypeId) {
            if (objectTypeId == win.dataFrame.objectType.typeId) win.parseSelectedData();
        });

        win.init();
        return win;
    };

    return PlotType;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(3), __webpack_require__(8), __webpack_require__(28), __webpack_require__(5), __webpack_require__(15), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Controls, Color, PanelCanvasZoomPan, SimplePopups, _GenericPlot, DataTypes) {

    var PlotType = _GenericPlot.createPlotType('bargraph', _TRL('Bar graph'), 'fa-bar-chart');
    PlotType.addPlotAspect('category', _TRL('Category'), DataTypes.typeAnyCategorical, true);
    PlotType.addPlotAspect('category2', _TRL('Second category'), DataTypes.typeAnyCategorical, false);

    PlotType.create = function (dataFrame, aspectMap) {
        var win = PlotType.createGeneric(dataFrame, aspectMap);
        win.catSizeX = 20;

        win.plot = PanelCanvasZoomPan.create('', { scaleMarginY: 120 });
        win.plot._directRedraw = true;
        win.plot.setZoomDirections(true, false);

        win.render = function () {
            win.plot.render();
        };

        win._createDisplayControls = function (dispGroup) {

            win._scaleCheck = Controls.Check({ text: _TRL('Scale to 100%'), checked: false }).addNotificationHandler(function () {
                win.render();
            });
            dispGroup.add(win._scaleCheck);

            win.ctrlSortType = Controls.DropList({}).addNotificationHandler(function () {
                win.parseData();
                win.render();
            });
            win.ctrlSortType.addState('val', _TRL("Alphabetical"));
            win.ctrlSortType.addState('count', _TRL("Count"));
            dispGroup.add(Controls.Compound.GroupVert({}, [_TRL('Sort by:'), win.ctrlSortType]));
            win.colorLegendCtrl = Controls.Static({});
            dispGroup.add(win.colorLegendCtrl);
        };

        win.plot.drawXScale = function (drawInfo) {
            var plot = win.plot;
            var ctx = drawInfo.ctx;
            var scaleX = plot.getXScale();
            var offsetX = plot.getXOffset();
            var xL2S = function xL2S(vlx) {
                return vlx * scaleX + offsetX;
            };
            var topY = drawInfo.sizeY - plot.scaleMarginY;
            ctx.save();
            ctx.font = "11px Arial";
            ctx.fillStyle = "rgb(0,0,0)";
            ctx.textAlign = 'right';
            $.each(win._categories, function (idx, category) {
                var x1 = xL2S((idx + 0) * win.catSizeX);
                var x2 = xL2S((idx + 1) * win.catSizeX);
                ctx.save();
                ctx.translate(Math.round((x1 + x2) / 2 + 3), topY + 3);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(category.dispName, 0, 0);
                ctx.restore();
            });
            ctx.restore();
        };

        win.plot.drawYScale = function (drawInfo) {};

        win.plot.drawCenter = function (drawInfo) {
            var plot = win.plot;
            var ctx = drawInfo.ctx;
            var scaleX = plot.getXScale();
            var offsetX = plot.getXOffset();
            var scaleY = plot.getYScale();
            var offsetY = plot.getYOffset();
            plot.scaleX = scaleX;plot.offsetX = offsetX;
            plot.scaleY = scaleY;plot.offsetY = offsetY;
            drawInfo.scaleX = scaleX;drawInfo.offsetX = offsetX;
            drawInfo.scaleY = scaleY;drawInfo.offsetY = offsetY;

            var xL2S = function xL2S(vlx) {
                return vlx * scaleX + offsetX;
            };
            var yL2S = function yL2S(vly) {
                return vly * scaleY + offsetY;
            };

            var dataCat = win.getAspectProperty('category').data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            var scaleBars = win._scaleCheck.getValue();

            //count current selection
            var catSelMap = {};
            var rowSelGet = win.dataFrame.objectType.rowSelGet;
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var cat = dataCat[rowNr];
                if (!catSelMap[cat]) catSelMap[cat] = { count: 0 };
                if (rowSelGet(dataPrimKey[rowNr])) {
                    catSelMap[cat].count += 1;
                }
            }

            var propCat2 = null;
            if (win.hasAspectProperty('category2')) {
                propCat2 = win.getAspectProperty('category2');
            }

            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, drawInfo.sizeX, drawInfo.sizeY);

            ctx.strokeStyle = Color.Color(0, 0, 0).toStringCanvas();

            $.each(win._categories, function (idx, category) {
                var barRange = win._maxCount;
                if (scaleBars) barRange = Math.max(1, category.count);
                var x1 = Math.round(xL2S((idx + 0) * win.catSizeX)) + 0.5;
                var x2 = Math.round(xL2S((idx + 1) * win.catSizeX)) + 0.5;
                var y1 = Math.round(yL2S(0.0)) - 0.5;
                var y2 = Math.round(yL2S(category.count * 1.0 / barRange)) + 0.5;
                ctx.fillStyle = Color.Color(0.85, 0.9, 0.95).toStringCanvas();
                ctx.beginPath();
                ctx.rect(x1, y1, x2 - x1, y2 - y1);
                ctx.fill();
                ctx.stroke();

                if (propCat2) {
                    var countTot = 0;
                    $.each(win._categories2, function (idx, cat2) {
                        ctx.fillStyle = propCat2.getSingleColor(cat2.catVal).toStringCanvas();
                        var count = category.mapCategories2[cat2.catVal].count;
                        var y1 = Math.round(yL2S(countTot * 1.0 / barRange)) + 0.5;
                        countTot += count;
                        var y2 = Math.round(yL2S(countTot * 1.0 / barRange)) + 0.5;
                        ctx.beginPath();
                        ctx.rect(x1, y1, x2 - x1, y2 - y1);
                        ctx.fill();
                        ctx.stroke();
                    });
                }

                var selCount = catSelMap[category.catVal].count;
                if (selCount > 0) {
                    var y2s = yL2S(selCount * 1.0 / barRange);
                    ctx.fillStyle = Color.Color(1, 0.0, 0, 0.5).toStringCanvas();
                    ctx.beginPath();
                    ctx.rect(x1 + 1, y1, x2 - x1, y2s - y1);
                    ctx.fill();
                }

                ctx.save();
                ctx.font = "11px Arial";
                ctx.fillStyle = "rgb(0,0,0)";
                ctx.translate(Math.round((x1 + x2) / 2 + 3), Math.round(y2) - 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(category.count, 0, 0);
                ctx.restore();
            });
        };

        win.updateAspect = function (aspectId) {
            win.parseData();
            win.render();
        };

        win.parseData = function () {
            var propCat = win.getAspectProperty('category');
            var dataCat = propCat.data;

            win.colorLegendCtrl.modifyText('');

            var catMap = {};
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var val = dataCat[rowNr];
                if (!catMap[val]) {
                    catMap[val] = {
                        catVal: val,
                        dispName: propCat.content2DisplayString(val),
                        count: 0
                    };
                }
                catMap[val].count += 1;
            }
            win._categories = [];
            win._maxCount = 1;
            $.each(catMap, function (idx, cat) {
                win._categories.push(cat);
                win._maxCount = Math.max(win._maxCount, cat.count);
            });

            if (win.ctrlSortType.getValue() != 'count') win._categories.sort(AXMUtils.ByProperty('dispName'));else win._categories.sort(AXMUtils.ByPropertyReverse('count'));

            win.plot.setXRange(0, Math.max(500, win._categories.length * win.catSizeX));
            win.plot.setYRange(0, 1.2);

            if (win.hasAspectProperty('category2')) {
                var propCat2 = win.getAspectProperty('category2');
                var dataCat2 = propCat2.data;

                var catMap2 = {};
                for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                    var val = dataCat2[rowNr];
                    if (!catMap2[val]) {
                        catMap2[val] = {
                            catVal: val,
                            dispName: propCat2.content2DisplayString(val)
                        };
                    }
                }
                win._categories2 = [];
                $.each(catMap2, function (idx, cat) {
                    win._categories2.push(cat);
                });

                $.each(win._categories, function (idx, cat) {
                    cat.mapCategories2 = {};
                    $.each(win._categories2, function (idx, cat2) {
                        cat.mapCategories2[cat2.catVal] = {
                            count: 0
                        };
                    });
                });

                for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                    var val1 = dataCat[rowNr];
                    var val2 = dataCat2[rowNr];
                    catMap[val1].mapCategories2[val2].count += 1;
                }

                var legendData = propCat2.mapColors(dataCat2);

                var legendHtml = '';
                $.each(legendData, function (idx, legendItem) {
                    legendHtml += '<span style="background-color: {col};">&nbsp;&nbsp;&nbsp;</span>&nbsp;'.AXMInterpolate({ col: legendItem.color.toString() });
                    legendHtml += legendItem.content;
                    legendHtml += '<br>';
                });
                win.colorLegendCtrl.modifyText(legendHtml);
            }
        };

        win.plot.getCategoryOnPoint = function (px, py) {
            var xL2S = function xL2S(vlx) {
                return vlx * win.plot.scaleX + win.plot.offsetX;
            };
            var yL2S = function yL2S(vly) {
                return vly * win.plot.scaleY + win.plot.offsetY;
            };
            var theCat = null;
            $.each(win._categories, function (idx, category) {
                var x1 = xL2S((idx + 0) * win.catSizeX);
                var x2 = xL2S((idx + 1) * win.catSizeX);
                var y1 = yL2S(0.0);
                var y2 = yL2S(category.count * 1.0 / win._maxCount);
                if (px >= x1 && px < x2 && py <= y1 && py >= y2 - 5) theCat = category;
            });
            return theCat;
        };

        win.plot.getToolTipInfo = function (px, py) {
            var category = win.plot.getCategoryOnPoint(px, py);
            if (!category) return null;
            return {
                px: px,
                py: py,
                ID: category.catVal,
                content: category.dispName,
                showPointer: true
            };
        };

        win.plot.onMouseClick = function (ev, info) {
            var category = win.plot.getCategoryOnPoint(info.x, info.y);
            if (category) win.openCategory(category);
        };

        win.openCategory = function (catInfo) {
            var selList = [];
            var dataCat = win.getAspectProperty('category').data;
            var dataPrimKey = win.getPrimKeyProperty().data;
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                if (dataCat[rowNr] == catInfo.catVal) selList.push(dataPrimKey[rowNr]);
            }
            var dispText = _TRL('{propname}= {value}').AXMInterpolate({
                propname: win.getAspectProperty('category').getDispName(),
                value: catInfo.dispName
            });
            win.performRowSelected(selList, dispText);
        };

        win.initPlot = function () {
            win.parseData();
        };

        win.init();
        return win;
    };

    return PlotType;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(8), __webpack_require__(25), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(15), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Color, PanelCanvasXYPlot, PopupWindow, Controls, SimplePopups, _GenericPlot, DataTypes) {

    var PlotType = _GenericPlot.createPlotType('multicathistogram', _TRL('Multi-category histogram'), 'fa-area-chart');

    PlotType.addPlotAspect('category', _TRL('Category'), DataTypes.typeAnyCategorical, true);
    PlotType.addPlotAspect('value', _TRL('Value'), DataTypes.typeFloat, true);

    PlotType.create = function (dataFrame, aspectMap) {
        var win = PlotType.createGeneric(dataFrame, aspectMap);

        win.plot = PanelCanvasXYPlot.create('', { selectXDirOnly: true });
        win.plot._directRedraw = true; //might be changed
        win._opacity = 0.40;

        win._createDisplayControls = function (dispGroup) {
            win._ctrlNormalise = Controls.Check({ text: _TRL('Normalise per category'), checked: false }).addNotificationHandler(function () {
                win.parseData();
                win.render();
            });
            dispGroup.add(win._ctrlNormalise);

            win.colorLegendCtrl = Controls.Static({});
            dispGroup.add(win.colorLegendCtrl);
        };

        win.initPlot = function () {
            win.parseData();
        };

        win.render = function () {
            win.plot.render();
        };

        win.plot.drawPlot = function (drawInfo) {
            var plot = win.plot;
            var ctx = drawInfo.ctx;
            var scaleX = plot.getXScale();
            var offsetX = plot.getXOffset();
            var scaleY = plot.getYScale();
            var offsetY = plot.getYOffset();
            plot.scaleX = scaleX;plot.offsetX = offsetX;
            plot.scaleY = scaleY;plot.offsetY = offsetY;
            drawInfo.scaleX = scaleX;drawInfo.offsetX = offsetX;
            drawInfo.scaleY = scaleY;drawInfo.offsetY = offsetY;
            var xL2S = win.plot.coordXLogic2Win;
            var yL2S = win.plot.coordYLogic2Win;

            var propCat = win.getAspectProperty('category');
            var dataVal = win.getAspectProperty('value').data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            //var binValuesSelected = [];
            //for (var i=0; i<win._binCount; i++)
            //    binValuesSelected.push(0);
            //var rowSelGet = win.dataFrame.objectType.rowSelGet;
            //for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
            //    if (rowSelGet(dataPrimKey[rowNr]))
            //        binValuesSelected[Math.floor((dataVal[rowNr]-win._binOffset)/win._binSize)] ++;
            //}

            $.each(win._categories, function (idx, cat) {
                ctx.strokeStyle = propCat.getSingleColor(cat.catVal).toStringCanvas();
                ctx.fillStyle = propCat.getSingleColor(cat.catVal).toStringCanvas();
                ctx.beginPath();
                for (var binNr = 0; binNr < win._binCount; binNr++) {
                    var binCount = cat._binValues[binNr];
                    var x1 = Math.round(xL2S(win._binOffset + (binNr + 0.5) * win._binSize)) + 0.5;
                    var y1 = Math.round(yL2S(binCount)) + 0.5;
                    if (binNr == 0) ctx.moveTo(x1, y1);else ctx.lineTo(x1, y1);
                }
                ctx.stroke();
                for (var binNr = 0; binNr < win._binCount; binNr++) {
                    var binCount = cat._binValues[binNr];
                    var x1 = Math.round(xL2S(win._binOffset + (binNr + 0.5) * win._binSize)) + 0.5;
                    var y1 = Math.round(yL2S(binCount)) + 0.5;
                    ctx.beginPath();
                    ctx.arc(x1, y1, 3, 0, 2 * Math.PI, false);
                    ctx.closePath();
                    ctx.fill();
                }
            });
        };

        win.plot.handleRectSelection = function (pt1, pt2) {
            var xMin = win.plot.coordXWin2Logic(Math.min(pt1.x, pt2.x));
            var xMax = win.plot.coordXWin2Logic(Math.max(pt1.x, pt2.x));

            var dataVal = win.getAspectProperty('value').data;
            var dataPrimKey = win.getPrimKeyProperty().data;
            var selList = [];
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                if (dataVal[rowNr] >= xMin && dataVal[rowNr] <= xMax) selList.push(dataPrimKey[rowNr]);
            }
            win.performRowSelected(selList);
        };

        win.updateAspect = function (aspectId) {
            win.parseData();
            win.render();
        };

        win.parseData = function () {

            var propCat = win.getAspectProperty('category');
            var dataCat = propCat.data;

            win.colorLegendCtrl.modifyText('');

            var catMap = {};
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var val = dataCat[rowNr];
                if (!catMap[val]) {
                    catMap[val] = {
                        catVal: val,
                        dispName: propCat.content2DisplayString(val)
                    };
                }
            }
            win._categories = [];
            $.each(catMap, function (idx, cat) {
                win._categories.push(cat);
            });

            var propVal = win.getAspectProperty('value');
            var dataVal = propVal.data;

            var values = [];
            var minVal = +1.0e99;
            var maxVal = -1.0e99;
            var count = 0;
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var val = dataVal[rowNr];
                if (val !== null) {
                    values.push(val);
                    if (val < minVal) minVal = val;
                    if (val > maxVal) maxVal = val;
                    count++;
                }
            }

            var binSize = 1;
            if (minVal == maxVal) binSize = minVal * 0.1;else {
                var jumpPrototypes = [1, 2, 5];
                var optimalbincount = Math.floor(Math.sqrt(count / win._categories.length));
                optimalbincount = Math.max(optimalbincount, 2);
                optimalbincount = Math.min(optimalbincount, 200);
                var optimalbinsize = (maxVal - minVal) * 1.0 / optimalbincount;
                var mindist = 1.0e99;
                $.each(jumpPrototypes, function (idx, jumpPrototype) {
                    var q = Math.floor(AXMUtils.log10(optimalbinsize / jumpPrototype));
                    var TryJump1A = Math.pow(10, q) * jumpPrototype;
                    var TryJump1B = Math.pow(10, q + 1) * jumpPrototype;
                    if (Math.abs(TryJump1A - optimalbinsize) < mindist) {
                        mindist = Math.abs(TryJump1A - optimalbinsize);
                        binSize = TryJump1A;
                    }
                    if (Math.abs(TryJump1B - optimalbinsize) < mindist) {
                        mindist = Math.abs(TryJump1B - optimalbinsize);
                        binSize = TryJump1B;
                    }
                });
            }

            win._binSize = binSize;
            win._binOffset = Math.floor(minVal / binSize) * binSize;
            win._binCount = Math.floor((maxVal - win._binOffset) / binSize) + 1;

            $.each(win._categories, function (idx, cat) {
                cat._binValues = [];
                for (var i = 0; i < win._binCount; i++) {
                    cat._binValues.push(0);
                }
            });
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var cat = dataCat[rowNr];
                var val = dataVal[rowNr];
                if (val !== null) {
                    var binNr = Math.floor((val - win._binOffset) / binSize);
                    if (binNr < 0 || binNr >= win._binCount) AXMUtils.reportBug(_TRL('Invalid bin'));
                    catMap[cat]._binValues[binNr] += 1;
                }
            }

            if (win._ctrlNormalise.getValue()) {
                $.each(win._categories, function (idx, cat) {
                    var totCount = 0;
                    $.each(cat._binValues, function (idx, value) {
                        totCount += value;
                    });
                    if (totCount == 0) totCount = 1.0E-99;
                    $.each(cat._binValues, function (idx, value) {
                        cat._binValues[idx] = value * 1.0 / totCount;
                    });
                });
            }

            win._maxBinSize = 1.0e-99;
            $.each(win._categories, function (idx, cat) {
                $.each(cat._binValues, function (idx, value) {
                    if (value > win._maxBinSize) win._maxBinSize = value;
                });
            });

            var rangeX = AXMUtils.valueRange(win._binOffset, win._binOffset + win._binCount * win._binSize);
            rangeX.extendFraction(0.1);
            var rangeY = AXMUtils.valueRange(0, win._maxBinSize);
            rangeY.extendFraction(0.1);
            win.plot.setXRange(rangeX.getMin(), rangeX.getMax());
            win.plot.setYRange(rangeY.getMin(), rangeY.getMax());

            var legendData = propCat.mapColors(dataCat);
            var legendHtml = '';
            $.each(legendData, function (idx, legendItem) {
                legendHtml += '<span style="background-color: {col};">&nbsp;&nbsp;&nbsp;</span>&nbsp;'.AXMInterpolate({ col: legendItem.color.toString() });
                legendHtml += legendItem.content;
                legendHtml += '<br>';
            });
            win.colorLegendCtrl.modifyText(legendHtml);
            win.plot.setXLabel(propVal.getDispName());
        };

        win.init();
        return win;
    };

    return PlotType;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(3), __webpack_require__(8), __webpack_require__(11), __webpack_require__(5), __webpack_require__(15), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Controls, Color, PanelHtml, SimplePopups, _GenericPlot, DataTypes) {

    var PlotType = _GenericPlot.createPlotType('crosstab', _TRL('Crosstab'), 'fa-th-large');
    PlotType.addPlotAspect('category1', _TRL('Rows category'), DataTypes.typeAnyCategorical, true);
    PlotType.addPlotAspect('category2', _TRL('Columns category'), DataTypes.typeAnyCategorical, true);

    PlotType.create = function (dataFrame, aspectMap) {
        var win = PlotType.createGeneric(dataFrame, aspectMap);

        win.plot = PanelHtml.create('', {}).enableVScrollBar().enableHScrollBar();

        win._createDisplayControls = function (dispGroup) {

            win.ctrl_showEnhInfo = Controls.Check({ text: _TRL('Show enhancement'), checked: false }).addNotificationHandler(function () {
                win.render();
            });
            dispGroup.add(win.ctrl_showEnhInfo);

            win.ctrl_showFracInfo = Controls.Check({ text: _TRL('Show fraction info'), checked: true }).addNotificationHandler(function () {
                win.render();
            });
            dispGroup.add(win.ctrl_showFracInfo);

            win.ctrl_showSelInfo = Controls.Check({ text: _TRL('Show selection info'), checked: true }).addNotificationHandler(function () {
                win.render();
            });
            dispGroup.add(win.ctrl_showSelInfo);

            //
            //win.ctrlSortType = Controls.DropList({}).addNotificationHandler(function() {
            //    win.parseData();
            //    win.plot.render();
            //});
            //win.ctrlSortType.addState('val', _TRL("Alphabetical"));
            //win.ctrlSortType.addState('count', _TRL("Count"));
            //dispGroup.add(Controls.Compound.GroupVert({}, [
            //    _TRL('Sort by:'),
            //    win.ctrlSortType
            //]));
            //win.colorLegendCtrl = Controls.Static({});
            //dispGroup.add(win.colorLegendCtrl);
        };

        win.updateAspect = function (aspectId) {
            win.render();
        };

        win.parseData = function () {
            var propCat1 = win.getAspectProperty('category1');
            var dataCat1 = propCat1.data;
            var propCat2 = win.getAspectProperty('category2');
            var dataCat2 = propCat2.data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            win.cats1 = [];
            var cat1Map = {};
            win.cats2 = [];
            var cat2Map = {};
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var val1 = dataCat1[rowNr];
                if (!cat1Map[val1]) {
                    cat1Map[val1] = {
                        catVal: val1,
                        dispName: propCat1.content2DisplayString(val1),
                        count: 0
                    };
                    win.cats1.push(cat1Map[val1]);
                }
                cat1Map[val1].count += 1;

                var val2 = dataCat2[rowNr];
                if (!cat2Map[val2]) {
                    cat2Map[val2] = {
                        catVal: val2,
                        dispName: propCat2.content2DisplayString(val2),
                        count: 0
                    };
                    win.cats2.push(cat2Map[val2]);
                }
                cat2Map[val2].count += 1;
            }

            win.cats1.sort(AXMUtils.ByProperty('dispName'));
            win.cats2.sort(AXMUtils.ByProperty('dispName'));

            var cat1Map = {};
            $.each(win.cats1, function (idx, cat) {
                cat1Map[cat.catVal] = idx;
            });
            var cat2Map = {};
            $.each(win.cats2, function (idx, cat) {
                cat2Map[cat.catVal] = idx;
            });

            win.cellData = [];
            $.each(win.cats1, function (idx1, cat1) {
                var row = [];
                $.each(win.cats2, function (idx2, cat2) {
                    row.push({
                        count: 0,
                        selCount: 0
                    });
                });
                win.cellData.push(row);
            });

            var rowSelGet = win.dataFrame.objectType.rowSelGet;
            win.totCount = 0;
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var val1 = dataCat1[rowNr];
                var val2 = dataCat2[rowNr];
                var cellInfo = win.cellData[cat1Map[val1]][cat2Map[val2]];
                cellInfo.count++;
                if (rowSelGet(dataPrimKey[rowNr])) cellInfo.selCount++;
                win.totCount++;
            }

            win.maxCellCount = 0;
            $.each(win.cats1, function (idx1, cat1) {
                $.each(win.cats2, function (idx2, cat2) {
                    var cellInfo = win.cellData[idx1][idx2];
                    cellInfo.enhancement = cellInfo.count * 1.0 / (cat1.count * cat2.count) * win.totCount - 1;
                });
            });

            win.maxCellCount = 0;
            win.maxCellEnhancement = 0.1;
            $.each(win.cats1, function (idx1, cat1) {
                $.each(win.cats2, function (idx2, cat2) {
                    var cellInfo = win.cellData[idx1][idx2];
                    win.maxCellCount = Math.max(win.maxCellCount, cellInfo.count);
                    win.maxCellEnhancement = Math.max(win.maxCellEnhancement, Math.abs(cellInfo.enhancement));
                });
            });
            win.maxCellEnhancement = Math.min(win.maxCellEnhancement, 5);
        };

        var writeFrac = function writeFrac(val) {
            return (100 * val).toFixed(2) + '%';
        };

        win.renderHeadInfo = function () {
            var content = '';
            content += '<table class="AXMCrossTableCell">';

            content += '<tr><th>Count:</th><td><b>{val}</b></td></tr>'.AXMInterpolate({
                val: win.totCount
            });

            content += '</table>';
            return content;
        };

        win.renderCatInfo = function (propInfo, info) {
            var content = '';
            content += '<div class="AXMCrossTableSmall">' + propInfo.getDispName() + '</div>';
            content += '<div class="AXMCrossTableLarge">' + info.dispName + '</div>';
            content += '<table class="AXMCrossTableCell">';

            content += '<tr><th>Count:</th><td><b>{val}</b></td></tr>'.AXMInterpolate({
                val: info.count
            });

            if (win._dispFracInfo) {
                content += '<tr><th>Frac&nbsp;tot:</th><td>{val}</td></tr>'.AXMInterpolate({
                    val: writeFrac(info.count * 1.0 / win.totCount)
                });
            }

            content += '</table>';
            return content;
        };

        win.renderCellInfo = function (idx1, idx2) {
            var content = '';
            var content = '<table class="AXMCrossTableCell">';
            var cellInfo = win.cellData[idx1][idx2];

            content += '<tr><th>Count:</th><td><b>{val}</b></td></tr>'.AXMInterpolate({
                val: cellInfo.count
            });

            if (win._dispEnhInfo) {
                content += '<tr><th>Enhanc:</th><td>{val}</td></tr>'.AXMInterpolate({
                    val: writeFrac(cellInfo.enhancement)
                });
            }

            if (win._dispFracInfo) {
                content += '<tr><th>Frac&nbsp;tot:</th><td>{val}</td></tr>'.AXMInterpolate({
                    val: writeFrac(cellInfo.count * 1.0 / win.totCount)
                });
                content += '<tr><th>Frac&nbsp;Row:</th><td>{val}</td></tr>'.AXMInterpolate({
                    val: writeFrac(cellInfo.count * 1.0 / win.cats1[idx1].count)
                });
                content += '<tr><th>Frac&nbsp;Col:</th><td>{val}</td></tr>'.AXMInterpolate({
                    val: writeFrac(cellInfo.count * 1.0 / win.cats2[idx2].count)
                });
            }

            if (win._dispSelInfo) {
                content += '<tr><th>Sel:</th><td>{val}</td></tr>'.AXMInterpolate({
                    val: cellInfo.selCount
                });
                content += '<tr><th>Frac&nbsp;Sel:</th><td>{val}</td></tr>'.AXMInterpolate({
                    val: writeFrac(cellInfo.selCount * 1.0 / Math.max(cellInfo.count, 1))
                });
            }

            content += '</table>';
            return content;
        };

        win.render = function () {
            var propCat1 = win.getAspectProperty('category1');
            var propCat2 = win.getAspectProperty('category2');

            win._dispEnhInfo = win.ctrl_showEnhInfo.getValue();
            win._dispSelInfo = win.ctrl_showSelInfo.getValue();
            win._dispFracInfo = win.ctrl_showFracInfo.getValue();

            win.parseData();
            var content = '<table class="AXMCrossTable">';

            content += '<tr>';
            content += '<th><div>';
            content += win.renderHeadInfo();
            content += '</div></th>';
            $.each(win.cats2, function (idx2, cat2Info) {
                content += '<th><div>';
                content += win.renderCatInfo(propCat2, cat2Info);
                content += '</div></th>';
            });
            content += '</tr>';

            $.each(win.cats1, function (idx1, cat1Info) {
                content += '<tr>';

                content += '<th><div>';
                content += win.renderCatInfo(propCat1, cat1Info);
                content += '</div></th>';

                $.each(win.cats2, function (idx2, cat2Info) {
                    var cellInfo = win.cellData[idx1][idx2];
                    cellInfo._id = AXMUtils.getUniqueID();
                    var colorFr = cellInfo.count * 1.0 / win.maxCellCount;
                    var col = Color.Color(1 - 0.6 * colorFr, 1 - 0.3 * colorFr * colorFr, 1);
                    if (win._dispEnhInfo) {
                        colorFr = cellInfo.enhancement * 1.0 / win.maxCellEnhancement;
                        if (colorFr > 0) {
                            if (colorFr > 1) colorFr = 1;
                            col = Color.Color(1 - 0.6 * colorFr, 1 - 0.3 * colorFr * colorFr, 1);
                        } else {
                            colorFr = -colorFr;
                            if (colorFr > 1) colorFr = 1;
                            col = Color.Color(1, 1 - 0.3 * colorFr * colorFr, 1 - 0.6 * colorFr);
                        }
                    }
                    content += '<td style="background-color: {col}"><div id="{id}" style="height:100%;padding:8px">'.AXMInterpolate({ id: cellInfo._id, col: col.toString() });
                    content += win.renderCellInfo(idx1, idx2);
                    content += '</div></td>';
                });

                content += '</tr>';
            });

            content += '</table>';

            win.plot.setContent(content);

            $.each(win.cats1, function (idx1, cat1Info) {
                $.each(win.cats2, function (idx2, cat2Info) {
                    var cellInfo = win.cellData[idx1][idx2];
                    $('#' + cellInfo._id).click(function () {
                        var selList = [];
                        var dataCat1 = win.getAspectProperty('category1').data;
                        var dataCat2 = win.getAspectProperty('category2').data;
                        var dataPrimKey = win.getPrimKeyProperty().data;
                        for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                            if (dataCat1[rowNr] == cat1Info.catVal && dataCat2[rowNr] == cat2Info.catVal) selList.push(dataPrimKey[rowNr]);
                        }
                        var dispText = '';
                        dispText += _TRL('{propname}= {value}').AXMInterpolate({
                            propname: win.getAspectProperty('category1').getDispName(),
                            value: cat1Info.dispName
                        });
                        dispText += _TRL('{propname}= {value}').AXMInterpolate({
                            propname: win.getAspectProperty('category2').getDispName(),
                            value: cat2Info.dispName
                        });
                        win.performRowSelected(selList, dispText);
                    });
                });

                content += '</tr>';
            });
        };

        win.initPlot = function () {
            //                win.render();
        };

        win.plot.render = win.render;
        win.init();
        win.render();
        return win;
    };

    return PlotType;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(29), __webpack_require__(3), __webpack_require__(8), __webpack_require__(11), __webpack_require__(5), __webpack_require__(15), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Stats, Controls, Color, PanelHtml, SimplePopups, _GenericPlot, DataTypes) {

    var PlotType = _GenericPlot.createPlotType('binpredictor', _TRL('Binary predictor'), 'fa-arrows-h');
    PlotType.addPlotAspect('binval', _TRL('Binary value'), DataTypes.typeBoolean, true);
    PlotType.addPlotAspect('predictor', _TRL('Predictor'), DataTypes.typeFloat, true);

    PlotType.create = function (dataFrame, aspectMap) {
        var win = PlotType.createGeneric(dataFrame, aspectMap);

        win.plot = PanelHtml.create('', {}).enableVScrollBar().enableHScrollBar();

        win._createDisplayControls = function (dispGroup) {

            win.ctrl_costFN = Controls.Edit({ value: 1000, width: 60 });
            dispGroup.add(Controls.Compound.GroupHor({}, ['Cost FN:&nbsp', win.ctrl_costFN]));

            win.ctrl_costFP = Controls.Edit({ value: 100, width: 60 });
            dispGroup.add(Controls.Compound.GroupHor({}, ['Cost FP:&nbsp', win.ctrl_costFP]));

            win.ctrl_costUN = Controls.Edit({ value: 10, width: 60 });
            dispGroup.add(Controls.Compound.GroupHor({}, ['Cost Undet:&nbsp', win.ctrl_costUN]));

            win.ctrl_costFN.addNotificationHandler(win.clear);
            win.ctrl_costFP.addNotificationHandler(win.clear);
            win.ctrl_costUN.addNotificationHandler(win.clear);

            var bt_Update = Controls.Button({ text: 'Update' });
            bt_Update.addNotificationHandler(win.render);
            dispGroup.add(bt_Update);

            //win.ctrl_showEnhInfo = Controls.Check({text: _TRL('Show enhancement'), checked: false})
            //    .addNotificationHandler(function() {
            //        win.render();
            //    });
            //dispGroup.add(win.ctrl_showEnhInfo);
            //
            //win.ctrl_showFracInfo = Controls.Check({text: _TRL('Show fraction info'), checked: true})
            //    .addNotificationHandler(function() {
            //        win.render();
            //    });
            //dispGroup.add(win.ctrl_showFracInfo);
            //
            //win.ctrl_showSelInfo = Controls.Check({text: _TRL('Show selection info'), checked: true})
            //    .addNotificationHandler(function() {
            //        win.render();
            //    });
            //dispGroup.add(win.ctrl_showSelInfo);

            //
            //win.ctrlSortType = Controls.DropList({}).addNotificationHandler(function() {
            //    win.parseData();
            //    win.plot.render();
            //});
            //win.ctrlSortType.addState('val', _TRL("Alphabetical"));
            //win.ctrlSortType.addState('count', _TRL("Count"));
            //dispGroup.add(Controls.Compound.GroupVert({}, [
            //    _TRL('Sort by:'),
            //    win.ctrlSortType
            //]));
            //win.colorLegendCtrl = Controls.Static({});
            //dispGroup.add(win.colorLegendCtrl);
        };

        win.updateAspect = function (aspectId) {
            win.render();
        };

        //win.parseData = function() {
        //    var propBinVal = win.getAspectProperty('binval');
        //    var propPredictor = win.getAspectProperty('predictor');
        //    var dataBinVal = propBinVal.data;
        //    var dataPredictor = propPredictor.data;
        //    var dataPrimKey = win.getPrimKeyProperty().data;
        //
        //};


        win.clear = function () {
            win.plot.setContent('Not updated');
        };

        win.render = function () {
            var propBinVal = win.getAspectProperty('binval');
            var propPredictor = win.getAspectProperty('predictor');
            var dataBinVal = propBinVal.data;
            var dataPredictor = propPredictor.data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            //win.parseData();
            var content = '';

            var data = [];
            for (var i = 0; i < dataBinVal.length; i++) {
                if (dataBinVal[i] !== null && dataPredictor[i] !== null) data.push({ binval: dataBinVal[i], predictor: dataPredictor[i] });
            }
            data.sort(AXMUtils.ByProperty('predictor'));

            var valsNeg = [];
            var valsPos = [];
            $.each(data, function (idx, pt) {
                if (pt.binval == false) valsNeg.push(pt.predictor);
                if (pt.binval == true) valsPos.push(pt.predictor);
            });
            var countNeg = valsNeg.length;
            var countPos = valsPos.length;
            //content += 'Count negative: {countneg}<br>Count positive: {countpos}<br>'.AXMInterpolate({countneg: valsNeg.length, countpos: valsPos.length});

            content += '<h1>Parametric</h1>';
            var dfNeg = Stats.NormDfEstimator(valsNeg);
            dfNeg.calcParametric();
            content += '<h3>Negative</h3>Count= {ct}<br>Average= {av}<br>Standard deviation= {stdev}<br>'.AXMInterpolate({ ct: dfNeg.getCount(), av: dfNeg.getMean(), stdev: dfNeg.getStdev() });
            var dfPos = Stats.NormDfEstimator(valsPos);
            dfPos.calcParametric();
            content += '<h3>Positive</h3>Count= {ct}<br>Average= {av}<br>Standard deviation= {stdev}<br>'.AXMInterpolate({ ct: dfPos.getCount(), av: dfPos.getMean(), stdev: dfPos.getStdev() });

            content += '<h3>Distance</h3>Difference= {diff}<br><b>Weighted difference= {wdiff}</b>'.AXMInterpolate({
                diff: Math.abs(dfNeg.getMean() - dfPos.getMean()),
                wdiff: Math.abs(dfNeg.getMean() - dfPos.getMean()) / ((dfNeg.getStdev() + dfPos.getStdev()) / 2)
            });

            // make sure negatives are smaller than positives
            var fac = 1;
            if (dfNeg.getMean() > dfPos.getMean()) {
                fac = -1;
                data.sort(AXMUtils.ByPropertyReverse('predictor'));
            }

            var costFN = parseFloat(win.ctrl_costFN.getValue());
            var costFP = parseFloat(win.ctrl_costFP.getValue());
            var costUN = parseFloat(win.ctrl_costUN.getValue());

            var bestDivisionNeg = -1.0E99;

            var optimNeg = function optimNeg() {
                var ntot = 0;
                var nn = 0;
                var np = 0;
                var bestCost = 1e99;
                for (var idx = 0; idx < data.length - 1; idx++) {
                    var pt = data[idx];
                    ntot++;
                    if (pt.binval) np++;else nn++;
                    var cost = costFN * np + costUN * (data.length - ntot);
                    var tryDivisionNeg = (pt.predictor + data[idx + 1].predictor) / 2.0;
                    if (cost < bestCost) {
                        bestCost = cost;
                        bestDivisionNeg = tryDivisionNeg;
                    }
                }
            };

            var bestDivisionPos = 1.0E99;

            var optimPos = function optimPos() {
                var ntot = 0;
                var nn = 0;
                var np = 0;
                var bestCost = 1e99;
                for (var idx = data.length - 1; idx > 0; idx--) {
                    var pt = data[idx];
                    ntot++;
                    if (pt.binval) np++;else nn++;
                    var cost = costFP * nn + costUN * (data.length - ntot);
                    var tryDivisionPos = (pt.predictor + data[idx - 1].predictor) / 2.0;
                    if (cost < bestCost && tryDivisionPos >= bestDivisionNeg) {
                        bestCost = cost;
                        bestDivisionPos = tryDivisionPos;
                    }
                }
            };

            if (costFN > costFP) {
                optimPos();
                optimNeg();
            } else {
                optimNeg();
                optimPos();
            }

            //determine error counts
            var ctFP = 0;
            var ctFN = 0;
            var ctUN = 0;
            for (var idx = 0; idx < data.length; idx++) {
                var pt = data[idx];
                var predNeg = false;
                var predUN = false;
                var predPos = false;
                if (pt.predictor * fac < bestDivisionNeg * fac) predNeg = true;
                if (pt.predictor * fac > bestDivisionPos * fac) predPos = true;
                if (!predNeg && !predPos) predUN = true;
                if (pt.binval) {
                    if (predNeg) ctFN++;
                } else {
                    if (predPos) ctFP++;
                }
                if (predUN) ctUN++;
            }

            content += '<h1>Cost estimate</h1>';
            content += 'Negative limit= {lim}<br>'.AXMInterpolate({ lim: bestDivisionNeg });
            content += 'Positive limit= {lim}<br>'.AXMInterpolate({ lim: bestDivisionPos });
            content += 'FN= {fn}<br>'.AXMInterpolate({ fn: ctFN });
            content += 'FP= {fp}<br>'.AXMInterpolate({ fp: ctFP });
            content += 'UN= {un}<br>'.AXMInterpolate({ un: ctUN });

            var totCost = ctFN * costFN + ctFP * costFP + ctUN * costUN;
            content += '<b>Cost= {cost}</b><br>'.AXMInterpolate({ cost: totCost });

            win.plot.setContent(content);
        };

        win.initPlot = function () {
            //                win.render();
        };

        win.plot.render = win.render;
        win.init();
        win.render();
        return win;
    };

    return PlotType;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(8), __webpack_require__(25), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(15), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Color, PanelCanvasXYPlot, PopupWindow, Controls, SimplePopups, _GenericPlot, DataTypes) {

    var PlotType = _GenericPlot.createPlotType('histogram', _TRL('Histogram'), 'fa-area-chart');

    PlotType.addPlotAspect('value', _TRL('Value'), DataTypes.typeFloat, true);

    PlotType.create = function (dataFrame, aspectMap) {
        var win = PlotType.createGeneric(dataFrame, aspectMap);

        win.plot = PanelCanvasXYPlot.create('', { selectXDirOnly: true });
        win.plot._directRedraw = true; //might be changed
        win._opacity = 0.40;

        win._createDisplayControls = function (dispGroup) {

            win.ctrl_Resolution = Controls.Slider({
                width: 160,
                minValue: -1,
                maxValue: +1,
                step: 0.01,
                value: 0,
                text: _TRL('Resolution')
            }).addNotificationHandler(function () {
                win.parseData();
                win.render();
            });
            dispGroup.add(win.ctrl_Resolution);

            win.infoCtrl = Controls.Static({});
            win.infoSelectionCtrl = Controls.Static({});
            dispGroup.add(win.infoCtrl);
            dispGroup.add(win.infoSelectionCtrl);
        };

        win.render = function () {
            win.plot.render();
        };

        win.initPlot = function () {
            win.parseData();
        };

        win.plot.drawPlot = function (drawInfo) {
            var plot = win.plot;
            var ctx = drawInfo.ctx;
            var scaleX = plot.getXScale();
            var offsetX = plot.getXOffset();
            var scaleY = plot.getYScale();
            var offsetY = plot.getYOffset();
            plot.scaleX = scaleX;plot.offsetX = offsetX;
            plot.scaleY = scaleY;plot.offsetY = offsetY;
            drawInfo.scaleX = scaleX;drawInfo.offsetX = offsetX;
            drawInfo.scaleY = scaleY;drawInfo.offsetY = offsetY;
            var xL2S = win.plot.coordXLogic2Win;
            var yL2S = win.plot.coordYLogic2Win;

            var dataVal = win.getAspectProperty('value').data;
            var dataPrimKey = win.getPrimKeyProperty().data;

            var binValuesSelected = [];
            for (var i = 0; i < win._binCount; i++) {
                binValuesSelected.push(0);
            }var rowSelGet = win.dataFrame.objectType.rowSelGet;
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                if (rowSelGet(dataPrimKey[rowNr])) binValuesSelected[Math.floor((dataVal[rowNr] - win._binOffset) / win._binSize)]++;
            }

            ctx.strokeStyle = Color.Color(0, 0, 0).toStringCanvas();
            for (var binNr = 0; binNr < win._binCount; binNr++) {
                var binCount = win._binValues[binNr];
                var x1 = Math.round(xL2S(win._binOffset + (binNr + 0) * win._binSize)) + 0.5;
                var x2 = Math.round(xL2S(win._binOffset + (binNr + 1) * win._binSize)) + 0.5;
                var y1 = Math.round(yL2S(0.0)) + 0.5;
                var y2 = Math.round(yL2S(binCount)) + 0.5;
                ctx.fillStyle = Color.Color(0.8, 0.8, 0.8).toStringCanvas();
                ctx.beginPath();
                ctx.rect(x1, y1, x2 - x1, y2 - y1);
                ctx.fill();
                ctx.stroke();
                var selCount = binValuesSelected[binNr];
                if (selCount > 0) {
                    var y2s = yL2S(selCount);
                    ctx.fillStyle = Color.Color(1, 0.0, 0, 0.5).toStringCanvas();
                    ctx.beginPath();
                    ctx.rect(x1 + 1, y1, x2 - x1, y2s - y1);
                    ctx.fill();
                }
            }
        };

        win.plot.handleRectSelection = function (pt1, pt2) {
            var xMin = win.plot.coordXWin2Logic(Math.min(pt1.x, pt2.x));
            var xMax = win.plot.coordXWin2Logic(Math.max(pt1.x, pt2.x));

            var dataVal = win.getAspectProperty('value').data;
            var dataPrimKey = win.getPrimKeyProperty().data;
            var selList = [];
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                if (dataVal[rowNr] >= xMin && dataVal[rowNr] <= xMax) selList.push(dataPrimKey[rowNr]);
            }
            win.performRowSelected(selList);
        };

        win.updateAspect = function (aspectId) {
            win.parseData();
            win.render();
        };

        /**
         * Create text for display in info section of the plot
         * @param {[]} values: list of data values
         * @returns {String}: info text to display
         * @private
         */
        win._infoText = function (values) {

            var minVal = +1.0e99;
            var maxVal = -1.0e99;
            var sum = 0;
            var count = values.length;

            for (var rowNr = 0; rowNr < count; rowNr++) {
                var val = values[rowNr];
                if (val < minVal) minVal = val;
                if (val > maxVal) maxVal = val;
                sum += val;
            }

            var str = '';
            str += 'Min: ' + minVal + '<br>';
            str += 'Max: ' + maxVal + '<br>';
            str += 'Count: ' + count + '<br>';
            str += 'Sum: ' + sum + '<br>';
            var average = sum / count;
            str += 'Average: ' + average + '<br>';

            var stdev = 0;
            for (var i = 0; i < values.length; i += 1) {
                stdev += Math.pow(values[i] - average, 2.0);
            }stdev = Math.sqrt(stdev / values.length);
            str += 'Stdev: ' + stdev + '<br>';

            function median(values) {
                values.sort(function (a, b) {
                    return a - b;
                });
                var half = Math.floor(values.length / 2);
                if (values.length % 2) return values[half];else return (values[half - 1] + values[half]) / 2.0;
            }

            str += 'Median: ' + median(values) + '<br>';

            return str;
        };

        win.parseData = function () {
            var propVal = win.getAspectProperty('value');
            var dataVal = propVal.data;

            var values = [];
            var minVal = +1.0e99;
            var maxVal = -1.0e99;
            var count = 0;
            for (var rowNr = 0; rowNr < win.dataFrame.getRowCount(); rowNr++) {
                var val = dataVal[rowNr];
                if (val !== null && !isNaN(val)) {
                    values.push(val);
                    if (val < minVal) minVal = val;
                    if (val > maxVal) maxVal = val;
                    count++;
                }
            }

            var resolMultFac = Math.exp(2 * win.ctrl_Resolution.getValue());

            var binSize = 1;
            if (minVal == maxVal) binSize = minVal * 0.1;else {
                var jumpPrototypes = [1, 2, 5];
                var optimalbincount = Math.floor(Math.sqrt(count)) * resolMultFac;
                optimalbincount = Math.max(optimalbincount, 2);
                optimalbincount = Math.min(optimalbincount, 200);
                var optimalbinsize = (maxVal - minVal) * 1.0 / optimalbincount;
                var mindist = 1.0e99;
                $.each(jumpPrototypes, function (idx, jumpPrototype) {
                    var q = Math.floor(AXMUtils.log10(optimalbinsize / jumpPrototype));
                    var TryJump1A = Math.pow(10, q) * jumpPrototype;
                    var TryJump1B = Math.pow(10, q + 1) * jumpPrototype;
                    if (Math.abs(TryJump1A - optimalbinsize) < mindist) {
                        mindist = Math.abs(TryJump1A - optimalbinsize);
                        binSize = TryJump1A;
                    }
                    if (Math.abs(TryJump1B - optimalbinsize) < mindist) {
                        mindist = Math.abs(TryJump1B - optimalbinsize);
                        binSize = TryJump1B;
                    }
                });
            }

            win._binSize = binSize;
            win._binOffset = Math.floor(minVal / binSize) * binSize;
            win._binCount = Math.floor((maxVal - win._binOffset) / binSize) + 1;
            win._binValues = [];
            for (var i = 0; i < win._binCount; i++) {
                win._binValues.push(0);
            }$.each(values, function (idx, val) {
                var binNr = Math.floor((val - win._binOffset) / binSize);
                if (binNr < 0 || binNr >= win._binCount) AXMUtils.reportBug(_TRL('Invalid bin'));
                win._binValues[binNr] += 1;
            });

            win._maxBinSize = 1;
            $.each(win._binValues, function (idx, value) {
                if (value > win._maxBinSize) win._maxBinSize = value;
            });

            var rangeX = AXMUtils.valueRange(win._binOffset, win._binOffset + win._binCount * win._binSize);
            rangeX.extendFraction(0.1);
            var rangeY = AXMUtils.valueRange(0, win._maxBinSize);
            rangeY.extendFraction(0.1);
            win.plot.setXRange(rangeX.getMin(), rangeX.getMax());
            win.plot.setYRange(rangeY.getMin(), rangeY.getMax());
            win.plot.setXLabel(propVal.getDispName());

            win.infoCtrl.modifyText(win._infoText(values));
            win.parseSelectedData();
        };

        /**
         * Parse selected data, calculate properties and display them in the Display section of the plot.
         */
        win.parseSelectedData = function () {
            var propVal = win.getAspectProperty('value');
            var dataVal = propVal.data;

            var dataPrimKey = win.getPrimKeyProperty().data;
            var rowSelGet = win.dataFrame.objectType.rowSelGet;

            var values = [];
            for (var rowNr = 0; rowNr < dataVal.length; rowNr++) {
                if (rowSelGet(dataPrimKey[rowNr])) {
                    var val = dataVal[rowNr];
                    if (val !== null && !isNaN(val)) {
                        values.push(val);
                    }
                }
            }
            var str = 'Selection: '.bold() + '<br>';
            str += win._infoText(values);
            win.infoSelectionCtrl.modifyText(str);
        };

        win.modifySetting = function (settingKey, settingValue) {
            if (settingKey == "Resolution") {
                win.ctrl_Resolution.setValue(settingValue);
                return;
            }
            throw "Invalid plot setting: " + settingKey;
        };

        win.setXRange = function (mn, mx) {
            win.plot.setXRange(mn, mx);
            win.render();
        };

        win.listen('DataFrameRowSelChanged', function (objectTypeId) {
            if (objectTypeId == win.dataFrame.objectType.typeId) win.parseSelectedData();
        });

        win.init();
        return win;
    };

    return PlotType;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, Controls, SimplePopups, DataTypes) {

    var Module = {};
    Module.lastExpr = '';
    Module.lastName = 'NewProperty';

    Module.create = function (dataFrame, startExpr, onCompleted) {

        var win = PopupWindow.create({
            title: _TRL('Calculate property'),
            blocking: true,
            autoCenter: true
        });

        if (startExpr) Module.lastExpr = startExpr;
        var grp = Controls.Compound.GroupVert({ separator: 15 });
        grp.add(_TRL('<i>Use the following tokens in the expression:</i>'));
        var grd = Controls.Compound.Grid({ sepH: 4, sepV: 2 });
        $.each(dataFrame.getProperties(), function (idx, property) {
            var filterButton = Controls.Button({
                icon: 'fa-plus-square',
                width: 25,
                height: 19,
                buttonClass: 'AXMButtonCommandBar',
                iconSizeFraction: 0.9
            }).addNotificationHandler(function () {
                var str = win.ctrlExpr.getValue() + 'pt.' + property.getId();
                win.ctrlExpr.setValue(str);
                win.ctrlExpr.setFocus();
            });
            grd.setItem(idx, 0, filterButton);
            grd.setItem(idx, 1, '<b>pt.' + property.getId() + '</b>');
            grd.setItem(idx, 2, property.getDispName());
        });
        grp.add(Controls.Compound.VScroller(grd, 300));

        win.ctrlExpr = Controls.Edit({ width: 500, value: Module.lastExpr }).setHasDefaultFocus();
        grp.add(win.ctrlExpr);

        win.ctrlType = Controls.DropList({ width: 150, value: DataTypes.typeFloat.id });
        grp.add(Controls.Compound.GroupHor({}, ['Property type:&nbsp;&nbsp;', win.ctrlType]));
        $.each(DataTypes.typesMap, function (id, val) {
            win.ctrlType.addState(id, val.getName);
        });

        win.ctrlName = Controls.Edit({ width: 150, value: Module.lastName });
        grp.add(Controls.Compound.GroupHor({}, ['Property name:&nbsp;&nbsp;', win.ctrlName]));

        //grp.add(_TRL('<i>NOTE: test equality with "==". Surround strings with single quotes.</i>'));

        var btOK = Controls.Button({
            text: _TRL('Execute'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.execute();
        });
        grp.add(btOK);

        win.execute = function () {
            win.close();
            var expr = win.ctrlExpr.getValue();
            Module.lastExpr = expr;
            var name = win.ctrlName.getValue();
            Module.lastName = name;
            var newProp = null;
            $.each(dataFrame.getProperties(), function (idx, propInfo) {
                if (propInfo.getDispName() == name) newProp = propInfo;
            });
            if (!newProp) {
                newProp = dataFrame.addProperty(name, name, DataTypes.typesMap[win.ctrlType.getValue()], {});
            }
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var newVal = null;
                try {
                    var pt = {};
                    $.each(dataFrame.getProperties(), function (idx, property) {
                        pt[property.getId()] = property.data[rowNr];
                    });
                    newVal = eval(expr);
                } catch (err) {}
                newProp.data[rowNr] = newVal;
            }
            onCompleted();
        };

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, Controls, SimplePopups, DataTypes) {

    var Module = {};
    Module.lastExpr = '';

    Module.create = function (dataFrame, startExpr, onCompleted) {

        var win = PopupWindow.create({
            title: _TRL('Execute script for each row'),
            blocking: true,
            autoCenter: true
        });

        if (startExpr) Module.lastExpr = startExpr;
        var grp = Controls.Compound.GroupVert({ separator: 15 });
        grp.add(_TRL('<i>Use the following tokens in the script:</i>'));
        var grd = Controls.Compound.Grid({ sepH: 4, sepV: 2 });
        $.each(dataFrame.getProperties(), function (idx, property) {
            var filterButton = Controls.Button({
                icon: 'fa-plus-square',
                width: 25,
                height: 19,
                buttonClass: 'AXMButtonCommandBar',
                iconSizeFraction: 0.9
            }).addNotificationHandler(function () {
                var str = win.ctrlExpr.getValue() + 'pt.' + property.getId();
                win.ctrlExpr.setValue(str);
                win.ctrlExpr.setFocus();
            });
            grd.setItem(idx, 0, filterButton);
            grd.setItem(idx, 1, '<b>pt.' + property.getId() + '</b>');
            grd.setItem(idx, 2, property.getDispName());
        });
        grp.add(Controls.Compound.VScroller(grd, 250));

        win.ctrlExpr = Controls.TextArea({
            width: 500, lineCount: 6,
            fixedfont: true,
            noWrap: true,
            value: Module.lastExpr
        }).setHasDefaultFocus();
        grp.add(win.ctrlExpr);

        var btOK = Controls.Button({
            text: _TRL('Execute'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.execute();
        });
        grp.add(btOK);

        win.execute = function () {
            win.close();
            var expr = win.ctrlExpr.getValue();
            Module.lastExpr = expr;
            for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var newVal = null;
                try {
                    var pt = {};
                    $.each(dataFrame.getProperties(), function (idx, property) {
                        pt[property.getId()] = property.data[rowNr];
                    });
                    eval(expr);
                    $.each(dataFrame.getProperties(), function (idx, property) {
                        property.data[rowNr] = pt[property.getId()];
                    });
                } catch (err) {}
            }
            onCompleted();
        };

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, Controls, SimplePopups, DataTypes) {

    var Module = {};
    Module.lastExpr = '';
    Module.lastName = 'NewProperty';

    Module.create = function (dataFrame, onCompleted) {

        var compatibleDataFrames = [];
        $.each(__webpack_require__(26)._activeDataFrames, function (idx, activeDataFrame) {
            if (dataFrame.getObjectType().getTypeId() == activeDataFrame.getObjectType().getTypeId() && dataFrame != activeDataFrame) compatibleDataFrames.push(activeDataFrame);
        });
        if (compatibleDataFrames.length == 0) {
            SimplePopups.ErrorBox('There are currently no compatible dataframe tables open.');
            return;
        }

        var win = PopupWindow.create({
            title: _TRL('Import property'),
            blocking: true,
            autoCenter: true
        });

        var grp = Controls.Compound.GroupVert({ separator: 15 });

        win.ctrlDataFrame = Controls.DropList({ width: 300 });
        $.each(compatibleDataFrames, function (idx, frame) {
            win.ctrlDataFrame.addState(idx + 1, frame.getName());
        });
        grp.add(Controls.Compound.GroupHor({ verticalAlignCenter: true, separator: 7 }, ['Dataframe: ', win.ctrlDataFrame]));
        win.ctrlDataFrame.addNotificationHandler(function () {
            win.update();
        });

        win.ctrlProperty = Controls.DropList({ width: 300 });
        grp.add(Controls.Compound.GroupHor({ verticalAlignCenter: true, separator: 7 }, ['Property: ', win.ctrlProperty]));

        //win.ctrlName = Controls.Edit({width: 150, value: Module.lastName});
        //grp.add(Controls.Compound.GroupHor({}, ['Property name: ', win.ctrlName]));


        var btOK = Controls.Button({
            text: _TRL('Execute'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.execute();
        });

        var btAddAllProperties = Controls.Button({
            text: _TRL('Import all properties'),
            icon: 'fa-arrows-v'
        }).addNotificationHandler(function () {
            win.executeAll();
        });

        grp.add(Controls.Compound.GroupHor({}, [btOK, btAddAllProperties]));

        win.update = function () {
            win.ctrlProperty.clearStates();
            var dataFrameId = parseInt(win.ctrlDataFrame.getValue()) - 1;
            if (dataFrameId >= 0) {
                var dataFrame = compatibleDataFrames[dataFrameId];
                $.each(dataFrame.getProperties(), function (idx, propInfo) {
                    win.ctrlProperty.addState(propInfo.getId(), propInfo.getDispName());
                });
            }
        };

        win.execute = function () {
            var dataFrameId = parseInt(win.ctrlDataFrame.getValue()) - 1;
            if (dataFrameId >= 0) {
                win._copySingleProperty(dataFrameId, win.ctrlProperty.getValue());
                win.close();
            }
            onCompleted();
        };

        win.executeAll = function () {
            var dataFrameId = parseInt(win.ctrlDataFrame.getValue()) - 1;
            if (dataFrameId >= 0) {
                var dataFrame = compatibleDataFrames[dataFrameId];
                $.each(dataFrame.getProperties(), function (idx, propInfo) {
                    win._copySingleProperty(dataFrameId, propInfo.getId());
                });
                win.close();
            }
            onCompleted();
        };

        win._copySingleProperty = function (dataFrameId, propId) {
            var sourceDataFrame = compatibleDataFrames[dataFrameId];
            var propInfo = sourceDataFrame.getProperty(propId);
            var newProp = dataFrame.addProperty(AXMUtils.getUniqueID(), sourceDataFrame.getName() + ': ' + propInfo.getDispName(), propInfo.getDataType(), {});
            var primKey = dataFrame.getPrimKeyProperty();
            var sourcePrimKey = sourceDataFrame.getPrimKeyProperty();
            var sourceMap = {};
            for (var rowNr = 0; rowNr < sourceDataFrame.getRowCount(); rowNr++) {
                sourceMap[sourcePrimKey.data[rowNr]] = rowNr;
            }for (var rowNr = 0; rowNr < dataFrame.getRowCount(); rowNr++) {
                var newVal = null;
                var ID = primKey.data[rowNr];
                if (ID in sourceMap) newVal = propInfo.data[sourceMap[ID]];
                newProp.data[rowNr] = newVal;
            }
        };

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
        win.update();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(3), __webpack_require__(5), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, PopupWindow, Controls, SimplePopups, DataTypes) {

    var Module = {};

    Module.create = function (dataFrame, onCompleted) {

        var compatibleDataFrames = [];
        $.each(__webpack_require__(26)._activeDataFrames, function (idx, activeDataFrame) {
            if (dataFrame.getObjectType().getTypeId() == activeDataFrame.getObjectType().getTypeId() && dataFrame != activeDataFrame) compatibleDataFrames.push(activeDataFrame);
        });
        if (compatibleDataFrames.length == 0) {
            SimplePopups.ErrorBox('There are currently no compatible dataframe tables open.');
            return;
        }

        var win = PopupWindow.create({
            title: _TRL('Append dataframe'),
            blocking: true,
            autoCenter: true
        });

        var grp = Controls.Compound.GroupVert({ separator: 15 });

        win.ctrlDataFrame = Controls.DropList({ width: 300 });
        $.each(compatibleDataFrames, function (idx, frame) {
            win.ctrlDataFrame.addState(idx + 1, frame.getName());
        });
        grp.add(Controls.Compound.GroupHor({}, ['Dataframe: ', win.ctrlDataFrame]));

        var btOK = Controls.Button({
            text: _TRL('Execute'),
            icon: 'fa-check'
        }).addNotificationHandler(function () {
            win.execute();
        });
        grp.add(btOK);

        win.execute = function () {
            var dataFrameId = parseInt(win.ctrlDataFrame.getValue()) - 1;
            if (dataFrameId >= 0) {
                var sourceDataFrame = compatibleDataFrames[dataFrameId];
                dataFrame.append(sourceDataFrame);
                win.close();
            }
            onCompleted();
        };

        win.setRootControl(Controls.Compound.StandardMargin(grp));
        win.start();
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//Copyright (c) 2015 Multiplicom NV
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//and associated documentation files (the "Software"), to deal in the Software without restriction,
//including without limitation the rights to use, copy, modify, merge, publish, distribute,
//sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(10), __webpack_require__(11), __webpack_require__(3), __webpack_require__(22), __webpack_require__(6), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, $, _, AXMUtils, Frame, PanelHtml, Controls, ControlsCompound, PopupWindow, DOM) {

    /**
     * Module implementing FlexTabber classes, used to organise the web application client area in a dynamic way
     * @type {{}}
     */
    var Module = {};

    Module.leftPartSize = 160;

    Module.setLeftPartSize = function (size) {
        Module.leftPartSize = size;
    };

    /**
     * Creates a new TabInfo object
     * @param {string} tabId
     * @param {AXM.Panel.FlexTabber} parentContainer - FlexTabber frame frame this tab will belong to
     * @param {AXM.Iconn.HeaderInfo} headerInfo - object containing info about the header of the tab (icon, title, ...)
     * @param {AXM.Frame} tabFrame - frame that whill be shown in the tab
     * @param {int} stackNr - index of the tab in the stack of tabs
     * @param {{}} settings - extra settings
     * @param {boolean} settings.isFixed - if true, the tab cannot be removed
     * @returns {{}} - tab info object
     */
    Module.createTabInfo = function (tabId, parentContainer, headerInfo, tabFrame, stackNr, settings) {
        var tabInfo = {};
        AXMUtils.Test.checkIsType(headerInfo, 'headerinfo');
        AXMUtils.Test.checkIsType(parentContainer, "flextabber");
        AXMUtils.Test.checkIsType(tabFrame, "@Frame");

        tabInfo.headerInfo = headerInfo;
        tabInfo.parentContainer = parentContainer;
        tabInfo.tabFrame = tabFrame;
        tabInfo.stackNr = stackNr;
        tabInfo.tabId = tabId;
        tabInfo._isFixed = !!settings.isFixed;

        /**
         * Returns the html for the tab header
         * @returns {string}
         */
        tabInfo.createHtml = function () {
            var tabDiv = DOM.Div({ id: tabInfo.tabId });
            tabDiv.addCssClass('AXMFlexTab');
            tabDiv.addCssClass('AXMFlexTabInActive');
            tabDiv.addCssClass('AXMFlexTabInActiveHighlight');
            tabDiv.addStyle('display', 'none');
            var tabContent = DOM.Div({ parent: tabDiv });
            tabContent.addCssClass('AXMFlexTabContent');

            var iconDiv = DOM.Div({ parent: tabContent });
            iconDiv.addCssClass('AXMFlexTabIcon');
            iconDiv.addElem(tabInfo.headerInfo.icon.renderHtml());

            var textDiv = DOM.Div({ parent: tabContent });
            textDiv.addCssClass('AXMFlexTabText');
            var textLine1Div = DOM.Div({ parent: textDiv });
            textLine1Div.addCssClass("TabTitle1");
            textLine1Div.addElem(tabInfo.headerInfo.title1);
            var textLine2Div = DOM.Div({ parent: textDiv });
            textLine2Div.addCssClass("TabTitle2");
            textLine2Div.addStyle("max-width", Module.leftPartSize - 40 + "px");
            textLine2Div.addStyle("overflow", "hidden");
            textLine2Div.addStyle("text-overflow", "ellipsis");
            textLine2Div.addElem(tabInfo.headerInfo.title2);

            if (!tabInfo._isFixed) {
                var closeDiv = DOM.Create('span', { parent: tabDiv });
                closeDiv.addCssClass('AXMFlexTabCloser');
                closeDiv.addElem('<i class="fa fa-times-circle"/>');

                var popupDiv = DOM.Create('span', { parent: tabDiv });
                popupDiv.addCssClass('AXMFlexTabToPopup');
                popupDiv.addElem('<i class="fa fa-arrow-circle-right"/>');
            }

            return tabDiv.toString();
        };

        /**
         * Returns the jQuery element with the tab header
         * @returns {jQuery}
         */
        tabInfo.get$El = function () {
            return $('#' + tabInfo.tabId);
        };

        /**
         * Attach the required event handlers to the tab header after DOM insertion
         */
        tabInfo.attachEventHandlers = function () {
            var el = tabInfo.get$El();
            el.click(function () {
                tabInfo.parentContainer.activateTab_byID(tabInfo.tabId);
            });

            el.find('.AXMFlexTabCloser').click(function (ev) {
                tabInfo.parentContainer.closeTab_byID(tabInfo.tabId);
                ev.stopPropagation();
                return null;
            });

            el.find('.AXMFlexTabToPopup').click(function (ev) {
                tabInfo.parentContainer.convertToPopup_byID(tabInfo.tabId);
                ev.stopPropagation();
                return null;
            });
        };

        /**
         * Detach the required event handlers to the tab header
         */
        tabInfo.detachEventHandlers = function () {
            var el = tabInfo.get$El();
            el.unbind('click');
            el.find('.AXMFlexTabCloser').unbind('click');
            el.find('.AXMFlexTabToPopup').unbind('click');
        };

        return tabInfo;
    };

    /**
     * Creates a FlexTabber frame
     * @returns {Object}
     */
    Module.create = function () {
        var frame = Frame.FrameSplitterHor();
        frame.extend('flextabber');
        frame.setHalfSplitterSize(3);
        frame.splitterColor = "white";

        frame._id = AXMUtils.getUniqueID();

        frame._panelTabs = PanelHtml.create(frame._id + 'flexTabberLeft');
        frame._panelTabs.enableVScrollingNoBar();

        frame._frameTabs = frame.addMember(Frame.FrameFinal(frame._panelTabs));
        frame._frameTabs.setFixedDimSize(Frame.dimX, Module.leftPartSize);
        frame._frameStacker = frame.addMember(Frame.FrameStacker());

        frame._myTabs = [];
        frame._activeTab = -1;
        frame._history_tabId = [];

        frame._panelTabs.setContent('<div class="flexTabWrapperFull"><div class="flexTabWrapper"></div></div>');

        /**
         * Call this to allow the FlexTabber to use the browser history
         */
        frame.setUseBrowserHistory = function () {
            frame._useBrowserHistory = true;
            window.onpopstate = function (event) {
                if (event.state) frame.activateTab_byID(event.state.viewId, true);
            };
        };

        /**
         * Adds a new tab to the frame
         * @param tabId {string|null} - Identifier of the tab (might be null)
         * @param headerInfo - AXM.Icon.HeaderInfo
         * @param theFrame - frame content
         * @param {{}} settings - settings
         * @param {boolean} settings.isFixed - if true, the tab cannot be removed
         * @param {boolean} settings.autoActivate - if true, the tab becomes automatically activate
         * @returns {string} - ID of the tab
         */
        frame.addTabFrame = function (tabId, headerInfo, theFrame, settings) {
            if (!tabId) tabId = 'TB_' + AXMUtils.getUniqueID();else if (frame.hasTabId(tabId)) AXMUtils.Test.reportBug("Tab is already present: " + tabId);
            AXMUtils.Test.checkIsType(headerInfo, 'headerinfo');
            if (settings.autoActivate !== false) frame._activeTab = frame._myTabs.length;
            var tabInfo = Module.createTabInfo(tabId, frame, headerInfo, theFrame, frame._frameStacker.getmemberFrameCount(), settings);
            frame._myTabs.push(tabInfo);
            frame._frameStacker.dynAddMember(theFrame);

            tabInfo.parentContainer._panelTabs.get$El().find('.flexTabWrapper').append(tabInfo.createHtml());
            setTimeout(function () {
                frame._panelTabs.scrollToBottom();
            }, 200);

            tabInfo.get$El().slideDown(200, function () {
                tabInfo.get$El().removeClass('AXMFlexTabInActiveHighlight');
            });

            tabInfo.attachEventHandlers();
            if (settings.autoActivate !== false) frame.activateTab_byID(tabInfo.tabId);
            return tabInfo.tabId;
        };

        /**
         * Modifies the title of a tab frame
         * @param tabId {string} id of the tab
         * @param newTitle1 {string} - title line 1
         * @param newTitle2 {string} - title line 2
         * @param settings {{}} - label settings
         */
        frame.changeTabFrameTitle = function (tabId, newTitle1, newTitle2, settings) {
            var tabNr = frame._tabId2Nr_noFail(tabId);
            if (!settings) settings = {};

            if (tabNr >= 0) {
                var tabInfo = frame._myTabs[tabNr];
                tabInfo.headerInfo.title1 = newTitle1;
                tabInfo.headerInfo.title2 = newTitle2;
                tabInfo.headerInfo.labels = settings.labels || {};
                frame._updateTabStates();
                tabInfo.get$El().find('.TabTitle1').html(newTitle1);
                tabInfo.get$El().find('.TabTitle2').html(newTitle2);
            }

            $.each(PopupWindow.getActiveWindowList(), function (idx, popupWindow) {
                if (tabId === popupWindow.__originalFlexTabberId) {
                    popupWindow.modifyLabels(settings.labels || {});
                    popupWindow.modifyTitle(newTitle1 + " " + newTitle2);
                }
            });
        };

        /**
         * Returns the tab index associated with a tab ID, and returns -1 of not present
         * @param {string} tabId
         * @returns {number}
         * @private
         */
        frame._tabId2Nr_noFail = function (tabId) {
            var tabNr = -1;
            $.each(frame._myTabs, function (idx, _tabInfo) {
                if (_tabInfo.tabId == tabId) {
                    tabNr = idx;
                }
            });
            return tabNr;
        };

        /**
         * Returns the tab index associated with a tab ID, and fails of not present
         * @param {string} tabId
         * @returns {number}
         * @private
         */
        frame._tabId2Nr = function (tabId) {
            var tabNr = frame._tabId2Nr_noFail(tabId);
            if (tabNr < 0) AXMUtils.reportBug("Invalid tab ID");
            return tabNr;
        };

        /**
         * Returns the ID of the currently active tab
         * @returns {string}
         */
        frame.getCurrentTabId = function () {
            if (frame._activeTab < 0 || frame._activeTab >= frame._myTabs.length) return "";
            return frame._myTabs[frame._activeTab].tabId;
        };

        /**
         * Returns the TabInfo object of the currently acive tab
         * @returns {*}
         */
        frame.getCurrentTabInfo = function () {
            if (frame._activeTab < 0 || frame._activeTab >= frame._myTabs.length) return null;
            return frame._myTabs[frame._activeTab];
        };

        /**
         * Determines if a tab is present
         * @param {string} tabId
         * @returns {boolean}
         */
        frame.hasTabId = function (tabId) {
            return frame._tabId2Nr_noFail(tabId) >= 0;
        };

        /**
         * Returns the TabInfo object associated with a tab id
         * @param {string} tabId
         * @returns {*}
         */
        frame.getTabInfo_byId = function (tabId) {
            var tabNr = frame._tabId2Nr(tabId);
            return frame._myTabs[tabNr];
        };

        /**
         * Activates a tab
         * @param {string} tabId - tab id
         * @param {bool} noUpdateHistory - if true, do not update the browser history
         */
        frame.activateTab_byID = function (tabId, noUpdateHistory) {
            var tabNr = frame._tabId2Nr(tabId);
            var tabInfo = frame._myTabs[tabNr];
            if (!tabInfo) return false;
            frame._frameStacker.activateStackNr(tabInfo.stackNr);
            frame._activeTab = tabNr;
            frame._updateTabStates();
            if (frame._useBrowserHistory) {
                if (!noUpdateHistory) {
                    if (history) history.pushState({ viewId: tabInfo.tabId }, "");
                }
            }
            frame._history_tabId.push(tabInfo.tabId);
            return true;
        };

        /**
         * Updates the displayed tab state
         * @private
         */
        frame._updateTabStates = function () {
            frame._panelTabs.get$El().find('.AXMFlexTab').removeClass('AXMFlexTabActive').addClass('AXMFlexTabInActive');
            if (frame._activeTab >= 0 && frame._activeTab < frame._myTabs.length) {
                $('#' + frame._myTabs[frame._activeTab].tabId).removeClass('AXMFlexTabInActive').addClass('AXMFlexTabActive');
                if (frame.hiderCloseView) frame.hiderCloseView.show(!frame.getCurrentTabInfo()._isFixed);
            }

            if (frame.viewTitle) {
                var newTitle = "";
                if (frame.getCurrentTabInfo()) {
                    var currentTabInfo = frame.getCurrentTabInfo();
                    if (currentTabInfo.headerInfo.showTitle) newTitle = frame.getCurrentTabInfo().headerInfo.getSingleTitle();
                }
                frame.viewTitle.get$El().fadeTo(200, 0, function () {
                    var newTitleHtml = '<div class="ViewTitleDecorator">' + newTitle + '</div>';
                    frame.viewTitle.modifyText(newTitleHtml);
                    if (newTitle) frame.viewTitle.get$El().fadeTo(200, 1);
                });
            }

            // Set labels of the flextabber
            $.each(frame.viewLabelDict, function (key, viewLabelCtrl) {
                var newLabel = "";
                if (frame.getCurrentTabInfo()) {
                    var currentTabInfo = frame.getCurrentTabInfo();
                    if (currentTabInfo.headerInfo.showTitle) {
                        var labelInfo = frame.getCurrentTabInfo().headerInfo.labels[key];
                        if (labelInfo) {
                            newLabel = frame.getCurrentTabInfo().headerInfo.labels[key].text;
                        }
                    }
                }
                viewLabelCtrl.get$El().fadeTo(200, 0, function () {
                    viewLabelCtrl.get$El().hide();
                    var labelClass = "ViewTitleDecorator";
                    if (frame.getCurrentTabInfo() && frame.getCurrentTabInfo().headerInfo.labels[key]) {
                        labelClass = frame.getCurrentTabInfo().headerInfo.labels[key].cssClass || "ViewTitleDecorator";
                    }
                    var newLabelHtml = '<div class="{cl}">'.AXMInterpolate({ cl: labelClass }) + newLabel + '</div>';
                    viewLabelCtrl.modifyText(newLabelHtml);
                    if (newLabel) {
                        viewLabelCtrl.get$El().show();
                        viewLabelCtrl.get$El().fadeTo(200, 1);
                    }
                });
            });
        };

        /**
         * Activates an individual panel inside the hierarchical frame structure
         * @param {string} panelTypeId - ID of the panel
         * @returns {boolean} - determines whether or not the panel was found
         */
        frame.activatePanelTypeId = function (panelTypeId) {
            var isFound = false;
            $.each(frame._myTabs, function (idx, tabInfo) {
                if (tabInfo.tabFrame.activatePanelTypeId(panelTypeId)) {
                    frame.activateTab_byID(tabInfo.tabId);
                    isFound = true;
                }
            });
            return isFound;
        };

        /**
         * Closes a tab, provided an ID
         * @param {string} tabId - id of the tab to be removed
         * @param {boolean} doNotAnimate - if true, there will be no animation for closing the frame
         * @param {boolean} doNotRemoveFrame - if true, the frame contained in the tab is not removed (used in the case the frame is transferred to a popup window)
         * @param {function} onCompleted - executed when the animation of the removal is completed
         */
        frame.closeTab_byID = function (tabId, doNotAnimate, doNotRemoveFrame, onCompleted) {
            var tabNr = frame._tabId2Nr(tabId);
            var tabInfo = frame._myTabs[tabNr];

            if (!tabInfo) return;

            //remove tab from history
            for (var idx = 0; idx < frame._history_tabId.length;) {
                if (frame._history_tabId[idx] == tabId) frame._history_tabId.splice(idx, 1);else idx++;
            }

            if (!doNotRemoveFrame) {
                var closePreventReason = tabInfo.tabFrame._getAnyClosePreventReason();
                if (closePreventReason) {
                    alert('Cannot close: ' + closePreventReason);
                    return;
                }
                tabInfo.tabFrame.detachEventHandlers();
                tabInfo.tabFrame.informWillClose();
            }
            var removeFrame = function removeFrame() {
                var tabNr = frame._tabId2Nr(tabId); // need to re-quiry: might be changed after delay
                frame._myTabs[tabNr].detachEventHandlers();
                tabInfo.get$El().remove();
                frame._frameStacker.dynDelMember(tabInfo.stackNr);
                $.each(frame._myTabs, function (idx, tmp1tabInfo) {
                    if (tmp1tabInfo.stackNr > tabInfo.stackNr) tmp1tabInfo.stackNr--;
                });
                if (!doNotRemoveFrame) {
                    tabInfo.tabFrame.getRoot$El().remove();
                }
                frame._myTabs.splice(tabNr, 1);
                if (tabNr == frame._activeTab) {
                    //We need to change the current tab
                    var newTabNr = -1;
                    //First try the most recent historic tab
                    if (frame._history_tabId.length > 0) {
                        newTabNr = frame._tabId2Nr_noFail(frame._history_tabId[frame._history_tabId.length - 1]);
                    }
                    if (newTabNr < 0) {
                        //If that failed, just use the next tab available
                        newTabNr = frame._activeTab;
                        if (newTabNr >= frame._myTabs.length) newTabNr--;
                    }
                    frame._activeTab = newTabNr;
                    if (frame._activeTab >= 0) frame.activateTab_byID(frame._myTabs[frame._activeTab].tabId);
                } else {
                    if (tabNr < frame._activeTab) frame._activeTab--;
                }
                if (onCompleted) onCompleted();
            };
            if (doNotAnimate) {
                removeFrame();
            } else {
                tabInfo.get$El().slideUp(200, removeFrame);
            }
        };

        /**
         * Converts a tab to a popup window
         * @param {string} tabId - id of the tab to be converted
         */
        frame.convertToPopup_byID = function (tabId) {
            var tabNr = frame._tabId2Nr(tabId);
            var tabInfo = frame._myTabs[tabNr];

            var popup = PopupWindow.create({
                //title: tabInfo.headerInfo.title1,
                blocking: false,
                autoCenter: true,
                canDock: true,
                sizeX: 750,
                sizeY: 570,
                labels: tabInfo.headerInfo.labels
            });

            popup.__originalFlexTabberId = tabId;

            popup.setHeaderInfo(tabInfo.headerInfo);

            popup.setRootFrame(tabInfo.tabFrame);

            popup.start();
            tabInfo.tabFrame.getRoot$El().css('display', ''); // make sure the frame if visible, in case the tab was hidden
            tabInfo.tabFrame.getRoot$El().css('opacity', 1); // make sure the frame if visible, in case the tab was hidden
            if (tabInfo.tabFrame.repositionSubFrames) tabInfo.tabFrame.repositionSubFrames(); //done here because elements in an initially invisible tab may not be measured correctly for positioning

            AXMUtils.animateBoxTransition(tabInfo.get$El(), popup.get$El(), {}, function () {
                frame.closeTab_byID(tabId, false, true);
            });
        };

        /**
         * Attempts to activate a tab or a popup window, according to a tab id
         * @param tabId
         * @returns {boolean} - determines whether the tab was found and activated
         */
        frame.tryActivateTabId = function (tabId) {
            if (tabId === undefined) return false;
            if (frame.hasTabId(tabId)) {
                frame.activateTab_byID(tabId);
                return true;
            }
            var popupWindow = null;
            $.each(PopupWindow.getActiveWindowList(), function (idx, popup) {
                if (popup.__originalFlexTabberId == tabId) popupWindow = popup;
            });
            if (popupWindow) {
                popupWindow.bringToTop();
                return true;
            }
            return false;
        };

        /**
         * Defines this flex tabber as the one and only tabber that can be used to dock popup windows
         */
        frame.setAsPopupDocker = function (buttonCloseView, hiderCloseView, viewTitle, viewLabelDict) {
            PopupWindow.docker = function (popup) {
                var tabId = frame.addTabFrame(popup.__originalFlexTabberId, popup.getHeaderInfo(), popup.getRootFrame(), {
                    autoActivate: false
                });
                setTimeout(function () {
                    AXMUtils.animateBoxTransition(popup.get$El(), frame.getTabInfo_byId(tabId).get$El(), {}, function () {
                        popup.close(true);
                    });
                }, 100);
            };

            if (buttonCloseView) {
                frame.hiderCloseView = hiderCloseView;
                buttonCloseView.addNotificationHandler(function () {
                    var currentTabId = frame.getCurrentTabId();
                    if (currentTabId) {
                        var tabInfo = frame.getTabInfo_byId(currentTabId);
                        if (!tabInfo._isFixed) frame.closeTab_byID(currentTabId);
                    }
                });
            }

            frame.viewTitle = viewTitle;
            frame.viewLabelDict = viewLabelDict || {};
        };

        /**
         * Closes a view (tab or undocked popup), provided a tab ID
         * @param tabId
         * @param {boolean} doNotAnimate - if true, there will be no animation for closing the frame
         */
        frame.closeView_byID = function (tabId, doNotAnimate) {
            if (frame.hasTabId(tabId)) {
                frame.closeTab_byID(tabId, doNotAnimate);
            } else {
                $.each(PopupWindow.getActiveWindowList(), function (idx, popupWindow) {
                    if (tabId == popupWindow.__originalFlexTabberId) {
                        popupWindow.close();
                    }
                });
            }
        };

        return frame;
    };

    return Module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ })
/******/ ])});;
//# sourceMappingURL=axiom.js.map